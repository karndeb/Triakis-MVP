import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM,
  require_react
} from "./chunk-KD7XVJGB.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics2;
  }
});

// node_modules/flatbuffers/js/flatbuffers.mjs
var flatbuffers_exports = {};
__export(flatbuffers_exports, {
  flatbuffers: () => flatbuffers
});
var flatbuffers;
var init_flatbuffers = __esm({
  "node_modules/flatbuffers/js/flatbuffers.mjs"() {
    flatbuffers = {};
    flatbuffers.Offset;
    flatbuffers.Table;
    flatbuffers.SIZEOF_SHORT = 2;
    flatbuffers.SIZEOF_INT = 4;
    flatbuffers.FILE_IDENTIFIER_LENGTH = 4;
    flatbuffers.Encoding = {
      UTF8_BYTES: 1,
      UTF16_STRING: 2
    };
    flatbuffers.int32 = new Int32Array(2);
    flatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);
    flatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);
    flatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
    flatbuffers.Long = function(low, high) {
      this.low = low | 0;
      this.high = high | 0;
    };
    flatbuffers.Long.create = function(low, high) {
      return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);
    };
    flatbuffers.Long.prototype.toFloat64 = function() {
      return (this.low >>> 0) + this.high * 4294967296;
    };
    flatbuffers.Long.prototype.equals = function(other) {
      return this.low == other.low && this.high == other.high;
    };
    flatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);
    flatbuffers.Builder = function(opt_initial_size) {
      if (!opt_initial_size) {
        var initial_size = 1024;
      } else {
        var initial_size = opt_initial_size;
      }
      this.bb = flatbuffers.ByteBuffer.allocate(initial_size);
      this.space = initial_size;
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
    };
    flatbuffers.Builder.prototype.clear = function() {
      this.bb.clear();
      this.space = this.bb.capacity();
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
    };
    flatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {
      this.force_defaults = forceDefaults;
    };
    flatbuffers.Builder.prototype.dataBuffer = function() {
      return this.bb;
    };
    flatbuffers.Builder.prototype.asUint8Array = function() {
      return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
    };
    flatbuffers.Builder.prototype.prep = function(size, additional_bytes) {
      if (size > this.minalign) {
        this.minalign = size;
      }
      var align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
      while (this.space < align_size + size + additional_bytes) {
        var old_buf_size = this.bb.capacity();
        this.bb = flatbuffers.Builder.growByteBuffer(this.bb);
        this.space += this.bb.capacity() - old_buf_size;
      }
      this.pad(align_size);
    };
    flatbuffers.Builder.prototype.pad = function(byte_size) {
      for (var i = 0; i < byte_size; i++) {
        this.bb.writeInt8(--this.space, 0);
      }
    };
    flatbuffers.Builder.prototype.writeInt8 = function(value) {
      this.bb.writeInt8(this.space -= 1, value);
    };
    flatbuffers.Builder.prototype.writeInt16 = function(value) {
      this.bb.writeInt16(this.space -= 2, value);
    };
    flatbuffers.Builder.prototype.writeInt32 = function(value) {
      this.bb.writeInt32(this.space -= 4, value);
    };
    flatbuffers.Builder.prototype.writeInt64 = function(value) {
      this.bb.writeInt64(this.space -= 8, value);
    };
    flatbuffers.Builder.prototype.writeFloat32 = function(value) {
      this.bb.writeFloat32(this.space -= 4, value);
    };
    flatbuffers.Builder.prototype.writeFloat64 = function(value) {
      this.bb.writeFloat64(this.space -= 8, value);
    };
    flatbuffers.Builder.prototype.addInt8 = function(value) {
      this.prep(1, 0);
      this.writeInt8(value);
    };
    flatbuffers.Builder.prototype.addInt16 = function(value) {
      this.prep(2, 0);
      this.writeInt16(value);
    };
    flatbuffers.Builder.prototype.addInt32 = function(value) {
      this.prep(4, 0);
      this.writeInt32(value);
    };
    flatbuffers.Builder.prototype.addInt64 = function(value) {
      this.prep(8, 0);
      this.writeInt64(value);
    };
    flatbuffers.Builder.prototype.addFloat32 = function(value) {
      this.prep(4, 0);
      this.writeFloat32(value);
    };
    flatbuffers.Builder.prototype.addFloat64 = function(value) {
      this.prep(8, 0);
      this.writeFloat64(value);
    };
    flatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt8(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt16(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt32(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {
      if (this.force_defaults || !value.equals(defaultValue)) {
        this.addInt64(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat32(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat64(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addOffset(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {
      if (value != defaultValue) {
        this.nested(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.nested = function(obj) {
      if (obj != this.offset()) {
        throw new Error("FlatBuffers: struct must be serialized inline.");
      }
    };
    flatbuffers.Builder.prototype.notNested = function() {
      if (this.isNested) {
        throw new Error("FlatBuffers: object serialization must not be nested.");
      }
    };
    flatbuffers.Builder.prototype.slot = function(voffset) {
      this.vtable[voffset] = this.offset();
    };
    flatbuffers.Builder.prototype.offset = function() {
      return this.bb.capacity() - this.space;
    };
    flatbuffers.Builder.growByteBuffer = function(bb) {
      var old_buf_size = bb.capacity();
      if (old_buf_size & 3221225472) {
        throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
      }
      var new_buf_size = old_buf_size << 1;
      var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);
      nbb.setPosition(new_buf_size - old_buf_size);
      nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
      return nbb;
    };
    flatbuffers.Builder.prototype.addOffset = function(offset) {
      this.prep(flatbuffers.SIZEOF_INT, 0);
      this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);
    };
    flatbuffers.Builder.prototype.startObject = function(numfields) {
      this.notNested();
      if (this.vtable == null) {
        this.vtable = [];
      }
      this.vtable_in_use = numfields;
      for (var i = 0; i < numfields; i++) {
        this.vtable[i] = 0;
      }
      this.isNested = true;
      this.object_start = this.offset();
    };
    flatbuffers.Builder.prototype.endObject = function() {
      if (this.vtable == null || !this.isNested) {
        throw new Error("FlatBuffers: endObject called without startObject");
      }
      this.addInt32(0);
      var vtableloc = this.offset();
      var i = this.vtable_in_use - 1;
      for (; i >= 0 && this.vtable[i] == 0; i--) {
      }
      var trimmed_size = i + 1;
      for (; i >= 0; i--) {
        this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
      }
      var standard_fields = 2;
      this.addInt16(vtableloc - this.object_start);
      var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;
      this.addInt16(len);
      var existing_vtable = 0;
      var vt1 = this.space;
      outer_loop:
        for (i = 0; i < this.vtables.length; i++) {
          var vt2 = this.bb.capacity() - this.vtables[i];
          if (len == this.bb.readInt16(vt2)) {
            for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {
              if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                continue outer_loop;
              }
            }
            existing_vtable = this.vtables[i];
            break;
          }
        }
      if (existing_vtable) {
        this.space = this.bb.capacity() - vtableloc;
        this.bb.writeInt32(this.space, existing_vtable - vtableloc);
      } else {
        this.vtables.push(this.offset());
        this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
      }
      this.isNested = false;
      return vtableloc;
    };
    flatbuffers.Builder.prototype.finish = function(root_table, opt_file_identifier) {
      if (opt_file_identifier) {
        var file_identifier = opt_file_identifier;
        this.prep(this.minalign, flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH);
        if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
          throw new Error("FlatBuffers: file identifier must be length " + flatbuffers.FILE_IDENTIFIER_LENGTH);
        }
        for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
          this.writeInt8(file_identifier.charCodeAt(i));
        }
      }
      this.prep(this.minalign, flatbuffers.SIZEOF_INT);
      this.addOffset(root_table);
      this.bb.setPosition(this.space);
    };
    flatbuffers.Builder.prototype.requiredField = function(table, field) {
      var table_start = this.bb.capacity() - table;
      var vtable_start = table_start - this.bb.readInt32(table_start);
      var ok = this.bb.readInt16(vtable_start + field) != 0;
      if (!ok) {
        throw new Error("FlatBuffers: field " + field + " must be set");
      }
    };
    flatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {
      this.notNested();
      this.vector_num_elems = num_elems;
      this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);
      this.prep(alignment, elem_size * num_elems);
    };
    flatbuffers.Builder.prototype.endVector = function() {
      this.writeInt32(this.vector_num_elems);
      return this.offset();
    };
    flatbuffers.Builder.prototype.createString = function(s) {
      if (s instanceof Uint8Array) {
        var utf8 = s;
      } else {
        var utf8 = [];
        var i = 0;
        while (i < s.length) {
          var codePoint;
          var a = s.charCodeAt(i++);
          if (a < 55296 || a >= 56320) {
            codePoint = a;
          } else {
            var b = s.charCodeAt(i++);
            codePoint = (a << 10) + b + (65536 - (55296 << 10) - 56320);
          }
          if (codePoint < 128) {
            utf8.push(codePoint);
          } else {
            if (codePoint < 2048) {
              utf8.push(codePoint >> 6 & 31 | 192);
            } else {
              if (codePoint < 65536) {
                utf8.push(codePoint >> 12 & 15 | 224);
              } else {
                utf8.push(
                  codePoint >> 18 & 7 | 240,
                  codePoint >> 12 & 63 | 128
                );
              }
              utf8.push(codePoint >> 6 & 63 | 128);
            }
            utf8.push(codePoint & 63 | 128);
          }
        }
      }
      this.addInt8(0);
      this.startVector(1, utf8.length, 1);
      this.bb.setPosition(this.space -= utf8.length);
      for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
        bytes[offset++] = utf8[i];
      }
      return this.endVector();
    };
    flatbuffers.Builder.prototype.createLong = function(low, high) {
      return flatbuffers.Long.create(low, high);
    };
    flatbuffers.ByteBuffer = function(bytes) {
      this.bytes_ = bytes;
      this.position_ = 0;
    };
    flatbuffers.ByteBuffer.allocate = function(byte_size) {
      return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));
    };
    flatbuffers.ByteBuffer.prototype.clear = function() {
      this.position_ = 0;
    };
    flatbuffers.ByteBuffer.prototype.bytes = function() {
      return this.bytes_;
    };
    flatbuffers.ByteBuffer.prototype.position = function() {
      return this.position_;
    };
    flatbuffers.ByteBuffer.prototype.setPosition = function(position) {
      this.position_ = position;
    };
    flatbuffers.ByteBuffer.prototype.capacity = function() {
      return this.bytes_.length;
    };
    flatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {
      return this.readUint8(offset) << 24 >> 24;
    };
    flatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {
      return this.bytes_[offset];
    };
    flatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {
      return this.readUint16(offset) << 16 >> 16;
    };
    flatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
    };
    flatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
    };
    flatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {
      return this.readInt32(offset) >>> 0;
    };
    flatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {
      return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));
    };
    flatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {
      return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));
    };
    flatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {
      flatbuffers.int32[0] = this.readInt32(offset);
      return flatbuffers.float32[0];
    };
    flatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {
      flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);
      flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
      return flatbuffers.float64[0];
    };
    flatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {
      this.bytes_[offset] = value;
    };
    flatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {
      this.bytes_[offset] = value;
    };
    flatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    };
    flatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    };
    flatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    };
    flatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    };
    flatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {
      this.writeInt32(offset, value.low);
      this.writeInt32(offset + 4, value.high);
    };
    flatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {
      this.writeUint32(offset, value.low);
      this.writeUint32(offset + 4, value.high);
    };
    flatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {
      flatbuffers.float32[0] = value;
      this.writeInt32(offset, flatbuffers.int32[0]);
    };
    flatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {
      flatbuffers.float64[0] = value;
      this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);
      this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);
    };
    flatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {
      if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH) {
        throw new Error(
          "FlatBuffers: ByteBuffer is too short to contain an identifier."
        );
      }
      var result = "";
      for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
        result += String.fromCharCode(
          this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)
        );
      }
      return result;
    };
    flatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {
      var vtable = bb_pos - this.readInt32(bb_pos);
      return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
    };
    flatbuffers.ByteBuffer.prototype.__union = function(t, offset) {
      t.bb_pos = offset + this.readInt32(offset);
      t.bb = this;
      return t;
    };
    flatbuffers.ByteBuffer.prototype.__string = function(offset, opt_encoding) {
      offset += this.readInt32(offset);
      var length = this.readInt32(offset);
      var result = "";
      var i = 0;
      offset += flatbuffers.SIZEOF_INT;
      if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {
        return this.bytes_.subarray(offset, offset + length);
      }
      while (i < length) {
        var codePoint;
        var a = this.readUint8(offset + i++);
        if (a < 192) {
          codePoint = a;
        } else {
          var b = this.readUint8(offset + i++);
          if (a < 224) {
            codePoint = (a & 31) << 6 | b & 63;
          } else {
            var c = this.readUint8(offset + i++);
            if (a < 240) {
              codePoint = (a & 15) << 12 | (b & 63) << 6 | c & 63;
            } else {
              var d = this.readUint8(offset + i++);
              codePoint = (a & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d & 63;
            }
          }
        }
        if (codePoint < 65536) {
          result += String.fromCharCode(codePoint);
        } else {
          codePoint -= 65536;
          result += String.fromCharCode(
            (codePoint >> 10) + 55296,
            (codePoint & (1 << 10) - 1) + 56320
          );
        }
      }
      return result;
    };
    flatbuffers.ByteBuffer.prototype.__indirect = function(offset) {
      return offset + this.readInt32(offset);
    };
    flatbuffers.ByteBuffer.prototype.__vector = function(offset) {
      return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT;
    };
    flatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {
      return this.readInt32(offset + this.readInt32(offset));
    };
    flatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {
      if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
        throw new Error("FlatBuffers: file identifier must be length " + flatbuffers.FILE_IDENTIFIER_LENGTH);
      }
      for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
        if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {
          return false;
        }
      }
      return true;
    };
    flatbuffers.ByteBuffer.prototype.createLong = function(low, high) {
      return flatbuffers.Long.create(low, high);
    };
  }
});

// node_modules/text-encoding-utf-8/src/encoding.js
var encoding_exports = {};
__export(encoding_exports, {
  TextDecoder: () => TextDecoder2,
  TextEncoder: () => TextEncoder2
});
function inRange(a, min, max) {
  return min <= a && a <= max;
}
function ToDictionary(o) {
  if (o === void 0)
    return {};
  if (o === Object(o))
    return o;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(string) {
  var s = String(string);
  var n = s.length;
  var i = 0;
  var u = [];
  while (i < n) {
    var c = s.charCodeAt(i);
    if (c < 55296 || c > 57343) {
      u.push(c);
    } else if (56320 <= c && c <= 57343) {
      u.push(65533);
    } else if (55296 <= c && c <= 56319) {
      if (i === n - 1) {
        u.push(65533);
      } else {
        var d = string.charCodeAt(i + 1);
        if (56320 <= d && d <= 57343) {
          var a = c & 1023;
          var b = d & 1023;
          u.push(65536 + (a << 10) + b);
          i += 1;
        } else {
          u.push(65533);
        }
      }
    }
    i += 1;
  }
  return u;
}
function codePointsToString(code_points) {
  var s = "";
  for (var i = 0; i < code_points.length; ++i) {
    var cp = code_points[i];
    if (cp <= 65535) {
      s += String.fromCharCode(cp);
    } else {
      cp -= 65536;
      s += String.fromCharCode(
        (cp >> 10) + 55296,
        (cp & 1023) + 56320
      );
    }
  }
  return s;
}
function Stream(tokens) {
  this.tokens = [].slice.call(tokens);
}
function decoderError(fatal, opt_code_point) {
  if (fatal)
    throw TypeError("Decoder error");
  return opt_code_point || 65533;
}
function Decoder() {
}
function Encoder() {
}
function TextDecoder2(encoding, options) {
  if (!(this instanceof TextDecoder2)) {
    return new TextDecoder2(encoding, options);
  }
  encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._BOMseen = false;
  this._decoder = null;
  this._fatal = Boolean(options["fatal"]);
  this._ignoreBOM = Boolean(options["ignoreBOM"]);
  Object.defineProperty(this, "encoding", { value: "utf-8" });
  Object.defineProperty(this, "fatal", { value: this._fatal });
  Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
function TextEncoder2(encoding, options) {
  if (!(this instanceof TextEncoder2))
    return new TextEncoder2(encoding, options);
  encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
  if (encoding !== DEFAULT_ENCODING) {
    throw new Error("Encoding not supported. Only utf-8 is supported");
  }
  options = ToDictionary(options);
  this._streaming = false;
  this._encoder = null;
  this._options = { fatal: Boolean(options["fatal"]) };
  Object.defineProperty(this, "encoding", { value: "utf-8" });
}
function UTF8Decoder(options) {
  var fatal = options.fatal;
  var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
  this.handler = function(stream, bite) {
    if (bite === end_of_stream && utf8_bytes_needed !== 0) {
      utf8_bytes_needed = 0;
      return decoderError(fatal);
    }
    if (bite === end_of_stream)
      return finished;
    if (utf8_bytes_needed === 0) {
      if (inRange(bite, 0, 127)) {
        return bite;
      }
      if (inRange(bite, 194, 223)) {
        utf8_bytes_needed = 1;
        utf8_code_point = bite - 192;
      } else if (inRange(bite, 224, 239)) {
        if (bite === 224)
          utf8_lower_boundary = 160;
        if (bite === 237)
          utf8_upper_boundary = 159;
        utf8_bytes_needed = 2;
        utf8_code_point = bite - 224;
      } else if (inRange(bite, 240, 244)) {
        if (bite === 240)
          utf8_lower_boundary = 144;
        if (bite === 244)
          utf8_upper_boundary = 143;
        utf8_bytes_needed = 3;
        utf8_code_point = bite - 240;
      } else {
        return decoderError(fatal);
      }
      utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
      return null;
    }
    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
      utf8_lower_boundary = 128;
      utf8_upper_boundary = 191;
      stream.prepend(bite);
      return decoderError(fatal);
    }
    utf8_lower_boundary = 128;
    utf8_upper_boundary = 191;
    utf8_bytes_seen += 1;
    utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
    if (utf8_bytes_seen !== utf8_bytes_needed)
      return null;
    var code_point = utf8_code_point;
    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
    return code_point;
  };
}
function UTF8Encoder(options) {
  var fatal = options.fatal;
  this.handler = function(stream, code_point) {
    if (code_point === end_of_stream)
      return finished;
    if (inRange(code_point, 0, 127))
      return code_point;
    var count, offset;
    if (inRange(code_point, 128, 2047)) {
      count = 1;
      offset = 192;
    } else if (inRange(code_point, 2048, 65535)) {
      count = 2;
      offset = 224;
    } else if (inRange(code_point, 65536, 1114111)) {
      count = 3;
      offset = 240;
    }
    var bytes = [(code_point >> 6 * count) + offset];
    while (count > 0) {
      var temp = code_point >> 6 * (count - 1);
      bytes.push(128 | temp & 63);
      count -= 1;
    }
    return bytes;
  };
}
var end_of_stream, finished, DEFAULT_ENCODING;
var init_encoding = __esm({
  "node_modules/text-encoding-utf-8/src/encoding.js"() {
    "use strict";
    end_of_stream = -1;
    Stream.prototype = {
      endOfStream: function() {
        return !this.tokens.length;
      },
      read: function() {
        if (!this.tokens.length)
          return end_of_stream;
        return this.tokens.shift();
      },
      prepend: function(token) {
        if (Array.isArray(token)) {
          var tokens = token;
          while (tokens.length)
            this.tokens.unshift(tokens.pop());
        } else {
          this.tokens.unshift(token);
        }
      },
      push: function(token) {
        if (Array.isArray(token)) {
          var tokens = token;
          while (tokens.length)
            this.tokens.push(tokens.shift());
        } else {
          this.tokens.push(token);
        }
      }
    };
    finished = -1;
    Decoder.prototype = {
      handler: function(stream, bite) {
      }
    };
    Encoder.prototype = {
      handler: function(stream, code_point) {
      }
    };
    DEFAULT_ENCODING = "utf-8";
    TextDecoder2.prototype = {
      decode: function decode(input, options) {
        var bytes;
        if (typeof input === "object" && input instanceof ArrayBuffer) {
          bytes = new Uint8Array(input);
        } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
          bytes = new Uint8Array(
            input.buffer,
            input.byteOffset,
            input.byteLength
          );
        } else {
          bytes = new Uint8Array(0);
        }
        options = ToDictionary(options);
        if (!this._streaming) {
          this._decoder = new UTF8Decoder({ fatal: this._fatal });
          this._BOMseen = false;
        }
        this._streaming = Boolean(options["stream"]);
        var input_stream = new Stream(bytes);
        var code_points = [];
        var result;
        while (!input_stream.endOfStream()) {
          result = this._decoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (result === null)
            continue;
          if (Array.isArray(result))
            code_points.push.apply(code_points, result);
          else
            code_points.push(result);
        }
        if (!this._streaming) {
          do {
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (result === null)
              continue;
            if (Array.isArray(result))
              code_points.push.apply(code_points, result);
            else
              code_points.push(result);
          } while (!input_stream.endOfStream());
          this._decoder = null;
        }
        if (code_points.length) {
          if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
            if (code_points[0] === 65279) {
              this._BOMseen = true;
              code_points.shift();
            } else {
              this._BOMseen = true;
            }
          }
        }
        return codePointsToString(code_points);
      }
    };
    TextEncoder2.prototype = {
      encode: function encode(opt_string, options) {
        opt_string = opt_string ? String(opt_string) : "";
        options = ToDictionary(options);
        if (!this._streaming)
          this._encoder = new UTF8Encoder(this._options);
        this._streaming = Boolean(options["stream"]);
        var bytes = [];
        var input_stream = new Stream(stringToCodePoints(opt_string));
        var result;
        while (!input_stream.endOfStream()) {
          result = this._encoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (Array.isArray(result))
            bytes.push.apply(bytes, result);
          else
            bytes.push(result);
        }
        if (!this._streaming) {
          while (true) {
            result = this._encoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (Array.isArray(result))
              bytes.push.apply(bytes, result);
            else
              bytes.push(result);
          }
          this._encoder = null;
        }
        return new Uint8Array(bytes);
      }
    };
  }
});

// node_modules/apache-arrow/util/utf8.js
var require_utf8 = __commonJS({
  "node_modules/apache-arrow/util/utf8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require_buffer();
    var text_encoding_utf_8_1 = (init_encoding(), __toCommonJS(encoding_exports));
    var _Buffer = typeof Buffer === "function" ? Buffer : null;
    var useNativeEncoders = typeof TextDecoder === "function" && typeof TextEncoder === "function";
    exports.decodeUtf8 = ((TextDecoder3) => {
      if (useNativeEncoders || !_Buffer) {
        const decoder = new TextDecoder3("utf-8");
        return (buffer) => decoder.decode(buffer);
      }
      return (input) => {
        const { buffer, byteOffset, length } = buffer_1.toUint8Array(input);
        return _Buffer.from(buffer, byteOffset, length).toString();
      };
    })(typeof TextDecoder !== "undefined" ? TextDecoder : text_encoding_utf_8_1.TextDecoder);
    exports.encodeUtf8 = ((TextEncoder3) => {
      if (useNativeEncoders || !_Buffer) {
        const encoder = new TextEncoder3();
        return (value) => encoder.encode(value);
      }
      return (input = "") => buffer_1.toUint8Array(_Buffer.from(input, "utf8"));
    })(typeof TextEncoder !== "undefined" ? TextEncoder : text_encoding_utf_8_1.TextEncoder);
  }
});

// node_modules/apache-arrow/io/interfaces.js
var require_interfaces = __commonJS({
  "node_modules/apache-arrow/io/interfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var adapters_1 = require_adapters();
    exports.ITERATOR_DONE = Object.freeze({ done: true, value: void 0 });
    var ArrowJSON = class {
      constructor(_json) {
        this._json = _json;
      }
      get schema() {
        return this._json["schema"];
      }
      get batches() {
        return this._json["batches"] || [];
      }
      get dictionaries() {
        return this._json["dictionaries"] || [];
      }
    };
    exports.ArrowJSON = ArrowJSON;
    var ReadableInterop = class {
      tee() {
        return this._getDOMStream().tee();
      }
      pipe(writable, options) {
        return this._getNodeStream().pipe(writable, options);
      }
      pipeTo(writable, options) {
        return this._getDOMStream().pipeTo(writable, options);
      }
      pipeThrough(duplex, options) {
        return this._getDOMStream().pipeThrough(duplex, options);
      }
      _getDOMStream() {
        return this._DOMStream || (this._DOMStream = this.toDOMStream());
      }
      _getNodeStream() {
        return this._nodeStream || (this._nodeStream = this.toNodeStream());
      }
    };
    exports.ReadableInterop = ReadableInterop;
    var AsyncQueue = class extends ReadableInterop {
      constructor() {
        super();
        this._values = [];
        this.resolvers = [];
        this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
      }
      get closed() {
        return this._closedPromise;
      }
      async cancel(reason) {
        await this.return(reason);
      }
      write(value) {
        if (this._ensureOpen()) {
          this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({ done: false, value });
        }
      }
      abort(value) {
        if (this._closedPromiseResolve) {
          this.resolvers.length <= 0 ? this._error = { error: value } : this.resolvers.shift().reject({ done: true, value });
        }
      }
      close() {
        if (this._closedPromiseResolve) {
          const { resolvers } = this;
          while (resolvers.length > 0) {
            resolvers.shift().resolve(exports.ITERATOR_DONE);
          }
          this._closedPromiseResolve();
          this._closedPromiseResolve = void 0;
        }
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      toDOMStream(options) {
        return adapters_1.default.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);
      }
      toNodeStream(options) {
        return adapters_1.default.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);
      }
      async throw(_) {
        await this.abort(_);
        return exports.ITERATOR_DONE;
      }
      async return(_) {
        await this.close();
        return exports.ITERATOR_DONE;
      }
      async read(size) {
        return (await this.next(size, "read")).value;
      }
      async peek(size) {
        return (await this.next(size, "peek")).value;
      }
      next(..._args) {
        if (this._values.length > 0) {
          return Promise.resolve({ done: false, value: this._values.shift() });
        } else if (this._error) {
          return Promise.reject({ done: true, value: this._error.error });
        } else if (!this._closedPromiseResolve) {
          return Promise.resolve(exports.ITERATOR_DONE);
        } else {
          return new Promise((resolve, reject) => {
            this.resolvers.push({ resolve, reject });
          });
        }
      }
      _ensureOpen() {
        if (this._closedPromiseResolve) {
          return true;
        }
        throw new Error(`${this} is closed`);
      }
    };
    exports.AsyncQueue = AsyncQueue;
  }
});

// node_modules/apache-arrow/util/compat.js
var require_compat = __commonJS({
  "node_modules/apache-arrow/util/compat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var interfaces_1 = require_interfaces();
    var [BigIntCtor, BigIntAvailable] = (() => {
      const BigIntUnavailableError = () => {
        throw new Error("BigInt is not available in this environment");
      };
      function BigIntUnavailable() {
        throw BigIntUnavailableError();
      }
      BigIntUnavailable.asIntN = () => {
        throw BigIntUnavailableError();
      };
      BigIntUnavailable.asUintN = () => {
        throw BigIntUnavailableError();
      };
      return typeof BigInt !== "undefined" ? [BigInt, true] : [BigIntUnavailable, false];
    })();
    exports.BigInt = BigIntCtor;
    exports.BigIntAvailable = BigIntAvailable;
    var [BigInt64ArrayCtor, BigInt64ArrayAvailable] = (() => {
      const BigInt64ArrayUnavailableError = () => {
        throw new Error("BigInt64Array is not available in this environment");
      };
      class BigInt64ArrayUnavailable {
        static get BYTES_PER_ELEMENT() {
          return 8;
        }
        static of() {
          throw BigInt64ArrayUnavailableError();
        }
        static from() {
          throw BigInt64ArrayUnavailableError();
        }
        constructor() {
          throw BigInt64ArrayUnavailableError();
        }
      }
      return typeof BigInt64Array !== "undefined" ? [BigInt64Array, true] : [BigInt64ArrayUnavailable, false];
    })();
    exports.BigInt64Array = BigInt64ArrayCtor;
    exports.BigInt64ArrayAvailable = BigInt64ArrayAvailable;
    var [BigUint64ArrayCtor, BigUint64ArrayAvailable] = (() => {
      const BigUint64ArrayUnavailableError = () => {
        throw new Error("BigUint64Array is not available in this environment");
      };
      class BigUint64ArrayUnavailable {
        static get BYTES_PER_ELEMENT() {
          return 8;
        }
        static of() {
          throw BigUint64ArrayUnavailableError();
        }
        static from() {
          throw BigUint64ArrayUnavailableError();
        }
        constructor() {
          throw BigUint64ArrayUnavailableError();
        }
      }
      return typeof BigUint64Array !== "undefined" ? [BigUint64Array, true] : [BigUint64ArrayUnavailable, false];
    })();
    exports.BigUint64Array = BigUint64ArrayCtor;
    exports.BigUint64ArrayAvailable = BigUint64ArrayAvailable;
    var isNumber = (x) => typeof x === "number";
    var isBoolean = (x) => typeof x === "boolean";
    var isFunction = (x) => typeof x === "function";
    exports.isObject = (x) => x != null && Object(x) === x;
    exports.isPromise = (x) => {
      return exports.isObject(x) && isFunction(x.then);
    };
    exports.isObservable = (x) => {
      return exports.isObject(x) && isFunction(x.subscribe);
    };
    exports.isIterable = (x) => {
      return exports.isObject(x) && isFunction(x[Symbol.iterator]);
    };
    exports.isAsyncIterable = (x) => {
      return exports.isObject(x) && isFunction(x[Symbol.asyncIterator]);
    };
    exports.isArrowJSON = (x) => {
      return exports.isObject(x) && exports.isObject(x["schema"]);
    };
    exports.isArrayLike = (x) => {
      return exports.isObject(x) && isNumber(x["length"]);
    };
    exports.isIteratorResult = (x) => {
      return exports.isObject(x) && "done" in x && "value" in x;
    };
    exports.isUnderlyingSink = (x) => {
      return exports.isObject(x) && isFunction(x["abort"]) && isFunction(x["close"]) && isFunction(x["start"]) && isFunction(x["write"]);
    };
    exports.isFileHandle = (x) => {
      return exports.isObject(x) && isFunction(x["stat"]) && isNumber(x["fd"]);
    };
    exports.isFSReadStream = (x) => {
      return exports.isReadableNodeStream(x) && isNumber(x["bytesRead"]);
    };
    exports.isFetchResponse = (x) => {
      return exports.isObject(x) && exports.isReadableDOMStream(x["body"]);
    };
    exports.isWritableDOMStream = (x) => {
      return exports.isObject(x) && isFunction(x["abort"]) && isFunction(x["getWriter"]) && !(x instanceof interfaces_1.ReadableInterop);
    };
    exports.isReadableDOMStream = (x) => {
      return exports.isObject(x) && isFunction(x["cancel"]) && isFunction(x["getReader"]) && !(x instanceof interfaces_1.ReadableInterop);
    };
    exports.isWritableNodeStream = (x) => {
      return exports.isObject(x) && isFunction(x["end"]) && isFunction(x["write"]) && isBoolean(x["writable"]) && !(x instanceof interfaces_1.ReadableInterop);
    };
    exports.isReadableNodeStream = (x) => {
      return exports.isObject(x) && isFunction(x["read"]) && isFunction(x["pipe"]) && isBoolean(x["readable"]) && !(x instanceof interfaces_1.ReadableInterop);
    };
  }
});

// node_modules/apache-arrow/util/buffer.js
var require_buffer = __commonJS({
  "node_modules/apache-arrow/util/buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var flatbuffers_1 = (init_flatbuffers(), __toCommonJS(flatbuffers_exports));
    var utf8_1 = require_utf8();
    var ByteBuffer = flatbuffers_1.flatbuffers.ByteBuffer;
    var compat_1 = require_compat();
    var SharedArrayBuf = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : ArrayBuffer;
    function collapseContiguousByteRanges(chunks) {
      let result = chunks[0] ? [chunks[0]] : [];
      let xOffset, yOffset, xLen, yLen;
      for (let x, y, i = 0, j = 0, n = chunks.length; ++i < n; ) {
        x = result[j];
        y = chunks[i];
        if (!x || !y || x.buffer !== y.buffer || y.byteOffset < x.byteOffset) {
          y && (result[++j] = y);
          continue;
        }
        ({ byteOffset: xOffset, byteLength: xLen } = x);
        ({ byteOffset: yOffset, byteLength: yLen } = y);
        if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {
          y && (result[++j] = y);
          continue;
        }
        result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);
      }
      return result;
    }
    function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
      const targetByteLength = target.byteLength;
      const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
      const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
      dst.set(src, targetByteOffset);
      return target;
    }
    exports.memcpy = memcpy;
    function joinUint8Arrays(chunks, size) {
      let result = collapseContiguousByteRanges(chunks);
      let byteLength = result.reduce((x, b) => x + b.byteLength, 0);
      let source, sliced, buffer;
      let offset = 0, index = -1, length = Math.min(size || Infinity, byteLength);
      for (let n = result.length; ++index < n; ) {
        source = result[index];
        sliced = source.subarray(0, Math.min(source.length, length - offset));
        if (length <= offset + sliced.length) {
          if (sliced.length < source.length) {
            result[index] = source.subarray(sliced.length);
          } else if (sliced.length === source.length) {
            index++;
          }
          buffer ? memcpy(buffer, sliced, offset) : buffer = sliced;
          break;
        }
        memcpy(buffer || (buffer = new Uint8Array(length)), sliced, offset);
        offset += sliced.length;
      }
      return [buffer || new Uint8Array(0), result.slice(index), byteLength - (buffer ? buffer.byteLength : 0)];
    }
    exports.joinUint8Arrays = joinUint8Arrays;
    function toArrayBufferView(ArrayBufferViewCtor, input) {
      let value = compat_1.isIteratorResult(input) ? input.value : input;
      if (value instanceof ArrayBufferViewCtor) {
        if (ArrayBufferViewCtor === Uint8Array) {
          return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
        }
        return value;
      }
      if (!value) {
        return new ArrayBufferViewCtor(0);
      }
      if (typeof value === "string") {
        value = utf8_1.encodeUtf8(value);
      }
      if (value instanceof ArrayBuffer) {
        return new ArrayBufferViewCtor(value);
      }
      if (value instanceof SharedArrayBuf) {
        return new ArrayBufferViewCtor(value);
      }
      if (value instanceof ByteBuffer) {
        return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
      }
      return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0) : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
    }
    exports.toArrayBufferView = toArrayBufferView;
    exports.toInt8Array = (input) => toArrayBufferView(Int8Array, input);
    exports.toInt16Array = (input) => toArrayBufferView(Int16Array, input);
    exports.toInt32Array = (input) => toArrayBufferView(Int32Array, input);
    exports.toBigInt64Array = (input) => toArrayBufferView(compat_1.BigInt64Array, input);
    exports.toUint8Array = (input) => toArrayBufferView(Uint8Array, input);
    exports.toUint16Array = (input) => toArrayBufferView(Uint16Array, input);
    exports.toUint32Array = (input) => toArrayBufferView(Uint32Array, input);
    exports.toBigUint64Array = (input) => toArrayBufferView(compat_1.BigUint64Array, input);
    exports.toFloat32Array = (input) => toArrayBufferView(Float32Array, input);
    exports.toFloat64Array = (input) => toArrayBufferView(Float64Array, input);
    exports.toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
    var pump = (iterator) => {
      iterator.next();
      return iterator;
    };
    function* toArrayBufferViewIterator(ArrayCtor, source) {
      const wrap = function* (x) {
        yield x;
      };
      const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : !compat_1.isIterable(source) ? wrap(source) : source;
      yield* pump(function* (it) {
        let r = null;
        do {
          r = it.next(yield toArrayBufferView(ArrayCtor, r));
        } while (!r.done);
      }(buffers[Symbol.iterator]()));
    }
    exports.toArrayBufferViewIterator = toArrayBufferViewIterator;
    exports.toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);
    exports.toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);
    exports.toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);
    exports.toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);
    exports.toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);
    exports.toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);
    exports.toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);
    exports.toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);
    exports.toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
    async function* toArrayBufferViewAsyncIterator(ArrayCtor, source) {
      if (compat_1.isPromise(source)) {
        return yield* toArrayBufferViewAsyncIterator(ArrayCtor, await source);
      }
      const wrap = async function* (x) {
        yield await x;
      };
      const emit = async function* (source2) {
        yield* pump(function* (it) {
          let r = null;
          do {
            r = it.next(yield r && r.value);
          } while (!r.done);
        }(source2[Symbol.iterator]()));
      };
      const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : compat_1.isIterable(source) ? emit(source) : !compat_1.isAsyncIterable(source) ? wrap(source) : source;
      yield* pump(async function* (it) {
        let r = null;
        do {
          r = await it.next(yield toArrayBufferView(ArrayCtor, r));
        } while (!r.done);
      }(buffers[Symbol.asyncIterator]()));
    }
    exports.toArrayBufferViewAsyncIterator = toArrayBufferViewAsyncIterator;
    exports.toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);
    exports.toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);
    exports.toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);
    exports.toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
    exports.toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
    exports.toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
    exports.toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
    exports.toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
    exports.toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
    function rebaseValueOffsets(offset, length, valueOffsets) {
      if (offset !== 0) {
        valueOffsets = valueOffsets.slice(0, length + 1);
        for (let i = -1; ++i <= length; ) {
          valueOffsets[i] += offset;
        }
      }
      return valueOffsets;
    }
    exports.rebaseValueOffsets = rebaseValueOffsets;
    function compareArrayLike(a, b) {
      let i = 0, n = a.length;
      if (n !== b.length) {
        return false;
      }
      if (n > 0) {
        do {
          if (a[i] !== b[i]) {
            return false;
          }
        } while (++i < n);
      }
      return true;
    }
    exports.compareArrayLike = compareArrayLike;
  }
});

// node_modules/apache-arrow/io/adapters.js
var require_adapters = __commonJS({
  "node_modules/apache-arrow/io/adapters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require_buffer();
    exports.default = {
      fromIterable(source) {
        return pump(fromIterable(source));
      },
      fromAsyncIterable(source) {
        return pump(fromAsyncIterable(source));
      },
      fromDOMStream(source) {
        return pump(fromDOMStream(source));
      },
      fromNodeStream(stream) {
        return pump(fromNodeStream(stream));
      },
      toDOMStream(source, options) {
        throw new Error(`"toDOMStream" not available in this environment`);
      },
      toNodeStream(source, options) {
        throw new Error(`"toNodeStream" not available in this environment`);
      }
    };
    var pump = (iterator) => {
      iterator.next();
      return iterator;
    };
    function* fromIterable(source) {
      let done, threw = false;
      let buffers = [], buffer;
      let cmd, size, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return buffer_1.joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = buffer_1.joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield null);
      let it = buffer_1.toUint8ArrayIterator(source)[Symbol.iterator]();
      try {
        do {
          ({ done, value: buffer } = isNaN(size - bufferLength) ? it.next(void 0) : it.next(size - bufferLength));
          if (!done && buffer.byteLength > 0) {
            buffers.push(buffer);
            bufferLength += buffer.byteLength;
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield byteRange());
            } while (size < bufferLength);
          }
        } while (!done);
      } catch (e) {
        (threw = true) && typeof it.throw === "function" && it.throw(e);
      } finally {
        threw === false && typeof it.return === "function" && it.return();
      }
    }
    async function* fromAsyncIterable(source) {
      let done, threw = false;
      let buffers = [], buffer;
      let cmd, size, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return buffer_1.joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = buffer_1.joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield null);
      let it = buffer_1.toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();
      try {
        do {
          ({ done, value: buffer } = isNaN(size - bufferLength) ? await it.next(void 0) : await it.next(size - bufferLength));
          if (!done && buffer.byteLength > 0) {
            buffers.push(buffer);
            bufferLength += buffer.byteLength;
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield byteRange());
            } while (size < bufferLength);
          }
        } while (!done);
      } catch (e) {
        (threw = true) && typeof it.throw === "function" && await it.throw(e);
      } finally {
        threw === false && typeof it.return === "function" && await it.return();
      }
    }
    async function* fromDOMStream(source) {
      let done = false, threw = false;
      let buffers = [], buffer;
      let cmd, size, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return buffer_1.joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = buffer_1.joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield null);
      let it = new AdaptiveByteReader(source);
      try {
        do {
          ({ done, value: buffer } = isNaN(size - bufferLength) ? await it["read"](void 0) : await it["read"](size - bufferLength));
          if (!done && buffer.byteLength > 0) {
            buffers.push(buffer_1.toUint8Array(buffer));
            bufferLength += buffer.byteLength;
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield byteRange());
            } while (size < bufferLength);
          }
        } while (!done);
      } catch (e) {
        (threw = true) && await it["cancel"](e);
      } finally {
        threw === false ? await it["cancel"]() : source["locked"] && it.releaseLock();
      }
    }
    var AdaptiveByteReader = class {
      constructor(source) {
        this.source = source;
        this.byobReader = null;
        this.defaultReader = null;
        try {
          this.supportsBYOB = !!(this.reader = this.getBYOBReader());
        } catch (e) {
          this.supportsBYOB = !!!(this.reader = this.getDefaultReader());
        }
      }
      get closed() {
        return this.reader ? this.reader["closed"].catch(() => {
        }) : Promise.resolve();
      }
      releaseLock() {
        if (this.reader) {
          this.reader.releaseLock();
        }
        this.reader = this.byobReader = this.defaultReader = null;
      }
      async cancel(reason) {
        const { reader, source } = this;
        reader && await reader["cancel"](reason).catch(() => {
        });
        source && (source["locked"] && this.releaseLock());
      }
      async read(size) {
        if (size === 0) {
          return { done: this.reader == null, value: new Uint8Array(0) };
        }
        const result = !this.supportsBYOB || typeof size !== "number" ? await this.getDefaultReader().read() : await this.readFromBYOBReader(size);
        !result.done && (result.value = buffer_1.toUint8Array(result));
        return result;
      }
      getDefaultReader() {
        if (this.byobReader) {
          this.releaseLock();
        }
        if (!this.defaultReader) {
          this.defaultReader = this.source["getReader"]();
          this.defaultReader["closed"].catch(() => {
          });
        }
        return this.reader = this.defaultReader;
      }
      getBYOBReader() {
        if (this.defaultReader) {
          this.releaseLock();
        }
        if (!this.byobReader) {
          this.byobReader = this.source["getReader"]({ mode: "byob" });
          this.byobReader["closed"].catch(() => {
          });
        }
        return this.reader = this.byobReader;
      }
      async readFromBYOBReader(size) {
        return await readInto(this.getBYOBReader(), new ArrayBuffer(size), 0, size);
      }
    };
    async function readInto(reader, buffer, offset, size) {
      if (offset >= size) {
        return { done: false, value: new Uint8Array(buffer, 0, size) };
      }
      const { done, value } = await reader.read(new Uint8Array(buffer, offset, size - offset));
      if ((offset += value.byteLength) < size && !done) {
        return await readInto(reader, value.buffer, offset, size);
      }
      return { done, value: new Uint8Array(value.buffer, 0, offset) };
    }
    var onEvent = (stream, event) => {
      let handler = (_) => resolve([event, _]);
      let resolve;
      return [event, handler, new Promise((r) => (resolve = r) && stream["once"](event, handler))];
    };
    async function* fromNodeStream(stream) {
      let events = [];
      let event = "error";
      let done = false, err = null;
      let cmd, size, bufferLength = 0;
      let buffers = [], buffer;
      function byteRange() {
        if (cmd === "peek") {
          return buffer_1.joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = buffer_1.joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield null);
      if (stream["isTTY"]) {
        return yield new Uint8Array(0);
      }
      try {
        events[0] = onEvent(stream, "end");
        events[1] = onEvent(stream, "error");
        do {
          events[2] = onEvent(stream, "readable");
          [event, err] = await Promise.race(events.map((x) => x[2]));
          if (event === "error") {
            break;
          }
          if (!(done = event === "end")) {
            if (!isFinite(size - bufferLength)) {
              buffer = buffer_1.toUint8Array(stream["read"](void 0));
            } else {
              buffer = buffer_1.toUint8Array(stream["read"](size - bufferLength));
              if (buffer.byteLength < size - bufferLength) {
                buffer = buffer_1.toUint8Array(stream["read"](void 0));
              }
            }
            if (buffer.byteLength > 0) {
              buffers.push(buffer);
              bufferLength += buffer.byteLength;
            }
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield byteRange());
            } while (size < bufferLength);
          }
        } while (!done);
      } finally {
        await cleanup(events, event === "error" ? err : null);
      }
      function cleanup(events2, err2) {
        buffer = buffers = null;
        return new Promise(async (resolve, reject) => {
          for (const [evt, fn] of events2) {
            stream["off"](evt, fn);
          }
          try {
            const destroy = stream["destroy"];
            destroy && destroy.call(stream, err2);
            err2 = void 0;
          } catch (e) {
            err2 = e || err2;
          } finally {
            err2 != null ? reject(err2) : resolve();
          }
        });
      }
    }
  }
});

// node_modules/apache-arrow/vector.js
var require_vector = __commonJS({
  "node_modules/apache-arrow/vector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var AbstractVector = class {
    };
    exports.AbstractVector = AbstractVector;
    exports.Vector = AbstractVector;
  }
});

// node_modules/apache-arrow/fb/Schema.js
var require_Schema = __commonJS({
  "node_modules/apache-arrow/fb/Schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var org;
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let MetadataVersion2;
            (function(MetadataVersion3) {
              MetadataVersion3[MetadataVersion3["V1"] = 0] = "V1";
              MetadataVersion3[MetadataVersion3["V2"] = 1] = "V2";
              MetadataVersion3[MetadataVersion3["V3"] = 2] = "V3";
              MetadataVersion3[MetadataVersion3["V4"] = 3] = "V4";
            })(MetadataVersion2 = flatbuf2.MetadataVersion || (flatbuf2.MetadataVersion = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let UnionMode2;
            (function(UnionMode3) {
              UnionMode3[UnionMode3["Sparse"] = 0] = "Sparse";
              UnionMode3[UnionMode3["Dense"] = 1] = "Dense";
            })(UnionMode2 = flatbuf2.UnionMode || (flatbuf2.UnionMode = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let Precision2;
            (function(Precision3) {
              Precision3[Precision3["HALF"] = 0] = "HALF";
              Precision3[Precision3["SINGLE"] = 1] = "SINGLE";
              Precision3[Precision3["DOUBLE"] = 2] = "DOUBLE";
            })(Precision2 = flatbuf2.Precision || (flatbuf2.Precision = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let DateUnit2;
            (function(DateUnit3) {
              DateUnit3[DateUnit3["DAY"] = 0] = "DAY";
              DateUnit3[DateUnit3["MILLISECOND"] = 1] = "MILLISECOND";
            })(DateUnit2 = flatbuf2.DateUnit || (flatbuf2.DateUnit = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let TimeUnit2;
            (function(TimeUnit3) {
              TimeUnit3[TimeUnit3["SECOND"] = 0] = "SECOND";
              TimeUnit3[TimeUnit3["MILLISECOND"] = 1] = "MILLISECOND";
              TimeUnit3[TimeUnit3["MICROSECOND"] = 2] = "MICROSECOND";
              TimeUnit3[TimeUnit3["NANOSECOND"] = 3] = "NANOSECOND";
            })(TimeUnit2 = flatbuf2.TimeUnit || (flatbuf2.TimeUnit = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let IntervalUnit2;
            (function(IntervalUnit3) {
              IntervalUnit3[IntervalUnit3["YEAR_MONTH"] = 0] = "YEAR_MONTH";
              IntervalUnit3[IntervalUnit3["DAY_TIME"] = 1] = "DAY_TIME";
            })(IntervalUnit2 = flatbuf2.IntervalUnit || (flatbuf2.IntervalUnit = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let Type2;
            (function(Type3) {
              Type3[Type3["NONE"] = 0] = "NONE";
              Type3[Type3["Null"] = 1] = "Null";
              Type3[Type3["Int"] = 2] = "Int";
              Type3[Type3["FloatingPoint"] = 3] = "FloatingPoint";
              Type3[Type3["Binary"] = 4] = "Binary";
              Type3[Type3["Utf8"] = 5] = "Utf8";
              Type3[Type3["Bool"] = 6] = "Bool";
              Type3[Type3["Decimal"] = 7] = "Decimal";
              Type3[Type3["Date"] = 8] = "Date";
              Type3[Type3["Time"] = 9] = "Time";
              Type3[Type3["Timestamp"] = 10] = "Timestamp";
              Type3[Type3["Interval"] = 11] = "Interval";
              Type3[Type3["List"] = 12] = "List";
              Type3[Type3["Struct_"] = 13] = "Struct_";
              Type3[Type3["Union"] = 14] = "Union";
              Type3[Type3["FixedSizeBinary"] = 15] = "FixedSizeBinary";
              Type3[Type3["FixedSizeList"] = 16] = "FixedSizeList";
              Type3[Type3["Map"] = 17] = "Map";
              Type3[Type3["Duration"] = 18] = "Duration";
              Type3[Type3["LargeBinary"] = 19] = "LargeBinary";
              Type3[Type3["LargeUtf8"] = 20] = "LargeUtf8";
              Type3[Type3["LargeList"] = 21] = "LargeList";
            })(Type2 = flatbuf2.Type || (flatbuf2.Type = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let Endianness;
            (function(Endianness2) {
              Endianness2[Endianness2["Little"] = 0] = "Little";
              Endianness2[Endianness2["Big"] = 1] = "Big";
            })(Endianness = flatbuf2.Endianness || (flatbuf2.Endianness = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Null2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsNull(bb, obj) {
                return (obj || new Null2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              static startNull(builder) {
                builder.startObject(0);
              }
              static endNull(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createNull(builder) {
                Null2.startNull(builder);
                return Null2.endNull(builder);
              }
            }
            flatbuf2.Null = Null2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Struct_ {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsStruct_(bb, obj) {
                return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              static startStruct_(builder) {
                builder.startObject(0);
              }
              static endStruct_(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createStruct_(builder) {
                Struct_.startStruct_(builder);
                return Struct_.endStruct_(builder);
              }
            }
            flatbuf2.Struct_ = Struct_;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class List2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsList(bb, obj) {
                return (obj || new List2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              static startList(builder) {
                builder.startObject(0);
              }
              static endList(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createList(builder) {
                List2.startList(builder);
                return List2.endList(builder);
              }
            }
            flatbuf2.List = List2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class LargeList {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsLargeList(bb, obj) {
                return (obj || new LargeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              static startLargeList(builder) {
                builder.startObject(0);
              }
              static endLargeList(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createLargeList(builder) {
                LargeList.startLargeList(builder);
                return LargeList.endLargeList(builder);
              }
            }
            flatbuf2.LargeList = LargeList;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class FixedSizeList2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsFixedSizeList(bb, obj) {
                return (obj || new FixedSizeList2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              listSize() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
              }
              static startFixedSizeList(builder) {
                builder.startObject(1);
              }
              static addListSize(builder, listSize) {
                builder.addFieldInt32(0, listSize, 0);
              }
              static endFixedSizeList(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createFixedSizeList(builder, listSize) {
                FixedSizeList2.startFixedSizeList(builder);
                FixedSizeList2.addListSize(builder, listSize);
                return FixedSizeList2.endFixedSizeList(builder);
              }
            }
            flatbuf2.FixedSizeList = FixedSizeList2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Map2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsMap(bb, obj) {
                return (obj || new Map2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              keysSorted() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
              }
              static startMap(builder) {
                builder.startObject(1);
              }
              static addKeysSorted(builder, keysSorted) {
                builder.addFieldInt8(0, +keysSorted, 0);
              }
              static endMap(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createMap(builder, keysSorted) {
                Map2.startMap(builder);
                Map2.addKeysSorted(builder, keysSorted);
                return Map2.endMap(builder);
              }
            }
            flatbuf2.Map = Map2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Union2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsUnion(bb, obj) {
                return (obj || new Union2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              mode() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt16(this.bb_pos + offset) : org2.apache.arrow.flatbuf.UnionMode.Sparse;
              }
              typeIds(index) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
              }
              typeIdsLength() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              typeIdsArray() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
              }
              static startUnion(builder) {
                builder.startObject(2);
              }
              static addMode(builder, mode) {
                builder.addFieldInt16(0, mode, org2.apache.arrow.flatbuf.UnionMode.Sparse);
              }
              static addTypeIds(builder, typeIdsOffset) {
                builder.addFieldOffset(1, typeIdsOffset, 0);
              }
              static createTypeIdsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addInt32(data[i]);
                }
                return builder.endVector();
              }
              static startTypeIdsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              static endUnion(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createUnion(builder, mode, typeIdsOffset) {
                Union2.startUnion(builder);
                Union2.addMode(builder, mode);
                Union2.addTypeIds(builder, typeIdsOffset);
                return Union2.endUnion(builder);
              }
            }
            flatbuf2.Union = Union2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Int2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsInt(bb, obj) {
                return (obj || new Int2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              bitWidth() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
              }
              isSigned() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
              }
              static startInt(builder) {
                builder.startObject(2);
              }
              static addBitWidth(builder, bitWidth) {
                builder.addFieldInt32(0, bitWidth, 0);
              }
              static addIsSigned(builder, isSigned) {
                builder.addFieldInt8(1, +isSigned, 0);
              }
              static endInt(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createInt(builder, bitWidth, isSigned) {
                Int2.startInt(builder);
                Int2.addBitWidth(builder, bitWidth);
                Int2.addIsSigned(builder, isSigned);
                return Int2.endInt(builder);
              }
            }
            flatbuf2.Int = Int2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class FloatingPoint {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsFloatingPoint(bb, obj) {
                return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              precision() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt16(this.bb_pos + offset) : org2.apache.arrow.flatbuf.Precision.HALF;
              }
              static startFloatingPoint(builder) {
                builder.startObject(1);
              }
              static addPrecision(builder, precision) {
                builder.addFieldInt16(0, precision, org2.apache.arrow.flatbuf.Precision.HALF);
              }
              static endFloatingPoint(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createFloatingPoint(builder, precision) {
                FloatingPoint.startFloatingPoint(builder);
                FloatingPoint.addPrecision(builder, precision);
                return FloatingPoint.endFloatingPoint(builder);
              }
            }
            flatbuf2.FloatingPoint = FloatingPoint;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Utf82 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsUtf8(bb, obj) {
                return (obj || new Utf82()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              static startUtf8(builder) {
                builder.startObject(0);
              }
              static endUtf8(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createUtf8(builder) {
                Utf82.startUtf8(builder);
                return Utf82.endUtf8(builder);
              }
            }
            flatbuf2.Utf8 = Utf82;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Binary2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsBinary(bb, obj) {
                return (obj || new Binary2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              static startBinary(builder) {
                builder.startObject(0);
              }
              static endBinary(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createBinary(builder) {
                Binary2.startBinary(builder);
                return Binary2.endBinary(builder);
              }
            }
            flatbuf2.Binary = Binary2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class LargeUtf8 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsLargeUtf8(bb, obj) {
                return (obj || new LargeUtf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              static startLargeUtf8(builder) {
                builder.startObject(0);
              }
              static endLargeUtf8(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createLargeUtf8(builder) {
                LargeUtf8.startLargeUtf8(builder);
                return LargeUtf8.endLargeUtf8(builder);
              }
            }
            flatbuf2.LargeUtf8 = LargeUtf8;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class LargeBinary {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsLargeBinary(bb, obj) {
                return (obj || new LargeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              static startLargeBinary(builder) {
                builder.startObject(0);
              }
              static endLargeBinary(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createLargeBinary(builder) {
                LargeBinary.startLargeBinary(builder);
                return LargeBinary.endLargeBinary(builder);
              }
            }
            flatbuf2.LargeBinary = LargeBinary;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class FixedSizeBinary2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsFixedSizeBinary(bb, obj) {
                return (obj || new FixedSizeBinary2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              byteWidth() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
              }
              static startFixedSizeBinary(builder) {
                builder.startObject(1);
              }
              static addByteWidth(builder, byteWidth) {
                builder.addFieldInt32(0, byteWidth, 0);
              }
              static endFixedSizeBinary(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createFixedSizeBinary(builder, byteWidth) {
                FixedSizeBinary2.startFixedSizeBinary(builder);
                FixedSizeBinary2.addByteWidth(builder, byteWidth);
                return FixedSizeBinary2.endFixedSizeBinary(builder);
              }
            }
            flatbuf2.FixedSizeBinary = FixedSizeBinary2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Bool2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsBool(bb, obj) {
                return (obj || new Bool2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              static startBool(builder) {
                builder.startObject(0);
              }
              static endBool(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createBool(builder) {
                Bool2.startBool(builder);
                return Bool2.endBool(builder);
              }
            }
            flatbuf2.Bool = Bool2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Decimal2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsDecimal(bb, obj) {
                return (obj || new Decimal2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              precision() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
              }
              scale() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
              }
              static startDecimal(builder) {
                builder.startObject(2);
              }
              static addPrecision(builder, precision) {
                builder.addFieldInt32(0, precision, 0);
              }
              static addScale(builder, scale) {
                builder.addFieldInt32(1, scale, 0);
              }
              static endDecimal(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createDecimal(builder, precision, scale) {
                Decimal2.startDecimal(builder);
                Decimal2.addPrecision(builder, precision);
                Decimal2.addScale(builder, scale);
                return Decimal2.endDecimal(builder);
              }
            }
            flatbuf2.Decimal = Decimal2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Date2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsDate(bb, obj) {
                return (obj || new Date2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              unit() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt16(this.bb_pos + offset) : org2.apache.arrow.flatbuf.DateUnit.MILLISECOND;
              }
              static startDate(builder) {
                builder.startObject(1);
              }
              static addUnit(builder, unit) {
                builder.addFieldInt16(0, unit, org2.apache.arrow.flatbuf.DateUnit.MILLISECOND);
              }
              static endDate(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createDate(builder, unit) {
                Date2.startDate(builder);
                Date2.addUnit(builder, unit);
                return Date2.endDate(builder);
              }
            }
            flatbuf2.Date = Date2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Time2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsTime(bb, obj) {
                return (obj || new Time2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              unit() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt16(this.bb_pos + offset) : org2.apache.arrow.flatbuf.TimeUnit.MILLISECOND;
              }
              bitWidth() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.readInt32(this.bb_pos + offset) : 32;
              }
              static startTime(builder) {
                builder.startObject(2);
              }
              static addUnit(builder, unit) {
                builder.addFieldInt16(0, unit, org2.apache.arrow.flatbuf.TimeUnit.MILLISECOND);
              }
              static addBitWidth(builder, bitWidth) {
                builder.addFieldInt32(1, bitWidth, 32);
              }
              static endTime(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createTime(builder, unit, bitWidth) {
                Time2.startTime(builder);
                Time2.addUnit(builder, unit);
                Time2.addBitWidth(builder, bitWidth);
                return Time2.endTime(builder);
              }
            }
            flatbuf2.Time = Time2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Timestamp2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsTimestamp(bb, obj) {
                return (obj || new Timestamp2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              unit() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt16(this.bb_pos + offset) : org2.apache.arrow.flatbuf.TimeUnit.SECOND;
              }
              timezone(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              static startTimestamp(builder) {
                builder.startObject(2);
              }
              static addUnit(builder, unit) {
                builder.addFieldInt16(0, unit, org2.apache.arrow.flatbuf.TimeUnit.SECOND);
              }
              static addTimezone(builder, timezoneOffset) {
                builder.addFieldOffset(1, timezoneOffset, 0);
              }
              static endTimestamp(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createTimestamp(builder, unit, timezoneOffset) {
                Timestamp2.startTimestamp(builder);
                Timestamp2.addUnit(builder, unit);
                Timestamp2.addTimezone(builder, timezoneOffset);
                return Timestamp2.endTimestamp(builder);
              }
            }
            flatbuf2.Timestamp = Timestamp2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Interval2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsInterval(bb, obj) {
                return (obj || new Interval2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              unit() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt16(this.bb_pos + offset) : org2.apache.arrow.flatbuf.IntervalUnit.YEAR_MONTH;
              }
              static startInterval(builder) {
                builder.startObject(1);
              }
              static addUnit(builder, unit) {
                builder.addFieldInt16(0, unit, org2.apache.arrow.flatbuf.IntervalUnit.YEAR_MONTH);
              }
              static endInterval(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createInterval(builder, unit) {
                Interval2.startInterval(builder);
                Interval2.addUnit(builder, unit);
                return Interval2.endInterval(builder);
              }
            }
            flatbuf2.Interval = Interval2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Duration {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsDuration(bb, obj) {
                return (obj || new Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              unit() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt16(this.bb_pos + offset) : org2.apache.arrow.flatbuf.TimeUnit.MILLISECOND;
              }
              static startDuration(builder) {
                builder.startObject(1);
              }
              static addUnit(builder, unit) {
                builder.addFieldInt16(0, unit, org2.apache.arrow.flatbuf.TimeUnit.MILLISECOND);
              }
              static endDuration(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createDuration(builder, unit) {
                Duration.startDuration(builder);
                Duration.addUnit(builder, unit);
                return Duration.endDuration(builder);
              }
            }
            flatbuf2.Duration = Duration;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class KeyValue {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsKeyValue(bb, obj) {
                return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              key(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              value(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              static startKeyValue(builder) {
                builder.startObject(2);
              }
              static addKey(builder, keyOffset) {
                builder.addFieldOffset(0, keyOffset, 0);
              }
              static addValue(builder, valueOffset) {
                builder.addFieldOffset(1, valueOffset, 0);
              }
              static endKeyValue(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createKeyValue(builder, keyOffset, valueOffset) {
                KeyValue.startKeyValue(builder);
                KeyValue.addKey(builder, keyOffset);
                KeyValue.addValue(builder, valueOffset);
                return KeyValue.endKeyValue(builder);
              }
            }
            flatbuf2.KeyValue = KeyValue;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class DictionaryEncoding {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsDictionaryEncoding(bb, obj) {
                return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              id() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              indexType(obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new org2.apache.arrow.flatbuf.Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              isOrdered() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
              }
              static startDictionaryEncoding(builder) {
                builder.startObject(3);
              }
              static addId(builder, id) {
                builder.addFieldInt64(0, id, builder.createLong(0, 0));
              }
              static addIndexType(builder, indexTypeOffset) {
                builder.addFieldOffset(1, indexTypeOffset, 0);
              }
              static addIsOrdered(builder, isOrdered) {
                builder.addFieldInt8(2, +isOrdered, 0);
              }
              static endDictionaryEncoding(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createDictionaryEncoding(builder, id, indexTypeOffset, isOrdered) {
                DictionaryEncoding.startDictionaryEncoding(builder);
                DictionaryEncoding.addId(builder, id);
                DictionaryEncoding.addIndexType(builder, indexTypeOffset);
                DictionaryEncoding.addIsOrdered(builder, isOrdered);
                return DictionaryEncoding.endDictionaryEncoding(builder);
              }
            }
            flatbuf2.DictionaryEncoding = DictionaryEncoding;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Field2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsField(bb, obj) {
                return (obj || new Field2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              name(optionalEncoding) {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
              }
              nullable() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
              }
              typeType() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.readUint8(this.bb_pos + offset) : org2.apache.arrow.flatbuf.Type.NONE;
              }
              type(obj) {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
              }
              dictionary(obj) {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? (obj || new org2.apache.arrow.flatbuf.DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              children(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? (obj || new org2.apache.arrow.flatbuf.Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
              }
              childrenLength() {
                let offset = this.bb.__offset(this.bb_pos, 14);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              customMetadata(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 16);
                return offset ? (obj || new org2.apache.arrow.flatbuf.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
              }
              customMetadataLength() {
                let offset = this.bb.__offset(this.bb_pos, 16);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              static startField(builder) {
                builder.startObject(7);
              }
              static addName(builder, nameOffset) {
                builder.addFieldOffset(0, nameOffset, 0);
              }
              static addNullable(builder, nullable) {
                builder.addFieldInt8(1, +nullable, 0);
              }
              static addTypeType(builder, typeType) {
                builder.addFieldInt8(2, typeType, org2.apache.arrow.flatbuf.Type.NONE);
              }
              static addType(builder, typeOffset) {
                builder.addFieldOffset(3, typeOffset, 0);
              }
              static addDictionary(builder, dictionaryOffset) {
                builder.addFieldOffset(4, dictionaryOffset, 0);
              }
              static addChildren(builder, childrenOffset) {
                builder.addFieldOffset(5, childrenOffset, 0);
              }
              static createChildrenVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              static startChildrenVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              static addCustomMetadata(builder, customMetadataOffset) {
                builder.addFieldOffset(6, customMetadataOffset, 0);
              }
              static createCustomMetadataVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              static startCustomMetadataVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              static endField(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createField(builder, nameOffset, nullable, typeType, typeOffset, dictionaryOffset, childrenOffset, customMetadataOffset) {
                Field2.startField(builder);
                Field2.addName(builder, nameOffset);
                Field2.addNullable(builder, nullable);
                Field2.addTypeType(builder, typeType);
                Field2.addType(builder, typeOffset);
                Field2.addDictionary(builder, dictionaryOffset);
                Field2.addChildren(builder, childrenOffset);
                Field2.addCustomMetadata(builder, customMetadataOffset);
                return Field2.endField(builder);
              }
            }
            flatbuf2.Field = Field2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Buffer2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              offset() {
                return this.bb.readInt64(this.bb_pos);
              }
              length() {
                return this.bb.readInt64(this.bb_pos + 8);
              }
              static createBuffer(builder, offset, length) {
                builder.prep(8, 16);
                builder.writeInt64(length);
                builder.writeInt64(offset);
                return builder.offset();
              }
            }
            flatbuf2.Buffer = Buffer2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Schema2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsSchema(bb, obj) {
                return (obj || new Schema2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              endianness() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt16(this.bb_pos + offset) : org2.apache.arrow.flatbuf.Endianness.Little;
              }
              fields(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new org2.apache.arrow.flatbuf.Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
              }
              fieldsLength() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              customMetadata(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (obj || new org2.apache.arrow.flatbuf.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
              }
              customMetadataLength() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              static startSchema(builder) {
                builder.startObject(3);
              }
              static addEndianness(builder, endianness) {
                builder.addFieldInt16(0, endianness, org2.apache.arrow.flatbuf.Endianness.Little);
              }
              static addFields(builder, fieldsOffset) {
                builder.addFieldOffset(1, fieldsOffset, 0);
              }
              static createFieldsVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              static startFieldsVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              static addCustomMetadata(builder, customMetadataOffset) {
                builder.addFieldOffset(2, customMetadataOffset, 0);
              }
              static createCustomMetadataVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              static startCustomMetadataVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              static endSchema(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static finishSchemaBuffer(builder, offset) {
                builder.finish(offset);
              }
              static createSchema(builder, endianness, fieldsOffset, customMetadataOffset) {
                Schema2.startSchema(builder);
                Schema2.addEndianness(builder, endianness);
                Schema2.addFields(builder, fieldsOffset);
                Schema2.addCustomMetadata(builder, customMetadataOffset);
                return Schema2.endSchema(builder);
              }
            }
            flatbuf2.Schema = Schema2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
  }
});

// node_modules/apache-arrow/fb/Message.js
var require_Message = __commonJS({
  "node_modules/apache-arrow/fb/Message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NS7624605610262437867 = require_Schema();
    var org;
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            flatbuf2.Schema = NS7624605610262437867.org.apache.arrow.flatbuf.Schema;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            let MessageHeader2;
            (function(MessageHeader3) {
              MessageHeader3[MessageHeader3["NONE"] = 0] = "NONE";
              MessageHeader3[MessageHeader3["Schema"] = 1] = "Schema";
              MessageHeader3[MessageHeader3["DictionaryBatch"] = 2] = "DictionaryBatch";
              MessageHeader3[MessageHeader3["RecordBatch"] = 3] = "RecordBatch";
              MessageHeader3[MessageHeader3["Tensor"] = 4] = "Tensor";
              MessageHeader3[MessageHeader3["SparseTensor"] = 5] = "SparseTensor";
            })(MessageHeader2 = flatbuf2.MessageHeader || (flatbuf2.MessageHeader = {}));
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class FieldNode {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              length() {
                return this.bb.readInt64(this.bb_pos);
              }
              nullCount() {
                return this.bb.readInt64(this.bb_pos + 8);
              }
              static createFieldNode(builder, length, null_count) {
                builder.prep(8, 16);
                builder.writeInt64(null_count);
                builder.writeInt64(length);
                return builder.offset();
              }
            }
            flatbuf2.FieldNode = FieldNode;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class RecordBatch2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsRecordBatch(bb, obj) {
                return (obj || new RecordBatch2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              length() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              nodes(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new org2.apache.arrow.flatbuf.FieldNode()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
              }
              nodesLength() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              buffers(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (obj || new NS7624605610262437867.org.apache.arrow.flatbuf.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
              }
              buffersLength() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              static startRecordBatch(builder) {
                builder.startObject(3);
              }
              static addLength(builder, length) {
                builder.addFieldInt64(0, length, builder.createLong(0, 0));
              }
              static addNodes(builder, nodesOffset) {
                builder.addFieldOffset(1, nodesOffset, 0);
              }
              static startNodesVector(builder, numElems) {
                builder.startVector(16, numElems, 8);
              }
              static addBuffers(builder, buffersOffset) {
                builder.addFieldOffset(2, buffersOffset, 0);
              }
              static startBuffersVector(builder, numElems) {
                builder.startVector(16, numElems, 8);
              }
              static endRecordBatch(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createRecordBatch(builder, length, nodesOffset, buffersOffset) {
                RecordBatch2.startRecordBatch(builder);
                RecordBatch2.addLength(builder, length);
                RecordBatch2.addNodes(builder, nodesOffset);
                RecordBatch2.addBuffers(builder, buffersOffset);
                return RecordBatch2.endRecordBatch(builder);
              }
            }
            flatbuf2.RecordBatch = RecordBatch2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class DictionaryBatch {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsDictionaryBatch(bb, obj) {
                return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              id() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              data(obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new org2.apache.arrow.flatbuf.RecordBatch()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              isDelta() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
              }
              static startDictionaryBatch(builder) {
                builder.startObject(3);
              }
              static addId(builder, id) {
                builder.addFieldInt64(0, id, builder.createLong(0, 0));
              }
              static addData(builder, dataOffset) {
                builder.addFieldOffset(1, dataOffset, 0);
              }
              static addIsDelta(builder, isDelta) {
                builder.addFieldInt8(2, +isDelta, 0);
              }
              static endDictionaryBatch(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static createDictionaryBatch(builder, id, dataOffset, isDelta) {
                DictionaryBatch.startDictionaryBatch(builder);
                DictionaryBatch.addId(builder, id);
                DictionaryBatch.addData(builder, dataOffset);
                DictionaryBatch.addIsDelta(builder, isDelta);
                return DictionaryBatch.endDictionaryBatch(builder);
              }
            }
            flatbuf2.DictionaryBatch = DictionaryBatch;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Message2 {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsMessage(bb, obj) {
                return (obj || new Message2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              version() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt16(this.bb_pos + offset) : NS7624605610262437867.org.apache.arrow.flatbuf.MetadataVersion.V1;
              }
              headerType() {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? this.bb.readUint8(this.bb_pos + offset) : org2.apache.arrow.flatbuf.MessageHeader.NONE;
              }
              header(obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
              }
              bodyLength() {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
              }
              customMetadata(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? (obj || new NS7624605610262437867.org.apache.arrow.flatbuf.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
              }
              customMetadataLength() {
                let offset = this.bb.__offset(this.bb_pos, 12);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              static startMessage(builder) {
                builder.startObject(5);
              }
              static addVersion(builder, version) {
                builder.addFieldInt16(0, version, NS7624605610262437867.org.apache.arrow.flatbuf.MetadataVersion.V1);
              }
              static addHeaderType(builder, headerType) {
                builder.addFieldInt8(1, headerType, org2.apache.arrow.flatbuf.MessageHeader.NONE);
              }
              static addHeader(builder, headerOffset) {
                builder.addFieldOffset(2, headerOffset, 0);
              }
              static addBodyLength(builder, bodyLength) {
                builder.addFieldInt64(3, bodyLength, builder.createLong(0, 0));
              }
              static addCustomMetadata(builder, customMetadataOffset) {
                builder.addFieldOffset(4, customMetadataOffset, 0);
              }
              static createCustomMetadataVector(builder, data) {
                builder.startVector(4, data.length, 4);
                for (let i = data.length - 1; i >= 0; i--) {
                  builder.addOffset(data[i]);
                }
                return builder.endVector();
              }
              static startCustomMetadataVector(builder, numElems) {
                builder.startVector(4, numElems, 4);
              }
              static endMessage(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static finishMessageBuffer(builder, offset) {
                builder.finish(offset);
              }
              static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
                Message2.startMessage(builder);
                Message2.addVersion(builder, version);
                Message2.addHeaderType(builder, headerType);
                Message2.addHeader(builder, headerOffset);
                Message2.addBodyLength(builder, bodyLength);
                Message2.addCustomMetadata(builder, customMetadataOffset);
                return Message2.endMessage(builder);
              }
            }
            flatbuf2.Message = Message2;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
  }
});

// node_modules/apache-arrow/enum.js
var require_enum = __commonJS({
  "node_modules/apache-arrow/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Schema_ = require_Schema();
    var Message_ = require_Message();
    exports.ArrowType = Schema_.org.apache.arrow.flatbuf.Type;
    exports.DateUnit = Schema_.org.apache.arrow.flatbuf.DateUnit;
    exports.TimeUnit = Schema_.org.apache.arrow.flatbuf.TimeUnit;
    exports.Precision = Schema_.org.apache.arrow.flatbuf.Precision;
    exports.UnionMode = Schema_.org.apache.arrow.flatbuf.UnionMode;
    exports.IntervalUnit = Schema_.org.apache.arrow.flatbuf.IntervalUnit;
    exports.MessageHeader = Message_.org.apache.arrow.flatbuf.MessageHeader;
    exports.MetadataVersion = Schema_.org.apache.arrow.flatbuf.MetadataVersion;
    var Type2;
    (function(Type3) {
      Type3[Type3["NONE"] = 0] = "NONE";
      Type3[Type3["Null"] = 1] = "Null";
      Type3[Type3["Int"] = 2] = "Int";
      Type3[Type3["Float"] = 3] = "Float";
      Type3[Type3["Binary"] = 4] = "Binary";
      Type3[Type3["Utf8"] = 5] = "Utf8";
      Type3[Type3["Bool"] = 6] = "Bool";
      Type3[Type3["Decimal"] = 7] = "Decimal";
      Type3[Type3["Date"] = 8] = "Date";
      Type3[Type3["Time"] = 9] = "Time";
      Type3[Type3["Timestamp"] = 10] = "Timestamp";
      Type3[Type3["Interval"] = 11] = "Interval";
      Type3[Type3["List"] = 12] = "List";
      Type3[Type3["Struct"] = 13] = "Struct";
      Type3[Type3["Union"] = 14] = "Union";
      Type3[Type3["FixedSizeBinary"] = 15] = "FixedSizeBinary";
      Type3[Type3["FixedSizeList"] = 16] = "FixedSizeList";
      Type3[Type3["Map"] = 17] = "Map";
      Type3[Type3["Dictionary"] = -1] = "Dictionary";
      Type3[Type3["Int8"] = -2] = "Int8";
      Type3[Type3["Int16"] = -3] = "Int16";
      Type3[Type3["Int32"] = -4] = "Int32";
      Type3[Type3["Int64"] = -5] = "Int64";
      Type3[Type3["Uint8"] = -6] = "Uint8";
      Type3[Type3["Uint16"] = -7] = "Uint16";
      Type3[Type3["Uint32"] = -8] = "Uint32";
      Type3[Type3["Uint64"] = -9] = "Uint64";
      Type3[Type3["Float16"] = -10] = "Float16";
      Type3[Type3["Float32"] = -11] = "Float32";
      Type3[Type3["Float64"] = -12] = "Float64";
      Type3[Type3["DateDay"] = -13] = "DateDay";
      Type3[Type3["DateMillisecond"] = -14] = "DateMillisecond";
      Type3[Type3["TimestampSecond"] = -15] = "TimestampSecond";
      Type3[Type3["TimestampMillisecond"] = -16] = "TimestampMillisecond";
      Type3[Type3["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
      Type3[Type3["TimestampNanosecond"] = -18] = "TimestampNanosecond";
      Type3[Type3["TimeSecond"] = -19] = "TimeSecond";
      Type3[Type3["TimeMillisecond"] = -20] = "TimeMillisecond";
      Type3[Type3["TimeMicrosecond"] = -21] = "TimeMicrosecond";
      Type3[Type3["TimeNanosecond"] = -22] = "TimeNanosecond";
      Type3[Type3["DenseUnion"] = -23] = "DenseUnion";
      Type3[Type3["SparseUnion"] = -24] = "SparseUnion";
      Type3[Type3["IntervalDayTime"] = -25] = "IntervalDayTime";
      Type3[Type3["IntervalYearMonth"] = -26] = "IntervalYearMonth";
    })(Type2 = exports.Type || (exports.Type = {}));
    var BufferType2;
    (function(BufferType3) {
      BufferType3[BufferType3["OFFSET"] = 0] = "OFFSET";
      BufferType3[BufferType3["DATA"] = 1] = "DATA";
      BufferType3[BufferType3["VALIDITY"] = 2] = "VALIDITY";
      BufferType3[BufferType3["TYPE"] = 3] = "TYPE";
    })(BufferType2 = exports.BufferType || (exports.BufferType = {}));
  }
});

// node_modules/apache-arrow/util/bit.js
var require_bit = __commonJS({
  "node_modules/apache-arrow/util/bit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function getBool(_data, _index, byte, bit) {
      return (byte & 1 << bit) !== 0;
    }
    exports.getBool = getBool;
    function getBit(_data, _index, byte, bit) {
      return (byte & 1 << bit) >> bit;
    }
    exports.getBit = getBit;
    function setBool(bytes, index, value) {
      return value ? !!(bytes[index >> 3] |= 1 << index % 8) || true : !(bytes[index >> 3] &= ~(1 << index % 8)) && false;
    }
    exports.setBool = setBool;
    function truncateBitmap(offset, length, bitmap) {
      const alignedSize = bitmap.byteLength + 7 & ~7;
      if (offset > 0 || bitmap.byteLength < alignedSize) {
        const bytes = new Uint8Array(alignedSize);
        bytes.set(offset % 8 === 0 ? bitmap.subarray(offset >> 3) : packBools(iterateBits(bitmap, offset, length, null, getBool)).subarray(0, alignedSize));
        return bytes;
      }
      return bitmap;
    }
    exports.truncateBitmap = truncateBitmap;
    function packBools(values) {
      let xs = [];
      let i = 0, bit = 0, byte = 0;
      for (const value of values) {
        value && (byte |= 1 << bit);
        if (++bit === 8) {
          xs[i++] = byte;
          byte = bit = 0;
        }
      }
      if (i === 0 || bit > 0) {
        xs[i++] = byte;
      }
      let b = new Uint8Array(xs.length + 7 & ~7);
      b.set(xs);
      return b;
    }
    exports.packBools = packBools;
    function* iterateBits(bytes, begin, length, context, get) {
      let bit = begin % 8;
      let byteIndex = begin >> 3;
      let index = 0, remaining = length;
      for (; remaining > 0; bit = 0) {
        let byte = bytes[byteIndex++];
        do {
          yield get(context, index++, byte, bit);
        } while (--remaining > 0 && ++bit < 8);
      }
    }
    exports.iterateBits = iterateBits;
    function popcnt_bit_range(data, lhs, rhs) {
      if (rhs - lhs <= 0) {
        return 0;
      }
      if (rhs - lhs < 8) {
        let sum = 0;
        for (const bit of iterateBits(data, lhs, rhs - lhs, data, getBit)) {
          sum += bit;
        }
        return sum;
      }
      const rhsInside = rhs >> 3 << 3;
      const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
      return popcnt_bit_range(data, lhs, lhsInside) + popcnt_bit_range(data, rhsInside, rhs) + popcnt_array(data, lhsInside >> 3, rhsInside - lhsInside >> 3);
    }
    exports.popcnt_bit_range = popcnt_bit_range;
    function popcnt_array(arr, byteOffset, byteLength) {
      let cnt = 0, pos = byteOffset | 0;
      const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;
      while (len - pos >= 4) {
        cnt += popcnt_uint32(view.getUint32(pos));
        pos += 4;
      }
      while (len - pos >= 2) {
        cnt += popcnt_uint32(view.getUint16(pos));
        pos += 2;
      }
      while (len - pos >= 1) {
        cnt += popcnt_uint32(view.getUint8(pos));
        pos += 1;
      }
      return cnt;
    }
    exports.popcnt_array = popcnt_array;
    function popcnt_uint32(uint32) {
      let i = uint32 | 0;
      i = i - (i >>> 1 & 1431655765);
      i = (i & 858993459) + (i >>> 2 & 858993459);
      return (i + (i >>> 4) & 252645135) * 16843009 >>> 24;
    }
    exports.popcnt_uint32 = popcnt_uint32;
  }
});

// node_modules/apache-arrow/visitor.js
var require_visitor = __commonJS({
  "node_modules/apache-arrow/visitor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_1 = require_data();
    var vector_1 = require_vector();
    var enum_1 = require_enum();
    var type_1 = require_type();
    var Visitor2 = class {
      visitMany(nodes, ...args) {
        return nodes.map((node, i) => this.visit(node, ...args.map((x) => x[i])));
      }
      visit(...args) {
        return this.getVisitFn(args[0], false).apply(this, args);
      }
      getVisitFn(node, throwIfNotFound = true) {
        return getVisitFn(this, node, throwIfNotFound);
      }
      visitNull(_node, ..._args) {
        return null;
      }
      visitBool(_node, ..._args) {
        return null;
      }
      visitInt(_node, ..._args) {
        return null;
      }
      visitFloat(_node, ..._args) {
        return null;
      }
      visitUtf8(_node, ..._args) {
        return null;
      }
      visitBinary(_node, ..._args) {
        return null;
      }
      visitFixedSizeBinary(_node, ..._args) {
        return null;
      }
      visitDate(_node, ..._args) {
        return null;
      }
      visitTimestamp(_node, ..._args) {
        return null;
      }
      visitTime(_node, ..._args) {
        return null;
      }
      visitDecimal(_node, ..._args) {
        return null;
      }
      visitList(_node, ..._args) {
        return null;
      }
      visitStruct(_node, ..._args) {
        return null;
      }
      visitUnion(_node, ..._args) {
        return null;
      }
      visitDictionary(_node, ..._args) {
        return null;
      }
      visitInterval(_node, ..._args) {
        return null;
      }
      visitFixedSizeList(_node, ..._args) {
        return null;
      }
      visitMap(_node, ..._args) {
        return null;
      }
    };
    exports.Visitor = Visitor2;
    function getVisitFn(visitor, node, throwIfNotFound = true) {
      let fn = null;
      let dtype = enum_1.Type.NONE;
      if (node instanceof data_1.Data) {
        dtype = inferDType(node.type);
      } else if (node instanceof vector_1.Vector) {
        dtype = inferDType(node.type);
      } else if (node instanceof type_1.DataType) {
        dtype = inferDType(node);
      } else if (typeof (dtype = node) !== "number") {
        dtype = enum_1.Type[node];
      }
      switch (dtype) {
        case enum_1.Type.Null:
          fn = visitor.visitNull;
          break;
        case enum_1.Type.Bool:
          fn = visitor.visitBool;
          break;
        case enum_1.Type.Int:
          fn = visitor.visitInt;
          break;
        case enum_1.Type.Int8:
          fn = visitor.visitInt8 || visitor.visitInt;
          break;
        case enum_1.Type.Int16:
          fn = visitor.visitInt16 || visitor.visitInt;
          break;
        case enum_1.Type.Int32:
          fn = visitor.visitInt32 || visitor.visitInt;
          break;
        case enum_1.Type.Int64:
          fn = visitor.visitInt64 || visitor.visitInt;
          break;
        case enum_1.Type.Uint8:
          fn = visitor.visitUint8 || visitor.visitInt;
          break;
        case enum_1.Type.Uint16:
          fn = visitor.visitUint16 || visitor.visitInt;
          break;
        case enum_1.Type.Uint32:
          fn = visitor.visitUint32 || visitor.visitInt;
          break;
        case enum_1.Type.Uint64:
          fn = visitor.visitUint64 || visitor.visitInt;
          break;
        case enum_1.Type.Float:
          fn = visitor.visitFloat;
          break;
        case enum_1.Type.Float16:
          fn = visitor.visitFloat16 || visitor.visitFloat;
          break;
        case enum_1.Type.Float32:
          fn = visitor.visitFloat32 || visitor.visitFloat;
          break;
        case enum_1.Type.Float64:
          fn = visitor.visitFloat64 || visitor.visitFloat;
          break;
        case enum_1.Type.Utf8:
          fn = visitor.visitUtf8;
          break;
        case enum_1.Type.Binary:
          fn = visitor.visitBinary;
          break;
        case enum_1.Type.FixedSizeBinary:
          fn = visitor.visitFixedSizeBinary;
          break;
        case enum_1.Type.Date:
          fn = visitor.visitDate;
          break;
        case enum_1.Type.DateDay:
          fn = visitor.visitDateDay || visitor.visitDate;
          break;
        case enum_1.Type.DateMillisecond:
          fn = visitor.visitDateMillisecond || visitor.visitDate;
          break;
        case enum_1.Type.Timestamp:
          fn = visitor.visitTimestamp;
          break;
        case enum_1.Type.TimestampSecond:
          fn = visitor.visitTimestampSecond || visitor.visitTimestamp;
          break;
        case enum_1.Type.TimestampMillisecond:
          fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;
          break;
        case enum_1.Type.TimestampMicrosecond:
          fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;
          break;
        case enum_1.Type.TimestampNanosecond:
          fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;
          break;
        case enum_1.Type.Time:
          fn = visitor.visitTime;
          break;
        case enum_1.Type.TimeSecond:
          fn = visitor.visitTimeSecond || visitor.visitTime;
          break;
        case enum_1.Type.TimeMillisecond:
          fn = visitor.visitTimeMillisecond || visitor.visitTime;
          break;
        case enum_1.Type.TimeMicrosecond:
          fn = visitor.visitTimeMicrosecond || visitor.visitTime;
          break;
        case enum_1.Type.TimeNanosecond:
          fn = visitor.visitTimeNanosecond || visitor.visitTime;
          break;
        case enum_1.Type.Decimal:
          fn = visitor.visitDecimal;
          break;
        case enum_1.Type.List:
          fn = visitor.visitList;
          break;
        case enum_1.Type.Struct:
          fn = visitor.visitStruct;
          break;
        case enum_1.Type.Union:
          fn = visitor.visitUnion;
          break;
        case enum_1.Type.DenseUnion:
          fn = visitor.visitDenseUnion || visitor.visitUnion;
          break;
        case enum_1.Type.SparseUnion:
          fn = visitor.visitSparseUnion || visitor.visitUnion;
          break;
        case enum_1.Type.Dictionary:
          fn = visitor.visitDictionary;
          break;
        case enum_1.Type.Interval:
          fn = visitor.visitInterval;
          break;
        case enum_1.Type.IntervalDayTime:
          fn = visitor.visitIntervalDayTime || visitor.visitInterval;
          break;
        case enum_1.Type.IntervalYearMonth:
          fn = visitor.visitIntervalYearMonth || visitor.visitInterval;
          break;
        case enum_1.Type.FixedSizeList:
          fn = visitor.visitFixedSizeList;
          break;
        case enum_1.Type.Map:
          fn = visitor.visitMap;
          break;
      }
      if (typeof fn === "function")
        return fn;
      if (!throwIfNotFound)
        return () => null;
      throw new Error(`Unrecognized type '${enum_1.Type[dtype]}'`);
    }
    function inferDType(type) {
      switch (type.typeId) {
        case enum_1.Type.Null:
          return enum_1.Type.Null;
        case enum_1.Type.Int:
          const { bitWidth, isSigned } = type;
          switch (bitWidth) {
            case 8:
              return isSigned ? enum_1.Type.Int8 : enum_1.Type.Uint8;
            case 16:
              return isSigned ? enum_1.Type.Int16 : enum_1.Type.Uint16;
            case 32:
              return isSigned ? enum_1.Type.Int32 : enum_1.Type.Uint32;
            case 64:
              return isSigned ? enum_1.Type.Int64 : enum_1.Type.Uint64;
          }
          return enum_1.Type.Int;
        case enum_1.Type.Float:
          switch (type.precision) {
            case enum_1.Precision.HALF:
              return enum_1.Type.Float16;
            case enum_1.Precision.SINGLE:
              return enum_1.Type.Float32;
            case enum_1.Precision.DOUBLE:
              return enum_1.Type.Float64;
          }
          return enum_1.Type.Float;
        case enum_1.Type.Binary:
          return enum_1.Type.Binary;
        case enum_1.Type.Utf8:
          return enum_1.Type.Utf8;
        case enum_1.Type.Bool:
          return enum_1.Type.Bool;
        case enum_1.Type.Decimal:
          return enum_1.Type.Decimal;
        case enum_1.Type.Time:
          switch (type.unit) {
            case enum_1.TimeUnit.SECOND:
              return enum_1.Type.TimeSecond;
            case enum_1.TimeUnit.MILLISECOND:
              return enum_1.Type.TimeMillisecond;
            case enum_1.TimeUnit.MICROSECOND:
              return enum_1.Type.TimeMicrosecond;
            case enum_1.TimeUnit.NANOSECOND:
              return enum_1.Type.TimeNanosecond;
          }
          return enum_1.Type.Time;
        case enum_1.Type.Timestamp:
          switch (type.unit) {
            case enum_1.TimeUnit.SECOND:
              return enum_1.Type.TimestampSecond;
            case enum_1.TimeUnit.MILLISECOND:
              return enum_1.Type.TimestampMillisecond;
            case enum_1.TimeUnit.MICROSECOND:
              return enum_1.Type.TimestampMicrosecond;
            case enum_1.TimeUnit.NANOSECOND:
              return enum_1.Type.TimestampNanosecond;
          }
          return enum_1.Type.Timestamp;
        case enum_1.Type.Date:
          switch (type.unit) {
            case enum_1.DateUnit.DAY:
              return enum_1.Type.DateDay;
            case enum_1.DateUnit.MILLISECOND:
              return enum_1.Type.DateMillisecond;
          }
          return enum_1.Type.Date;
        case enum_1.Type.Interval:
          switch (type.unit) {
            case enum_1.IntervalUnit.DAY_TIME:
              return enum_1.Type.IntervalDayTime;
            case enum_1.IntervalUnit.YEAR_MONTH:
              return enum_1.Type.IntervalYearMonth;
          }
          return enum_1.Type.Interval;
        case enum_1.Type.Map:
          return enum_1.Type.Map;
        case enum_1.Type.List:
          return enum_1.Type.List;
        case enum_1.Type.Struct:
          return enum_1.Type.Struct;
        case enum_1.Type.Union:
          switch (type.mode) {
            case enum_1.UnionMode.Dense:
              return enum_1.Type.DenseUnion;
            case enum_1.UnionMode.Sparse:
              return enum_1.Type.SparseUnion;
          }
          return enum_1.Type.Union;
        case enum_1.Type.FixedSizeBinary:
          return enum_1.Type.FixedSizeBinary;
        case enum_1.Type.FixedSizeList:
          return enum_1.Type.FixedSizeList;
        case enum_1.Type.Dictionary:
          return enum_1.Type.Dictionary;
      }
      throw new Error(`Unrecognized type '${enum_1.Type[type.typeId]}'`);
    }
    Visitor2.prototype.visitInt8 = null;
    Visitor2.prototype.visitInt16 = null;
    Visitor2.prototype.visitInt32 = null;
    Visitor2.prototype.visitInt64 = null;
    Visitor2.prototype.visitUint8 = null;
    Visitor2.prototype.visitUint16 = null;
    Visitor2.prototype.visitUint32 = null;
    Visitor2.prototype.visitUint64 = null;
    Visitor2.prototype.visitFloat16 = null;
    Visitor2.prototype.visitFloat32 = null;
    Visitor2.prototype.visitFloat64 = null;
    Visitor2.prototype.visitDateDay = null;
    Visitor2.prototype.visitDateMillisecond = null;
    Visitor2.prototype.visitTimestampSecond = null;
    Visitor2.prototype.visitTimestampMillisecond = null;
    Visitor2.prototype.visitTimestampMicrosecond = null;
    Visitor2.prototype.visitTimestampNanosecond = null;
    Visitor2.prototype.visitTimeSecond = null;
    Visitor2.prototype.visitTimeMillisecond = null;
    Visitor2.prototype.visitTimeMicrosecond = null;
    Visitor2.prototype.visitTimeNanosecond = null;
    Visitor2.prototype.visitDenseUnion = null;
    Visitor2.prototype.visitSparseUnion = null;
    Visitor2.prototype.visitIntervalDayTime = null;
    Visitor2.prototype.visitIntervalYearMonth = null;
  }
});

// node_modules/apache-arrow/visitor/typecomparator.js
var require_typecomparator = __commonJS({
  "node_modules/apache-arrow/visitor/typecomparator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var visitor_1 = require_visitor();
    var TypeComparator = class extends visitor_1.Visitor {
      compareSchemas(schema, other) {
        return schema === other || other instanceof schema.constructor && exports.instance.compareFields(schema.fields, other.fields);
      }
      compareFields(fields, others) {
        return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f, i) => exports.instance.compareField(f, others[i]));
      }
      compareField(field, other) {
        return field === other || other instanceof field.constructor && field.name === other.name && field.nullable === other.nullable && exports.instance.visit(field.type, other.type);
      }
    };
    exports.TypeComparator = TypeComparator;
    function compareConstructor(type, other) {
      return other instanceof type.constructor;
    }
    function compareAny(type, other) {
      return type === other || compareConstructor(type, other);
    }
    function compareInt(type, other) {
      return type === other || compareConstructor(type, other) && type.bitWidth === other.bitWidth && type.isSigned === other.isSigned;
    }
    function compareFloat(type, other) {
      return type === other || compareConstructor(type, other) && type.precision === other.precision;
    }
    function compareFixedSizeBinary(type, other) {
      return type === other || compareConstructor(type, other) && type.byteWidth === other.byteWidth;
    }
    function compareDate(type, other) {
      return type === other || compareConstructor(type, other) && type.unit === other.unit;
    }
    function compareTimestamp(type, other) {
      return type === other || compareConstructor(type, other) && type.unit === other.unit && type.timezone === other.timezone;
    }
    function compareTime(type, other) {
      return type === other || compareConstructor(type, other) && type.unit === other.unit && type.bitWidth === other.bitWidth;
    }
    function compareList(type, other) {
      return type === other || compareConstructor(type, other) && type.children.length === other.children.length && exports.instance.compareFields(type.children, other.children);
    }
    function compareStruct(type, other) {
      return type === other || compareConstructor(type, other) && type.children.length === other.children.length && exports.instance.compareFields(type.children, other.children);
    }
    function compareUnion(type, other) {
      return type === other || compareConstructor(type, other) && type.mode === other.mode && type.typeIds.every((x, i) => x === other.typeIds[i]) && exports.instance.compareFields(type.children, other.children);
    }
    function compareDictionary(type, other) {
      return type === other || compareConstructor(type, other) && type.id === other.id && type.isOrdered === other.isOrdered && exports.instance.visit(type.indices, other.indices) && exports.instance.visit(type.dictionary, other.dictionary);
    }
    function compareInterval(type, other) {
      return type === other || compareConstructor(type, other) && type.unit === other.unit;
    }
    function compareFixedSizeList(type, other) {
      return type === other || compareConstructor(type, other) && type.listSize === other.listSize && type.children.length === other.children.length && exports.instance.compareFields(type.children, other.children);
    }
    function compareMap(type, other) {
      return type === other || compareConstructor(type, other) && type.keysSorted === other.keysSorted && type.children.length === other.children.length && exports.instance.compareFields(type.children, other.children);
    }
    TypeComparator.prototype.visitNull = compareAny;
    TypeComparator.prototype.visitBool = compareAny;
    TypeComparator.prototype.visitInt = compareInt;
    TypeComparator.prototype.visitInt8 = compareInt;
    TypeComparator.prototype.visitInt16 = compareInt;
    TypeComparator.prototype.visitInt32 = compareInt;
    TypeComparator.prototype.visitInt64 = compareInt;
    TypeComparator.prototype.visitUint8 = compareInt;
    TypeComparator.prototype.visitUint16 = compareInt;
    TypeComparator.prototype.visitUint32 = compareInt;
    TypeComparator.prototype.visitUint64 = compareInt;
    TypeComparator.prototype.visitFloat = compareFloat;
    TypeComparator.prototype.visitFloat16 = compareFloat;
    TypeComparator.prototype.visitFloat32 = compareFloat;
    TypeComparator.prototype.visitFloat64 = compareFloat;
    TypeComparator.prototype.visitUtf8 = compareAny;
    TypeComparator.prototype.visitBinary = compareAny;
    TypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;
    TypeComparator.prototype.visitDate = compareDate;
    TypeComparator.prototype.visitDateDay = compareDate;
    TypeComparator.prototype.visitDateMillisecond = compareDate;
    TypeComparator.prototype.visitTimestamp = compareTimestamp;
    TypeComparator.prototype.visitTimestampSecond = compareTimestamp;
    TypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;
    TypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;
    TypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;
    TypeComparator.prototype.visitTime = compareTime;
    TypeComparator.prototype.visitTimeSecond = compareTime;
    TypeComparator.prototype.visitTimeMillisecond = compareTime;
    TypeComparator.prototype.visitTimeMicrosecond = compareTime;
    TypeComparator.prototype.visitTimeNanosecond = compareTime;
    TypeComparator.prototype.visitDecimal = compareAny;
    TypeComparator.prototype.visitList = compareList;
    TypeComparator.prototype.visitStruct = compareStruct;
    TypeComparator.prototype.visitUnion = compareUnion;
    TypeComparator.prototype.visitDenseUnion = compareUnion;
    TypeComparator.prototype.visitSparseUnion = compareUnion;
    TypeComparator.prototype.visitDictionary = compareDictionary;
    TypeComparator.prototype.visitInterval = compareInterval;
    TypeComparator.prototype.visitIntervalDayTime = compareInterval;
    TypeComparator.prototype.visitIntervalYearMonth = compareInterval;
    TypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;
    TypeComparator.prototype.visitMap = compareMap;
    exports.instance = new TypeComparator();
  }
});

// node_modules/apache-arrow/type.js
var require_type = __commonJS({
  "node_modules/apache-arrow/type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var typecomparator_1 = require_typecomparator();
    var enum_1 = require_enum();
    var DataType2 = class {
      static isNull(x) {
        return x && x.typeId === enum_1.Type.Null;
      }
      static isInt(x) {
        return x && x.typeId === enum_1.Type.Int;
      }
      static isFloat(x) {
        return x && x.typeId === enum_1.Type.Float;
      }
      static isBinary(x) {
        return x && x.typeId === enum_1.Type.Binary;
      }
      static isUtf8(x) {
        return x && x.typeId === enum_1.Type.Utf8;
      }
      static isBool(x) {
        return x && x.typeId === enum_1.Type.Bool;
      }
      static isDecimal(x) {
        return x && x.typeId === enum_1.Type.Decimal;
      }
      static isDate(x) {
        return x && x.typeId === enum_1.Type.Date;
      }
      static isTime(x) {
        return x && x.typeId === enum_1.Type.Time;
      }
      static isTimestamp(x) {
        return x && x.typeId === enum_1.Type.Timestamp;
      }
      static isInterval(x) {
        return x && x.typeId === enum_1.Type.Interval;
      }
      static isList(x) {
        return x && x.typeId === enum_1.Type.List;
      }
      static isStruct(x) {
        return x && x.typeId === enum_1.Type.Struct;
      }
      static isUnion(x) {
        return x && x.typeId === enum_1.Type.Union;
      }
      static isFixedSizeBinary(x) {
        return x && x.typeId === enum_1.Type.FixedSizeBinary;
      }
      static isFixedSizeList(x) {
        return x && x.typeId === enum_1.Type.FixedSizeList;
      }
      static isMap(x) {
        return x && x.typeId === enum_1.Type.Map;
      }
      static isDictionary(x) {
        return x && x.typeId === enum_1.Type.Dictionary;
      }
      get typeId() {
        return enum_1.Type.NONE;
      }
      compareTo(other) {
        return typecomparator_1.instance.visit(this, other);
      }
    };
    DataType2[Symbol.toStringTag] = ((proto) => {
      proto.children = null;
      proto.ArrayType = Array;
      return proto[Symbol.toStringTag] = "DataType";
    })(DataType2.prototype);
    exports.DataType = DataType2;
    var Null2 = class extends DataType2 {
      toString() {
        return `Null`;
      }
      get typeId() {
        return enum_1.Type.Null;
      }
    };
    Null2[Symbol.toStringTag] = ((proto) => {
      return proto[Symbol.toStringTag] = "Null";
    })(Null2.prototype);
    exports.Null = Null2;
    var Int_ = class extends DataType2 {
      constructor(isSigned, bitWidth) {
        super();
        this.isSigned = isSigned;
        this.bitWidth = bitWidth;
      }
      get typeId() {
        return enum_1.Type.Int;
      }
      get ArrayType() {
        switch (this.bitWidth) {
          case 8:
            return this.isSigned ? Int8Array : Uint8Array;
          case 16:
            return this.isSigned ? Int16Array : Uint16Array;
          case 32:
            return this.isSigned ? Int32Array : Uint32Array;
          case 64:
            return this.isSigned ? Int32Array : Uint32Array;
        }
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
      }
      toString() {
        return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;
      }
    };
    Int_[Symbol.toStringTag] = ((proto) => {
      proto.isSigned = null;
      proto.bitWidth = null;
      return proto[Symbol.toStringTag] = "Int";
    })(Int_.prototype);
    exports.Int = Int_;
    var Int82 = class extends Int_ {
      constructor() {
        super(true, 8);
      }
    };
    exports.Int8 = Int82;
    var Int162 = class extends Int_ {
      constructor() {
        super(true, 16);
      }
    };
    exports.Int16 = Int162;
    var Int322 = class extends Int_ {
      constructor() {
        super(true, 32);
      }
    };
    exports.Int32 = Int322;
    var Int642 = class extends Int_ {
      constructor() {
        super(true, 64);
      }
    };
    exports.Int64 = Int642;
    var Uint82 = class extends Int_ {
      constructor() {
        super(false, 8);
      }
    };
    exports.Uint8 = Uint82;
    var Uint162 = class extends Int_ {
      constructor() {
        super(false, 16);
      }
    };
    exports.Uint16 = Uint162;
    var Uint322 = class extends Int_ {
      constructor() {
        super(false, 32);
      }
    };
    exports.Uint32 = Uint322;
    var Uint642 = class extends Int_ {
      constructor() {
        super(false, 64);
      }
    };
    exports.Uint64 = Uint642;
    Object.defineProperty(Int82.prototype, "ArrayType", { value: Int8Array });
    Object.defineProperty(Int162.prototype, "ArrayType", { value: Int16Array });
    Object.defineProperty(Int322.prototype, "ArrayType", { value: Int32Array });
    Object.defineProperty(Int642.prototype, "ArrayType", { value: Int32Array });
    Object.defineProperty(Uint82.prototype, "ArrayType", { value: Uint8Array });
    Object.defineProperty(Uint162.prototype, "ArrayType", { value: Uint16Array });
    Object.defineProperty(Uint322.prototype, "ArrayType", { value: Uint32Array });
    Object.defineProperty(Uint642.prototype, "ArrayType", { value: Uint32Array });
    var Float2 = class extends DataType2 {
      constructor(precision) {
        super();
        this.precision = precision;
      }
      get typeId() {
        return enum_1.Type.Float;
      }
      get ArrayType() {
        switch (this.precision) {
          case enum_1.Precision.HALF:
            return Uint16Array;
          case enum_1.Precision.SINGLE:
            return Float32Array;
          case enum_1.Precision.DOUBLE:
            return Float64Array;
        }
        throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
      }
      toString() {
        return `Float${this.precision << 5 || 16}`;
      }
    };
    Float2[Symbol.toStringTag] = ((proto) => {
      proto.precision = null;
      return proto[Symbol.toStringTag] = "Float";
    })(Float2.prototype);
    exports.Float = Float2;
    var Float162 = class extends Float2 {
      constructor() {
        super(enum_1.Precision.HALF);
      }
    };
    exports.Float16 = Float162;
    var Float322 = class extends Float2 {
      constructor() {
        super(enum_1.Precision.SINGLE);
      }
    };
    exports.Float32 = Float322;
    var Float642 = class extends Float2 {
      constructor() {
        super(enum_1.Precision.DOUBLE);
      }
    };
    exports.Float64 = Float642;
    Object.defineProperty(Float162.prototype, "ArrayType", { value: Uint16Array });
    Object.defineProperty(Float322.prototype, "ArrayType", { value: Float32Array });
    Object.defineProperty(Float642.prototype, "ArrayType", { value: Float64Array });
    var Binary2 = class extends DataType2 {
      constructor() {
        super();
      }
      get typeId() {
        return enum_1.Type.Binary;
      }
      toString() {
        return `Binary`;
      }
    };
    Binary2[Symbol.toStringTag] = ((proto) => {
      proto.ArrayType = Uint8Array;
      return proto[Symbol.toStringTag] = "Binary";
    })(Binary2.prototype);
    exports.Binary = Binary2;
    var Utf82 = class extends DataType2 {
      constructor() {
        super();
      }
      get typeId() {
        return enum_1.Type.Utf8;
      }
      toString() {
        return `Utf8`;
      }
    };
    Utf82[Symbol.toStringTag] = ((proto) => {
      proto.ArrayType = Uint8Array;
      return proto[Symbol.toStringTag] = "Utf8";
    })(Utf82.prototype);
    exports.Utf8 = Utf82;
    var Bool2 = class extends DataType2 {
      constructor() {
        super();
      }
      get typeId() {
        return enum_1.Type.Bool;
      }
      toString() {
        return `Bool`;
      }
    };
    Bool2[Symbol.toStringTag] = ((proto) => {
      proto.ArrayType = Uint8Array;
      return proto[Symbol.toStringTag] = "Bool";
    })(Bool2.prototype);
    exports.Bool = Bool2;
    var Decimal2 = class extends DataType2 {
      constructor(scale, precision) {
        super();
        this.scale = scale;
        this.precision = precision;
      }
      get typeId() {
        return enum_1.Type.Decimal;
      }
      toString() {
        return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`;
      }
    };
    Decimal2[Symbol.toStringTag] = ((proto) => {
      proto.scale = null;
      proto.precision = null;
      proto.ArrayType = Uint32Array;
      return proto[Symbol.toStringTag] = "Decimal";
    })(Decimal2.prototype);
    exports.Decimal = Decimal2;
    var Date_2 = class extends DataType2 {
      constructor(unit) {
        super();
        this.unit = unit;
      }
      get typeId() {
        return enum_1.Type.Date;
      }
      toString() {
        return `Date${(this.unit + 1) * 32}<${enum_1.DateUnit[this.unit]}>`;
      }
    };
    Date_2[Symbol.toStringTag] = ((proto) => {
      proto.unit = null;
      proto.ArrayType = Int32Array;
      return proto[Symbol.toStringTag] = "Date";
    })(Date_2.prototype);
    exports.Date_ = Date_2;
    var DateDay2 = class extends Date_2 {
      constructor() {
        super(enum_1.DateUnit.DAY);
      }
    };
    exports.DateDay = DateDay2;
    var DateMillisecond2 = class extends Date_2 {
      constructor() {
        super(enum_1.DateUnit.MILLISECOND);
      }
    };
    exports.DateMillisecond = DateMillisecond2;
    var Time_ = class extends DataType2 {
      constructor(unit, bitWidth) {
        super();
        this.unit = unit;
        this.bitWidth = bitWidth;
      }
      get typeId() {
        return enum_1.Type.Time;
      }
      toString() {
        return `Time${this.bitWidth}<${enum_1.TimeUnit[this.unit]}>`;
      }
    };
    Time_[Symbol.toStringTag] = ((proto) => {
      proto.unit = null;
      proto.bitWidth = null;
      proto.ArrayType = Int32Array;
      return proto[Symbol.toStringTag] = "Time";
    })(Time_.prototype);
    exports.Time = Time_;
    var TimeSecond2 = class extends Time_ {
      constructor() {
        super(enum_1.TimeUnit.SECOND, 32);
      }
    };
    exports.TimeSecond = TimeSecond2;
    var TimeMillisecond2 = class extends Time_ {
      constructor() {
        super(enum_1.TimeUnit.MILLISECOND, 32);
      }
    };
    exports.TimeMillisecond = TimeMillisecond2;
    var TimeMicrosecond2 = class extends Time_ {
      constructor() {
        super(enum_1.TimeUnit.MICROSECOND, 64);
      }
    };
    exports.TimeMicrosecond = TimeMicrosecond2;
    var TimeNanosecond2 = class extends Time_ {
      constructor() {
        super(enum_1.TimeUnit.NANOSECOND, 64);
      }
    };
    exports.TimeNanosecond = TimeNanosecond2;
    var Timestamp_ = class extends DataType2 {
      constructor(unit, timezone) {
        super();
        this.unit = unit;
        this.timezone = timezone;
      }
      get typeId() {
        return enum_1.Type.Timestamp;
      }
      toString() {
        return `Timestamp<${enum_1.TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;
      }
    };
    Timestamp_[Symbol.toStringTag] = ((proto) => {
      proto.unit = null;
      proto.timezone = null;
      proto.ArrayType = Int32Array;
      return proto[Symbol.toStringTag] = "Timestamp";
    })(Timestamp_.prototype);
    exports.Timestamp = Timestamp_;
    var TimestampSecond2 = class extends Timestamp_ {
      constructor(timezone) {
        super(enum_1.TimeUnit.SECOND, timezone);
      }
    };
    exports.TimestampSecond = TimestampSecond2;
    var TimestampMillisecond2 = class extends Timestamp_ {
      constructor(timezone) {
        super(enum_1.TimeUnit.MILLISECOND, timezone);
      }
    };
    exports.TimestampMillisecond = TimestampMillisecond2;
    var TimestampMicrosecond2 = class extends Timestamp_ {
      constructor(timezone) {
        super(enum_1.TimeUnit.MICROSECOND, timezone);
      }
    };
    exports.TimestampMicrosecond = TimestampMicrosecond2;
    var TimestampNanosecond2 = class extends Timestamp_ {
      constructor(timezone) {
        super(enum_1.TimeUnit.NANOSECOND, timezone);
      }
    };
    exports.TimestampNanosecond = TimestampNanosecond2;
    var Interval_ = class extends DataType2 {
      constructor(unit) {
        super();
        this.unit = unit;
      }
      get typeId() {
        return enum_1.Type.Interval;
      }
      toString() {
        return `Interval<${enum_1.IntervalUnit[this.unit]}>`;
      }
    };
    Interval_[Symbol.toStringTag] = ((proto) => {
      proto.unit = null;
      proto.ArrayType = Int32Array;
      return proto[Symbol.toStringTag] = "Interval";
    })(Interval_.prototype);
    exports.Interval = Interval_;
    var IntervalDayTime2 = class extends Interval_ {
      constructor() {
        super(enum_1.IntervalUnit.DAY_TIME);
      }
    };
    exports.IntervalDayTime = IntervalDayTime2;
    var IntervalYearMonth2 = class extends Interval_ {
      constructor() {
        super(enum_1.IntervalUnit.YEAR_MONTH);
      }
    };
    exports.IntervalYearMonth = IntervalYearMonth2;
    var List2 = class extends DataType2 {
      constructor(child) {
        super();
        this.children = [child];
      }
      get typeId() {
        return enum_1.Type.List;
      }
      toString() {
        return `List<${this.valueType}>`;
      }
      get valueType() {
        return this.children[0].type;
      }
      get valueField() {
        return this.children[0];
      }
      get ArrayType() {
        return this.valueType.ArrayType;
      }
    };
    List2[Symbol.toStringTag] = ((proto) => {
      proto.children = null;
      return proto[Symbol.toStringTag] = "List";
    })(List2.prototype);
    exports.List = List2;
    var Struct2 = class extends DataType2 {
      constructor(children) {
        super();
        this.children = children;
      }
      get typeId() {
        return enum_1.Type.Struct;
      }
      toString() {
        return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
      }
    };
    Struct2[Symbol.toStringTag] = ((proto) => {
      proto.children = null;
      return proto[Symbol.toStringTag] = "Struct";
    })(Struct2.prototype);
    exports.Struct = Struct2;
    var Union_ = class extends DataType2 {
      constructor(mode, typeIds, children) {
        super();
        this.mode = mode;
        this.children = children;
        this.typeIds = typeIds = Int32Array.from(typeIds);
        this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => {
          return (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex;
        }, /* @__PURE__ */ Object.create(null));
      }
      get typeId() {
        return enum_1.Type.Union;
      }
      toString() {
        return `${this[Symbol.toStringTag]}<${this.children.map((x) => `${x.type}`).join(` | `)}>`;
      }
    };
    Union_[Symbol.toStringTag] = ((proto) => {
      proto.mode = null;
      proto.typeIds = null;
      proto.children = null;
      proto.typeIdToChildIndex = null;
      proto.ArrayType = Int8Array;
      return proto[Symbol.toStringTag] = "Union";
    })(Union_.prototype);
    exports.Union = Union_;
    var DenseUnion2 = class extends Union_ {
      constructor(typeIds, children) {
        super(enum_1.UnionMode.Dense, typeIds, children);
      }
    };
    exports.DenseUnion = DenseUnion2;
    var SparseUnion2 = class extends Union_ {
      constructor(typeIds, children) {
        super(enum_1.UnionMode.Sparse, typeIds, children);
      }
    };
    exports.SparseUnion = SparseUnion2;
    var FixedSizeBinary2 = class extends DataType2 {
      constructor(byteWidth) {
        super();
        this.byteWidth = byteWidth;
      }
      get typeId() {
        return enum_1.Type.FixedSizeBinary;
      }
      toString() {
        return `FixedSizeBinary[${this.byteWidth}]`;
      }
    };
    FixedSizeBinary2[Symbol.toStringTag] = ((proto) => {
      proto.byteWidth = null;
      proto.ArrayType = Uint8Array;
      return proto[Symbol.toStringTag] = "FixedSizeBinary";
    })(FixedSizeBinary2.prototype);
    exports.FixedSizeBinary = FixedSizeBinary2;
    var FixedSizeList2 = class extends DataType2 {
      constructor(listSize, child) {
        super();
        this.listSize = listSize;
        this.children = [child];
      }
      get typeId() {
        return enum_1.Type.FixedSizeList;
      }
      get valueType() {
        return this.children[0].type;
      }
      get valueField() {
        return this.children[0];
      }
      get ArrayType() {
        return this.valueType.ArrayType;
      }
      toString() {
        return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
      }
    };
    FixedSizeList2[Symbol.toStringTag] = ((proto) => {
      proto.children = null;
      proto.listSize = null;
      return proto[Symbol.toStringTag] = "FixedSizeList";
    })(FixedSizeList2.prototype);
    exports.FixedSizeList = FixedSizeList2;
    var Map_2 = class extends DataType2 {
      constructor(child, keysSorted = false) {
        super();
        this.children = [child];
        this.keysSorted = keysSorted;
      }
      get typeId() {
        return enum_1.Type.Map;
      }
      get keyType() {
        return this.children[0].type.children[0].type;
      }
      get valueType() {
        return this.children[0].type.children[1].type;
      }
      toString() {
        return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
      }
    };
    Map_2[Symbol.toStringTag] = ((proto) => {
      proto.children = null;
      proto.keysSorted = null;
      return proto[Symbol.toStringTag] = "Map_";
    })(Map_2.prototype);
    exports.Map_ = Map_2;
    var getId = ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);
    var Dictionary2 = class extends DataType2 {
      constructor(dictionary, indices, id, isOrdered) {
        super();
        this.indices = indices;
        this.dictionary = dictionary;
        this.isOrdered = isOrdered || false;
        this.id = id == null ? getId() : typeof id === "number" ? id : id.low;
      }
      get typeId() {
        return enum_1.Type.Dictionary;
      }
      get children() {
        return this.dictionary.children;
      }
      get valueType() {
        return this.dictionary;
      }
      get ArrayType() {
        return this.dictionary.ArrayType;
      }
      toString() {
        return `Dictionary<${this.indices}, ${this.dictionary}>`;
      }
    };
    Dictionary2[Symbol.toStringTag] = ((proto) => {
      proto.id = null;
      proto.indices = null;
      proto.isOrdered = null;
      proto.dictionary = null;
      return proto[Symbol.toStringTag] = "Dictionary";
    })(Dictionary2.prototype);
    exports.Dictionary = Dictionary2;
    function strideForType(type) {
      let t = type;
      switch (type.typeId) {
        case enum_1.Type.Decimal:
          return 4;
        case enum_1.Type.Timestamp:
          return 2;
        case enum_1.Type.Date:
          return 1 + t.unit;
        case enum_1.Type.Interval:
          return 1 + t.unit;
        case enum_1.Type.Int:
          return 1 + +(t.bitWidth > 32);
        case enum_1.Type.Time:
          return 1 + +(t.bitWidth > 32);
        case enum_1.Type.FixedSizeList:
          return t.listSize;
        case enum_1.Type.FixedSizeBinary:
          return t.byteWidth;
        default:
          return 1;
      }
    }
    exports.strideForType = strideForType;
  }
});

// node_modules/apache-arrow/data.js
var require_data = __commonJS({
  "node_modules/apache-arrow/data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bit_1 = require_bit();
    var bit_2 = require_bit();
    var enum_1 = require_enum();
    var type_1 = require_type();
    var buffer_1 = require_buffer();
    exports.kUnknownNullCount = -1;
    var Data2 = class {
      constructor(type, offset, length, nullCount, buffers, childData, dictionary) {
        this.type = type;
        this.dictionary = dictionary;
        this.offset = Math.floor(Math.max(offset || 0, 0));
        this.length = Math.floor(Math.max(length || 0, 0));
        this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
        this.childData = (childData || []).map((x) => x instanceof Data2 ? x : x.data);
        let buffer;
        if (buffers instanceof Data2) {
          this.stride = buffers.stride;
          this.values = buffers.values;
          this.typeIds = buffers.typeIds;
          this.nullBitmap = buffers.nullBitmap;
          this.valueOffsets = buffers.valueOffsets;
        } else {
          this.stride = type_1.strideForType(type);
          if (buffers) {
            (buffer = buffers[0]) && (this.valueOffsets = buffer);
            (buffer = buffers[1]) && (this.values = buffer);
            (buffer = buffers[2]) && (this.nullBitmap = buffer);
            (buffer = buffers[3]) && (this.typeIds = buffer);
          }
        }
      }
      get typeId() {
        return this.type.typeId;
      }
      get ArrayType() {
        return this.type.ArrayType;
      }
      get buffers() {
        return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
      }
      get byteLength() {
        let byteLength = 0;
        let { valueOffsets, values, nullBitmap, typeIds } = this;
        valueOffsets && (byteLength += valueOffsets.byteLength);
        values && (byteLength += values.byteLength);
        nullBitmap && (byteLength += nullBitmap.byteLength);
        typeIds && (byteLength += typeIds.byteLength);
        return this.childData.reduce((byteLength2, child) => byteLength2 + child.byteLength, byteLength);
      }
      get nullCount() {
        let nullCount = this._nullCount;
        let nullBitmap;
        if (nullCount <= exports.kUnknownNullCount && (nullBitmap = this.nullBitmap)) {
          this._nullCount = nullCount = this.length - bit_2.popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);
        }
        return nullCount;
      }
      clone(type, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers = this, childData = this.childData) {
        return new Data2(type, offset, length, nullCount, buffers, childData, this.dictionary);
      }
      slice(offset, length) {
        const { stride, typeId, childData } = this;
        const nullCount = +(this._nullCount === 0) - 1;
        const childStride = typeId === 16 ? stride : 1;
        const buffers = this._sliceBuffers(offset, length, stride, typeId);
        return this.clone(
          this.type,
          this.offset + offset,
          length,
          nullCount,
          buffers,
          !childData.length || this.valueOffsets ? childData : this._sliceChildren(childData, childStride * offset, childStride * length)
        );
      }
      _changeLengthAndBackfillNullBitmap(newLength) {
        if (this.typeId === enum_1.Type.Null) {
          return this.clone(this.type, 0, newLength, 0);
        }
        const { length, nullCount } = this;
        const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length >> 3);
        bitmap[length >> 3] = (1 << length - (length & ~7)) - 1;
        if (nullCount > 0) {
          bitmap.set(bit_1.truncateBitmap(this.offset, length, this.nullBitmap), 0);
        }
        const buffers = this.buffers;
        buffers[enum_1.BufferType.VALIDITY] = bitmap;
        return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);
      }
      _sliceBuffers(offset, length, stride, typeId) {
        let arr, { buffers } = this;
        (arr = buffers[enum_1.BufferType.TYPE]) && (buffers[enum_1.BufferType.TYPE] = arr.subarray(offset, offset + length));
        (arr = buffers[enum_1.BufferType.OFFSET]) && (buffers[enum_1.BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) || (arr = buffers[enum_1.BufferType.DATA]) && (buffers[enum_1.BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));
        return buffers;
      }
      _sliceChildren(childData, offset, length) {
        return childData.map((child) => child.slice(offset, length));
      }
      static new(type, offset, length, nullCount, buffers, childData, dictionary) {
        if (buffers instanceof Data2) {
          buffers = buffers.buffers;
        } else if (!buffers) {
          buffers = [];
        }
        switch (type.typeId) {
          case enum_1.Type.Null:
            return Data2.Null(type, offset, length);
          case enum_1.Type.Int:
            return Data2.Int(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Dictionary:
            return Data2.Dictionary(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || [], dictionary);
          case enum_1.Type.Float:
            return Data2.Float(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Bool:
            return Data2.Bool(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Decimal:
            return Data2.Decimal(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Date:
            return Data2.Date(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Time:
            return Data2.Time(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Timestamp:
            return Data2.Timestamp(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Interval:
            return Data2.Interval(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.FixedSizeBinary:
            return Data2.FixedSizeBinary(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Binary:
            return Data2.Binary(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.OFFSET] || [], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.Utf8:
            return Data2.Utf8(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.OFFSET] || [], buffers[enum_1.BufferType.DATA] || []);
          case enum_1.Type.List:
            return Data2.List(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.OFFSET] || [], (childData || [])[0]);
          case enum_1.Type.FixedSizeList:
            return Data2.FixedSizeList(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], (childData || [])[0]);
          case enum_1.Type.Struct:
            return Data2.Struct(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], childData || []);
          case enum_1.Type.Map:
            return Data2.Map(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.OFFSET] || [], (childData || [])[0]);
          case enum_1.Type.Union:
            return Data2.Union(type, offset, length, nullCount || 0, buffers[enum_1.BufferType.VALIDITY], buffers[enum_1.BufferType.TYPE] || [], buffers[enum_1.BufferType.OFFSET] || childData, childData);
        }
        throw new Error(`Unrecognized typeId ${type.typeId}`);
      }
      static Null(type, offset, length) {
        return new Data2(type, offset, length, 0);
      }
      static Int(type, offset, length, nullCount, nullBitmap, data) {
        return new Data2(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      static Dictionary(type, offset, length, nullCount, nullBitmap, data, dictionary) {
        return new Data2(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.indices.ArrayType, data), buffer_1.toUint8Array(nullBitmap)], [], dictionary);
      }
      static Float(type, offset, length, nullCount, nullBitmap, data) {
        return new Data2(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      static Bool(type, offset, length, nullCount, nullBitmap, data) {
        return new Data2(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      static Decimal(type, offset, length, nullCount, nullBitmap, data) {
        return new Data2(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      static Date(type, offset, length, nullCount, nullBitmap, data) {
        return new Data2(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      static Time(type, offset, length, nullCount, nullBitmap, data) {
        return new Data2(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      static Timestamp(type, offset, length, nullCount, nullBitmap, data) {
        return new Data2(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      static Interval(type, offset, length, nullCount, nullBitmap, data) {
        return new Data2(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      static FixedSizeBinary(type, offset, length, nullCount, nullBitmap, data) {
        return new Data2(type, offset, length, nullCount, [void 0, buffer_1.toArrayBufferView(type.ArrayType, data), buffer_1.toUint8Array(nullBitmap)]);
      }
      static Binary(type, offset, length, nullCount, nullBitmap, valueOffsets, data) {
        return new Data2(type, offset, length, nullCount, [buffer_1.toInt32Array(valueOffsets), buffer_1.toUint8Array(data), buffer_1.toUint8Array(nullBitmap)]);
      }
      static Utf8(type, offset, length, nullCount, nullBitmap, valueOffsets, data) {
        return new Data2(type, offset, length, nullCount, [buffer_1.toInt32Array(valueOffsets), buffer_1.toUint8Array(data), buffer_1.toUint8Array(nullBitmap)]);
      }
      static List(type, offset, length, nullCount, nullBitmap, valueOffsets, child) {
        return new Data2(type, offset, length, nullCount, [buffer_1.toInt32Array(valueOffsets), void 0, buffer_1.toUint8Array(nullBitmap)], [child]);
      }
      static FixedSizeList(type, offset, length, nullCount, nullBitmap, child) {
        return new Data2(type, offset, length, nullCount, [void 0, void 0, buffer_1.toUint8Array(nullBitmap)], [child]);
      }
      static Struct(type, offset, length, nullCount, nullBitmap, children) {
        return new Data2(type, offset, length, nullCount, [void 0, void 0, buffer_1.toUint8Array(nullBitmap)], children);
      }
      static Map(type, offset, length, nullCount, nullBitmap, valueOffsets, child) {
        return new Data2(type, offset, length, nullCount, [buffer_1.toInt32Array(valueOffsets), void 0, buffer_1.toUint8Array(nullBitmap)], [child]);
      }
      static Union(type, offset, length, nullCount, nullBitmap, typeIds, valueOffsetsOrChildren, children) {
        const buffers = [
          void 0,
          void 0,
          buffer_1.toUint8Array(nullBitmap),
          buffer_1.toArrayBufferView(type.ArrayType, typeIds)
        ];
        if (type.mode === enum_1.UnionMode.Sparse) {
          return new Data2(type, offset, length, nullCount, buffers, valueOffsetsOrChildren);
        }
        buffers[enum_1.BufferType.OFFSET] = buffer_1.toInt32Array(valueOffsetsOrChildren);
        return new Data2(type, offset, length, nullCount, buffers, children);
      }
    };
    exports.Data = Data2;
    Data2.prototype.childData = Object.freeze([]);
  }
});

// node_modules/apache-arrow/util/pretty.js
var require_pretty = __commonJS({
  "node_modules/apache-arrow/util/pretty.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var undf = void 0;
    function valueToString(x) {
      if (x === null) {
        return "null";
      }
      if (x === undf) {
        return "undefined";
      }
      switch (typeof x) {
        case "number":
          return `${x}`;
        case "bigint":
          return `${x}`;
        case "string":
          return `"${x}"`;
      }
      if (typeof x[Symbol.toPrimitive] === "function") {
        return x[Symbol.toPrimitive]("string");
      }
      return ArrayBuffer.isView(x) ? `[${x}]` : JSON.stringify(x);
    }
    exports.valueToString = valueToString;
  }
});

// node_modules/apache-arrow/builder/valid.js
var require_valid = __commonJS({
  "node_modules/apache-arrow/builder/valid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var pretty_1 = require_pretty();
    var compat_1 = require_compat();
    function createIsValidFunction(nullValues) {
      if (!nullValues || nullValues.length <= 0) {
        return function isValid(value) {
          return true;
        };
      }
      let fnBody = "";
      let noNaNs = nullValues.filter((x) => x === x);
      if (noNaNs.length > 0) {
        fnBody = `
    switch (x) {${noNaNs.map((x) => `
        case ${valueToCase(x)}:`).join("")}
            return false;
    }`;
      }
      if (nullValues.length !== noNaNs.length) {
        fnBody = `if (x !== x) return false;
${fnBody}`;
      }
      return new Function(`x`, `${fnBody}
return true;`);
    }
    exports.createIsValidFunction = createIsValidFunction;
    function valueToCase(x) {
      if (typeof x !== "bigint") {
        return pretty_1.valueToString(x);
      } else if (compat_1.BigIntAvailable) {
        return `${pretty_1.valueToString(x)}n`;
      }
      return `"${pretty_1.valueToString(x)}"`;
    }
  }
});

// node_modules/apache-arrow/builder/buffer.js
var require_buffer2 = __commonJS({
  "node_modules/apache-arrow/builder/buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require_buffer();
    var compat_1 = require_compat();
    var roundLengthUpToNearest64Bytes = (len, BPE) => (len * BPE + 63 & ~63 || 64) / BPE;
    var sliceOrExtendArray = (arr, len = 0) => arr.length >= len ? arr.subarray(0, len) : buffer_1.memcpy(new arr.constructor(len), arr, 0);
    var BufferBuilder = class {
      constructor(buffer, stride = 1) {
        this.buffer = buffer;
        this.stride = stride;
        this.BYTES_PER_ELEMENT = buffer.BYTES_PER_ELEMENT;
        this.ArrayType = buffer.constructor;
        this._resize(this.length = buffer.length / stride | 0);
      }
      get byteLength() {
        return this.length * this.stride * this.BYTES_PER_ELEMENT | 0;
      }
      get reservedLength() {
        return this.buffer.length / this.stride;
      }
      get reservedByteLength() {
        return this.buffer.byteLength;
      }
      set(index, value) {
        return this;
      }
      append(value) {
        return this.set(this.length, value);
      }
      reserve(extra) {
        if (extra > 0) {
          this.length += extra;
          const stride = this.stride;
          const length = this.length * stride;
          const reserved = this.buffer.length;
          if (length >= reserved) {
            this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length * 2, this.BYTES_PER_ELEMENT));
          }
        }
        return this;
      }
      flush(length = this.length) {
        length = roundLengthUpToNearest64Bytes(length * this.stride, this.BYTES_PER_ELEMENT);
        const array = sliceOrExtendArray(this.buffer, length);
        this.clear();
        return array;
      }
      clear() {
        this.length = 0;
        this._resize(0);
        return this;
      }
      _resize(newLength) {
        return this.buffer = buffer_1.memcpy(new this.ArrayType(newLength), this.buffer);
      }
    };
    exports.BufferBuilder = BufferBuilder;
    BufferBuilder.prototype.offset = 0;
    var DataBufferBuilder = class extends BufferBuilder {
      last() {
        return this.get(this.length - 1);
      }
      get(index) {
        return this.buffer[index];
      }
      set(index, value) {
        this.reserve(index - this.length + 1);
        this.buffer[index * this.stride] = value;
        return this;
      }
    };
    exports.DataBufferBuilder = DataBufferBuilder;
    var BitmapBufferBuilder = class extends DataBufferBuilder {
      constructor(data = new Uint8Array(0)) {
        super(data, 1 / 8);
        this.numValid = 0;
      }
      get numInvalid() {
        return this.length - this.numValid;
      }
      get(idx) {
        return this.buffer[idx >> 3] >> idx % 8 & 1;
      }
      set(idx, val) {
        const { buffer } = this.reserve(idx - this.length + 1);
        const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;
        val ? cur === 0 && (buffer[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer[byte] &= ~(1 << bit), --this.numValid);
        return this;
      }
      clear() {
        this.numValid = 0;
        return super.clear();
      }
    };
    exports.BitmapBufferBuilder = BitmapBufferBuilder;
    var OffsetsBufferBuilder = class extends DataBufferBuilder {
      constructor(data = new Int32Array(1)) {
        super(data, 1);
      }
      append(value) {
        return this.set(this.length - 1, value);
      }
      set(index, value) {
        const offset = this.length - 1;
        const buffer = this.reserve(index - offset + 1).buffer;
        if (offset < index++) {
          buffer.fill(buffer[offset], offset, index);
        }
        buffer[index] = buffer[index - 1] + value;
        return this;
      }
      flush(length = this.length - 1) {
        if (length > this.length) {
          this.set(length - 1, 0);
        }
        return super.flush(length + 1);
      }
    };
    exports.OffsetsBufferBuilder = OffsetsBufferBuilder;
    var WideBufferBuilder = class extends BufferBuilder {
      get ArrayType64() {
        return this._ArrayType64 || (this._ArrayType64 = this.buffer instanceof Int32Array ? compat_1.BigInt64Array : compat_1.BigUint64Array);
      }
      set(index, value) {
        this.reserve(index - this.length + 1);
        switch (typeof value) {
          case "bigint":
            this.buffer64[index] = value;
            break;
          case "number":
            this.buffer[index * this.stride] = value;
            break;
          default:
            this.buffer.set(value, index * this.stride);
        }
        return this;
      }
      _resize(newLength) {
        const data = super._resize(newLength);
        const length = data.byteLength / (this.BYTES_PER_ELEMENT * this.stride);
        if (compat_1.BigIntAvailable) {
          this.buffer64 = new this.ArrayType64(data.buffer, data.byteOffset, length);
        }
        return data;
      }
    };
    exports.WideBufferBuilder = WideBufferBuilder;
  }
});

// node_modules/apache-arrow/builder.js
var require_builder = __commonJS({
  "node_modules/apache-arrow/builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector();
    var enum_1 = require_enum();
    var data_1 = require_data();
    var valid_1 = require_valid();
    var buffer_1 = require_buffer2();
    var type_1 = require_type();
    var Builder3 = class {
      constructor({ "type": type, "nullValues": nulls }) {
        this.length = 0;
        this.finished = false;
        this.type = type;
        this.children = [];
        this.nullValues = nulls;
        this.stride = type_1.strideForType(type);
        this._nulls = new buffer_1.BitmapBufferBuilder();
        if (nulls && nulls.length > 0) {
          this._isValid = valid_1.createIsValidFunction(nulls);
        }
      }
      static new(options) {
      }
      static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
      }
      static throughDOM(options) {
        throw new Error(`"throughDOM" not available in this environment`);
      }
      static throughIterable(options) {
        return throughIterable(options);
      }
      static throughAsyncIterable(options) {
        return throughAsyncIterable(options);
      }
      toVector() {
        return vector_1.Vector.new(this.flush());
      }
      get ArrayType() {
        return this.type.ArrayType;
      }
      get nullCount() {
        return this._nulls.numInvalid;
      }
      get numChildren() {
        return this.children.length;
      }
      get byteLength() {
        let size = 0;
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        this._typeIds && (size += this._typeIds.byteLength);
        return this.children.reduce((size2, child) => size2 + child.byteLength, size);
      }
      get reservedLength() {
        return this._nulls.reservedLength;
      }
      get reservedByteLength() {
        let size = 0;
        this._offsets && (size += this._offsets.reservedByteLength);
        this._values && (size += this._values.reservedByteLength);
        this._nulls && (size += this._nulls.reservedByteLength);
        this._typeIds && (size += this._typeIds.reservedByteLength);
        return this.children.reduce((size2, child) => size2 + child.reservedByteLength, size);
      }
      get valueOffsets() {
        return this._offsets ? this._offsets.buffer : null;
      }
      get values() {
        return this._values ? this._values.buffer : null;
      }
      get nullBitmap() {
        return this._nulls ? this._nulls.buffer : null;
      }
      get typeIds() {
        return this._typeIds ? this._typeIds.buffer : null;
      }
      append(value) {
        return this.set(this.length, value);
      }
      isValid(value) {
        return this._isValid(value);
      }
      set(index, value) {
        if (this.setValid(index, this.isValid(value))) {
          this.setValue(index, value);
        }
        return this;
      }
      setValue(index, value) {
        this._setValue(this, index, value);
      }
      setValid(index, valid) {
        this.length = this._nulls.set(index, +valid).length;
        return valid;
      }
      addChild(child, name = `${this.numChildren}`) {
        throw new Error(`Cannot append children to non-nested type "${this.type}"`);
      }
      getChildAt(index) {
        return this.children[index] || null;
      }
      flush() {
        const buffers = [];
        const values = this._values;
        const offsets = this._offsets;
        const typeIds = this._typeIds;
        const { length, nullCount } = this;
        if (typeIds) {
          buffers[enum_1.BufferType.TYPE] = typeIds.flush(length);
          offsets && (buffers[enum_1.BufferType.OFFSET] = offsets.flush(length));
        } else if (offsets) {
          values && (buffers[enum_1.BufferType.DATA] = values.flush(offsets.last()));
          buffers[enum_1.BufferType.OFFSET] = offsets.flush(length);
        } else if (values) {
          buffers[enum_1.BufferType.DATA] = values.flush(length);
        }
        nullCount > 0 && (buffers[enum_1.BufferType.VALIDITY] = this._nulls.flush(length));
        const data = data_1.Data.new(this.type, 0, length, nullCount, buffers, this.children.map((child) => child.flush()));
        this.clear();
        return data;
      }
      finish() {
        this.finished = true;
        this.children.forEach((child) => child.finish());
        return this;
      }
      clear() {
        this.length = 0;
        this._offsets && this._offsets.clear();
        this._values && this._values.clear();
        this._nulls && this._nulls.clear();
        this._typeIds && this._typeIds.clear();
        this.children.forEach((child) => child.clear());
        return this;
      }
    };
    exports.Builder = Builder3;
    Builder3.prototype.length = 1;
    Builder3.prototype.stride = 1;
    Builder3.prototype.children = null;
    Builder3.prototype.finished = false;
    Builder3.prototype.nullValues = null;
    Builder3.prototype._isValid = () => true;
    var FixedWidthBuilder = class extends Builder3 {
      constructor(opts) {
        super(opts);
        this._values = new buffer_1.DataBufferBuilder(new this.ArrayType(0), this.stride);
      }
      setValue(index, value) {
        const values = this._values;
        values.reserve(index - values.length + 1);
        return super.setValue(index, value);
      }
    };
    exports.FixedWidthBuilder = FixedWidthBuilder;
    var VariableWidthBuilder = class extends Builder3 {
      constructor(opts) {
        super(opts);
        this._pendingLength = 0;
        this._offsets = new buffer_1.OffsetsBufferBuilder();
      }
      setValue(index, value) {
        const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
        const current = pending.get(index);
        current && (this._pendingLength -= current.length);
        this._pendingLength += value.length;
        pending.set(index, value);
      }
      setValid(index, isValid) {
        if (!super.setValid(index, isValid)) {
          (this._pending || (this._pending = /* @__PURE__ */ new Map())).set(index, void 0);
          return false;
        }
        return true;
      }
      clear() {
        this._pendingLength = 0;
        this._pending = void 0;
        return super.clear();
      }
      flush() {
        this._flush();
        return super.flush();
      }
      finish() {
        this._flush();
        return super.finish();
      }
      _flush() {
        const pending = this._pending;
        const pendingLength = this._pendingLength;
        this._pendingLength = 0;
        this._pending = void 0;
        if (pending && pending.size > 0) {
          this._flushPending(pending, pendingLength);
        }
        return this;
      }
    };
    exports.VariableWidthBuilder = VariableWidthBuilder;
    function throughIterable(options) {
      const { ["queueingStrategy"]: queueingStrategy = "count" } = options;
      const { ["highWaterMark"]: highWaterMark = queueingStrategy !== "bytes" ? 1e3 : 2 ** 14 } = options;
      const sizeProperty = queueingStrategy !== "bytes" ? "length" : "byteLength";
      return function* (source) {
        let numChunks = 0;
        let builder = Builder3.new(options);
        for (const value of source) {
          if (builder.append(value)[sizeProperty] >= highWaterMark) {
            ++numChunks && (yield builder.toVector());
          }
        }
        if (builder.finish().length > 0 || numChunks === 0) {
          yield builder.toVector();
        }
      };
    }
    function throughAsyncIterable(options) {
      const { ["queueingStrategy"]: queueingStrategy = "count" } = options;
      const { ["highWaterMark"]: highWaterMark = queueingStrategy !== "bytes" ? 1e3 : 2 ** 14 } = options;
      const sizeProperty = queueingStrategy !== "bytes" ? "length" : "byteLength";
      return async function* (source) {
        let numChunks = 0;
        let builder = Builder3.new(options);
        for await (const value of source) {
          if (builder.append(value)[sizeProperty] >= highWaterMark) {
            ++numChunks && (yield builder.toVector());
          }
        }
        if (builder.finish().length > 0 || numChunks === 0) {
          yield builder.toVector();
        }
      };
    }
  }
});

// node_modules/apache-arrow/builder/bool.js
var require_bool = __commonJS({
  "node_modules/apache-arrow/builder/bool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require_buffer2();
    var builder_1 = require_builder();
    var BoolBuilder2 = class extends builder_1.Builder {
      constructor(options) {
        super(options);
        this._values = new buffer_1.BitmapBufferBuilder();
      }
      setValue(index, value) {
        this._values.set(index, +value);
      }
    };
    exports.BoolBuilder = BoolBuilder2;
  }
});

// node_modules/apache-arrow/builder/null.js
var require_null = __commonJS({
  "node_modules/apache-arrow/builder/null.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builder_1 = require_builder();
    var NullBuilder2 = class extends builder_1.Builder {
      setValue(index, value) {
      }
      setValid(index, valid) {
        this.length = Math.max(index + 1, this.length);
        return valid;
      }
    };
    exports.NullBuilder = NullBuilder2;
  }
});

// node_modules/apache-arrow/builder/date.js
var require_date = __commonJS({
  "node_modules/apache-arrow/builder/date.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builder_1 = require_builder();
    var DateBuilder2 = class extends builder_1.FixedWidthBuilder {
    };
    exports.DateBuilder = DateBuilder2;
    var DateDayBuilder2 = class extends DateBuilder2 {
    };
    exports.DateDayBuilder = DateDayBuilder2;
    var DateMillisecondBuilder2 = class extends DateBuilder2 {
    };
    exports.DateMillisecondBuilder = DateMillisecondBuilder2;
  }
});

// node_modules/apache-arrow/builder/decimal.js
var require_decimal = __commonJS({
  "node_modules/apache-arrow/builder/decimal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builder_1 = require_builder();
    var DecimalBuilder2 = class extends builder_1.FixedWidthBuilder {
    };
    exports.DecimalBuilder = DecimalBuilder2;
  }
});

// node_modules/apache-arrow/builder/dictionary.js
var require_dictionary = __commonJS({
  "node_modules/apache-arrow/builder/dictionary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var type_1 = require_type();
    var builder_1 = require_builder();
    var DictionaryBuilder2 = class extends builder_1.Builder {
      constructor({ "type": type, "nullValues": nulls, "dictionaryHashFunction": hashFn }) {
        super({ type: new type_1.Dictionary(type.dictionary, type.indices, type.id, type.isOrdered) });
        this._nulls = null;
        this._dictionaryOffset = 0;
        this._keysToIndices = /* @__PURE__ */ Object.create(null);
        this.indices = builder_1.Builder.new({ "type": this.type.indices, "nullValues": nulls });
        this.dictionary = builder_1.Builder.new({ "type": this.type.dictionary, "nullValues": null });
        if (typeof hashFn === "function") {
          this.valueToKey = hashFn;
        }
      }
      get values() {
        return this.indices.values;
      }
      get nullCount() {
        return this.indices.nullCount;
      }
      get nullBitmap() {
        return this.indices.nullBitmap;
      }
      get byteLength() {
        return this.indices.byteLength + this.dictionary.byteLength;
      }
      get reservedLength() {
        return this.indices.reservedLength + this.dictionary.reservedLength;
      }
      get reservedByteLength() {
        return this.indices.reservedByteLength + this.dictionary.reservedByteLength;
      }
      isValid(value) {
        return this.indices.isValid(value);
      }
      setValid(index, valid) {
        const indices = this.indices;
        valid = indices.setValid(index, valid);
        this.length = indices.length;
        return valid;
      }
      setValue(index, value) {
        let keysToIndices = this._keysToIndices;
        let key = this.valueToKey(value);
        let idx = keysToIndices[key];
        if (idx === void 0) {
          keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;
        }
        return this.indices.setValue(index, idx);
      }
      flush() {
        const type = this.type;
        const prev = this._dictionary;
        const curr = this.dictionary.toVector();
        const data = this.indices.flush().clone(type);
        data.dictionary = prev ? prev.concat(curr) : curr;
        this.finished || (this._dictionaryOffset += curr.length);
        this._dictionary = data.dictionary;
        this.clear();
        return data;
      }
      finish() {
        this.indices.finish();
        this.dictionary.finish();
        this._dictionaryOffset = 0;
        this._keysToIndices = /* @__PURE__ */ Object.create(null);
        return super.finish();
      }
      clear() {
        this.indices.clear();
        this.dictionary.clear();
        return super.clear();
      }
      valueToKey(val) {
        return typeof val === "string" ? val : `${val}`;
      }
    };
    exports.DictionaryBuilder = DictionaryBuilder2;
  }
});

// node_modules/apache-arrow/builder/fixedsizebinary.js
var require_fixedsizebinary = __commonJS({
  "node_modules/apache-arrow/builder/fixedsizebinary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builder_1 = require_builder();
    var FixedSizeBinaryBuilder2 = class extends builder_1.FixedWidthBuilder {
    };
    exports.FixedSizeBinaryBuilder = FixedSizeBinaryBuilder2;
  }
});

// node_modules/apache-arrow/util/math.js
var require_math = __commonJS({
  "node_modules/apache-arrow/util/math.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var f64 = new Float64Array(1);
    var u32 = new Uint32Array(f64.buffer);
    function uint16ToFloat64(h) {
      let expo = (h & 31744) >> 10;
      let sigf = (h & 1023) / 1024;
      let sign = (-1) ** ((h & 32768) >> 15);
      switch (expo) {
        case 31:
          return sign * (sigf ? NaN : 1 / 0);
        case 0:
          return sign * (sigf ? 6103515625e-14 * sigf : 0);
      }
      return sign * 2 ** (expo - 15) * (1 + sigf);
    }
    exports.uint16ToFloat64 = uint16ToFloat64;
    function float64ToUint16(d) {
      if (d !== d) {
        return 32256;
      }
      f64[0] = d;
      let sign = (u32[1] & 2147483648) >> 16 & 65535;
      let expo = u32[1] & 2146435072, sigf = 0;
      if (expo >= 1089470464) {
        if (u32[0] > 0) {
          expo = 31744;
        } else {
          expo = (expo & 2080374784) >> 16;
          sigf = (u32[1] & 1048575) >> 10;
        }
      } else if (expo <= 1056964608) {
        sigf = 1048576 + (u32[1] & 1048575);
        sigf = 1048576 + (sigf << (expo >> 20) - 998) >> 21;
        expo = 0;
      } else {
        expo = expo - 1056964608 >> 10;
        sigf = (u32[1] & 1048575) + 512 >> 10;
      }
      return sign | expo | sigf & 65535;
    }
    exports.float64ToUint16 = float64ToUint16;
  }
});

// node_modules/apache-arrow/builder/float.js
var require_float = __commonJS({
  "node_modules/apache-arrow/builder/float.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var math_1 = require_math();
    var builder_1 = require_builder();
    var FloatBuilder2 = class extends builder_1.FixedWidthBuilder {
    };
    exports.FloatBuilder = FloatBuilder2;
    var Float16Builder2 = class extends FloatBuilder2 {
      setValue(index, value) {
        this._values.set(index, math_1.float64ToUint16(value));
      }
    };
    exports.Float16Builder = Float16Builder2;
    var Float32Builder2 = class extends FloatBuilder2 {
      setValue(index, value) {
        this._values.set(index, value);
      }
    };
    exports.Float32Builder = Float32Builder2;
    var Float64Builder2 = class extends FloatBuilder2 {
      setValue(index, value) {
        this._values.set(index, value);
      }
    };
    exports.Float64Builder = Float64Builder2;
  }
});

// node_modules/apache-arrow/util/bn.js
var require_bn = __commonJS({
  "node_modules/apache-arrow/util/bn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require_buffer();
    var compat_1 = require_compat();
    exports.isArrowBigNumSymbol = Symbol.for("isArrowBigNum");
    function BigNum(x, ...xs) {
      if (xs.length === 0) {
        return Object.setPrototypeOf(buffer_1.toArrayBufferView(this["TypedArray"], x), this.constructor.prototype);
      }
      return Object.setPrototypeOf(new this["TypedArray"](x, ...xs), this.constructor.prototype);
    }
    BigNum.prototype[exports.isArrowBigNumSymbol] = true;
    BigNum.prototype.toJSON = function() {
      return `"${exports.bignumToString(this)}"`;
    };
    BigNum.prototype.valueOf = function() {
      return bignumToNumber(this);
    };
    BigNum.prototype.toString = function() {
      return exports.bignumToString(this);
    };
    BigNum.prototype[Symbol.toPrimitive] = function(hint = "default") {
      switch (hint) {
        case "number":
          return bignumToNumber(this);
        case "string":
          return exports.bignumToString(this);
        case "default":
          return exports.bignumToBigInt(this);
      }
      return exports.bignumToString(this);
    };
    function SignedBigNum(...args) {
      return BigNum.apply(this, args);
    }
    function UnsignedBigNum(...args) {
      return BigNum.apply(this, args);
    }
    function DecimalBigNum(...args) {
      return BigNum.apply(this, args);
    }
    Object.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));
    Object.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));
    Object.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));
    Object.assign(SignedBigNum.prototype, BigNum.prototype, { "constructor": SignedBigNum, "signed": true, "TypedArray": Int32Array, "BigIntArray": compat_1.BigInt64Array });
    Object.assign(UnsignedBigNum.prototype, BigNum.prototype, { "constructor": UnsignedBigNum, "signed": false, "TypedArray": Uint32Array, "BigIntArray": compat_1.BigUint64Array });
    Object.assign(DecimalBigNum.prototype, BigNum.prototype, { "constructor": DecimalBigNum, "signed": true, "TypedArray": Uint32Array, "BigIntArray": compat_1.BigUint64Array });
    function bignumToNumber(bn) {
      let { buffer, byteOffset, length, "signed": signed } = bn;
      let words = new Int32Array(buffer, byteOffset, length);
      let number = 0, i = 0, n = words.length, hi, lo;
      while (i < n) {
        lo = words[i++];
        hi = words[i++];
        signed || (hi = hi >>> 0);
        number += (lo >>> 0) + hi * i ** 32;
      }
      return number;
    }
    if (!compat_1.BigIntAvailable) {
      exports.bignumToString = decimalToString;
      exports.bignumToBigInt = exports.bignumToString;
    } else {
      exports.bignumToBigInt = (a) => a.byteLength === 8 ? new a["BigIntArray"](a.buffer, a.byteOffset, 1)[0] : decimalToString(a);
      exports.bignumToString = (a) => a.byteLength === 8 ? `${new a["BigIntArray"](a.buffer, a.byteOffset, 1)[0]}` : decimalToString(a);
    }
    function decimalToString(a) {
      let digits = "";
      let base64 = new Uint32Array(2);
      let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
      let checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
      let i = -1, n = base32.length - 1;
      do {
        for (base64[0] = base32[i = 0]; i < n; ) {
          base32[i++] = base64[1] = base64[0] / 10;
          base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i];
        }
        base32[i] = base64[1] = base64[0] / 10;
        base64[0] = base64[0] - base64[1] * 10;
        digits = `${base64[0]}${digits}`;
      } while (checks[0] || checks[1] || checks[2] || checks[3]);
      return digits ? digits : `0`;
    }
    var BN = class {
      constructor(num, isSigned) {
        return BN.new(num, isSigned);
      }
      static new(num, isSigned) {
        switch (isSigned) {
          case true:
            return new SignedBigNum(num);
          case false:
            return new UnsignedBigNum(num);
        }
        switch (num.constructor) {
          case Int8Array:
          case Int16Array:
          case Int32Array:
          case compat_1.BigInt64Array:
            return new SignedBigNum(num);
        }
        if (num.byteLength === 16) {
          return new DecimalBigNum(num);
        }
        return new UnsignedBigNum(num);
      }
      static signed(num) {
        return new SignedBigNum(num);
      }
      static unsigned(num) {
        return new UnsignedBigNum(num);
      }
      static decimal(num) {
        return new DecimalBigNum(num);
      }
    };
    exports.BN = BN;
  }
});

// node_modules/apache-arrow/builder/int.js
var require_int = __commonJS({
  "node_modules/apache-arrow/builder/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bn_1 = require_bn();
    var buffer_1 = require_buffer2();
    var compat_1 = require_compat();
    var builder_1 = require_builder();
    var IntBuilder2 = class extends builder_1.FixedWidthBuilder {
      setValue(index, value) {
        this._values.set(index, value);
      }
    };
    exports.IntBuilder = IntBuilder2;
    var Int8Builder2 = class extends IntBuilder2 {
    };
    exports.Int8Builder = Int8Builder2;
    var Int16Builder2 = class extends IntBuilder2 {
    };
    exports.Int16Builder = Int16Builder2;
    var Int32Builder2 = class extends IntBuilder2 {
    };
    exports.Int32Builder = Int32Builder2;
    var Int64Builder2 = class extends IntBuilder2 {
      constructor(options) {
        if (options["nullValues"]) {
          options["nullValues"] = options["nullValues"].map(toBigInt);
        }
        super(options);
        this._values = new buffer_1.WideBufferBuilder(new Int32Array(0), 2);
      }
      get values64() {
        return this._values.buffer64;
      }
      isValid(value) {
        return super.isValid(toBigInt(value));
      }
    };
    exports.Int64Builder = Int64Builder2;
    var Uint8Builder2 = class extends IntBuilder2 {
    };
    exports.Uint8Builder = Uint8Builder2;
    var Uint16Builder2 = class extends IntBuilder2 {
    };
    exports.Uint16Builder = Uint16Builder2;
    var Uint32Builder2 = class extends IntBuilder2 {
    };
    exports.Uint32Builder = Uint32Builder2;
    var Uint64Builder2 = class extends IntBuilder2 {
      constructor(options) {
        if (options["nullValues"]) {
          options["nullValues"] = options["nullValues"].map(toBigInt);
        }
        super(options);
        this._values = new buffer_1.WideBufferBuilder(new Uint32Array(0), 2);
      }
      get values64() {
        return this._values.buffer64;
      }
      isValid(value) {
        return super.isValid(toBigInt(value));
      }
    };
    exports.Uint64Builder = Uint64Builder2;
    var toBigInt = ((memo) => (value) => {
      if (ArrayBuffer.isView(value)) {
        memo.buffer = value.buffer;
        memo.byteOffset = value.byteOffset;
        memo.byteLength = value.byteLength;
        value = bn_1.bignumToBigInt(memo);
        memo.buffer = null;
      }
      return value;
    })({ "BigIntArray": compat_1.BigInt64Array });
  }
});

// node_modules/apache-arrow/builder/time.js
var require_time = __commonJS({
  "node_modules/apache-arrow/builder/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builder_1 = require_builder();
    var TimeBuilder2 = class extends builder_1.FixedWidthBuilder {
    };
    exports.TimeBuilder = TimeBuilder2;
    var TimeSecondBuilder2 = class extends TimeBuilder2 {
    };
    exports.TimeSecondBuilder = TimeSecondBuilder2;
    var TimeMillisecondBuilder2 = class extends TimeBuilder2 {
    };
    exports.TimeMillisecondBuilder = TimeMillisecondBuilder2;
    var TimeMicrosecondBuilder2 = class extends TimeBuilder2 {
    };
    exports.TimeMicrosecondBuilder = TimeMicrosecondBuilder2;
    var TimeNanosecondBuilder2 = class extends TimeBuilder2 {
    };
    exports.TimeNanosecondBuilder = TimeNanosecondBuilder2;
  }
});

// node_modules/apache-arrow/builder/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/apache-arrow/builder/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builder_1 = require_builder();
    var TimestampBuilder2 = class extends builder_1.FixedWidthBuilder {
    };
    exports.TimestampBuilder = TimestampBuilder2;
    var TimestampSecondBuilder2 = class extends TimestampBuilder2 {
    };
    exports.TimestampSecondBuilder = TimestampSecondBuilder2;
    var TimestampMillisecondBuilder2 = class extends TimestampBuilder2 {
    };
    exports.TimestampMillisecondBuilder = TimestampMillisecondBuilder2;
    var TimestampMicrosecondBuilder2 = class extends TimestampBuilder2 {
    };
    exports.TimestampMicrosecondBuilder = TimestampMicrosecondBuilder2;
    var TimestampNanosecondBuilder2 = class extends TimestampBuilder2 {
    };
    exports.TimestampNanosecondBuilder = TimestampNanosecondBuilder2;
  }
});

// node_modules/apache-arrow/builder/interval.js
var require_interval = __commonJS({
  "node_modules/apache-arrow/builder/interval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builder_1 = require_builder();
    var IntervalBuilder2 = class extends builder_1.FixedWidthBuilder {
    };
    exports.IntervalBuilder = IntervalBuilder2;
    var IntervalDayTimeBuilder2 = class extends IntervalBuilder2 {
    };
    exports.IntervalDayTimeBuilder = IntervalDayTimeBuilder2;
    var IntervalYearMonthBuilder2 = class extends IntervalBuilder2 {
    };
    exports.IntervalYearMonthBuilder = IntervalYearMonthBuilder2;
  }
});

// node_modules/apache-arrow/builder/binary.js
var require_binary = __commonJS({
  "node_modules/apache-arrow/builder/binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require_buffer();
    var buffer_2 = require_buffer2();
    var builder_1 = require_builder();
    var BinaryBuilder2 = class extends builder_1.VariableWidthBuilder {
      constructor(opts) {
        super(opts);
        this._values = new buffer_2.BufferBuilder(new Uint8Array(0));
      }
      get byteLength() {
        let size = this._pendingLength + this.length * 4;
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
      }
      setValue(index, value) {
        return super.setValue(index, buffer_1.toUint8Array(value));
      }
      _flushPending(pending, pendingLength) {
        const offsets = this._offsets;
        const data = this._values.reserve(pendingLength).buffer;
        let index = 0, length = 0, offset = 0, value;
        for ([index, value] of pending) {
          if (value === void 0) {
            offsets.set(index, 0);
          } else {
            length = value.length;
            data.set(value, offset);
            offsets.set(index, length);
            offset += length;
          }
        }
      }
    };
    exports.BinaryBuilder = BinaryBuilder2;
  }
});

// node_modules/apache-arrow/builder/utf8.js
var require_utf82 = __commonJS({
  "node_modules/apache-arrow/builder/utf8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utf8_1 = require_utf8();
    var binary_1 = require_binary();
    var buffer_1 = require_buffer2();
    var builder_1 = require_builder();
    var Utf8Builder2 = class extends builder_1.VariableWidthBuilder {
      constructor(opts) {
        super(opts);
        this._values = new buffer_1.BufferBuilder(new Uint8Array(0));
      }
      get byteLength() {
        let size = this._pendingLength + this.length * 4;
        this._offsets && (size += this._offsets.byteLength);
        this._values && (size += this._values.byteLength);
        this._nulls && (size += this._nulls.byteLength);
        return size;
      }
      setValue(index, value) {
        return super.setValue(index, utf8_1.encodeUtf8(value));
      }
      _flushPending(pending, pendingLength) {
      }
    };
    exports.Utf8Builder = Utf8Builder2;
    Utf8Builder2.prototype._flushPending = binary_1.BinaryBuilder.prototype._flushPending;
  }
});

// node_modules/apache-arrow/builder/run.js
var require_run = __commonJS({
  "node_modules/apache-arrow/builder/run.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector();
    var Run = class {
      get length() {
        return this._values.length;
      }
      get(index) {
        return this._values[index];
      }
      clear() {
        this._values = null;
        return this;
      }
      bind(values) {
        if (values instanceof vector_1.Vector) {
          return values;
        }
        this._values = values;
        return this;
      }
    };
    exports.Run = Run;
  }
});

// node_modules/apache-arrow/vector/row.js
var require_row = __commonJS({
  "node_modules/apache-arrow/vector/row.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var pretty_1 = require_pretty();
    var kParent = Symbol.for("parent");
    var kRowIndex = Symbol.for("rowIndex");
    var kKeyToIdx = Symbol.for("keyToIdx");
    var kIdxToVal = Symbol.for("idxToVal");
    var kCustomInspect = Symbol.for("nodejs.util.inspect.custom");
    var Row = class {
      constructor(parent, numKeys) {
        this[kParent] = parent;
        this.size = numKeys;
      }
      entries() {
        return this[Symbol.iterator]();
      }
      has(key) {
        return this.get(key) !== void 0;
      }
      get(key) {
        let val = void 0;
        if (key !== null && key !== void 0) {
          const ktoi = this[kKeyToIdx] || (this[kKeyToIdx] = /* @__PURE__ */ new Map());
          let idx = ktoi.get(key);
          if (idx !== void 0) {
            const itov = this[kIdxToVal] || (this[kIdxToVal] = new Array(this.size));
            (val = itov[idx]) !== void 0 || (itov[idx] = val = this.getValue(idx));
          } else if ((idx = this.getIndex(key)) > -1) {
            ktoi.set(key, idx);
            const itov = this[kIdxToVal] || (this[kIdxToVal] = new Array(this.size));
            (val = itov[idx]) !== void 0 || (itov[idx] = val = this.getValue(idx));
          }
        }
        return val;
      }
      set(key, val) {
        if (key !== null && key !== void 0) {
          const ktoi = this[kKeyToIdx] || (this[kKeyToIdx] = /* @__PURE__ */ new Map());
          let idx = ktoi.get(key);
          if (idx === void 0) {
            ktoi.set(key, idx = this.getIndex(key));
          }
          if (idx > -1) {
            const itov = this[kIdxToVal] || (this[kIdxToVal] = new Array(this.size));
            itov[idx] = this.setValue(idx, val);
          }
        }
        return this;
      }
      clear() {
        throw new Error(`Clearing ${this[Symbol.toStringTag]} not supported.`);
      }
      delete(_) {
        throw new Error(`Deleting ${this[Symbol.toStringTag]} values not supported.`);
      }
      *[Symbol.iterator]() {
        const ki = this.keys();
        const vi = this.values();
        const ktoi = this[kKeyToIdx] || (this[kKeyToIdx] = /* @__PURE__ */ new Map());
        const itov = this[kIdxToVal] || (this[kIdxToVal] = new Array(this.size));
        for (let k, v, i = 0, kr, vr; !((kr = ki.next()).done || (vr = vi.next()).done); ++i) {
          k = kr.value;
          v = vr.value;
          itov[i] = v;
          ktoi.has(k) || ktoi.set(k, i);
          yield [k, v];
        }
      }
      forEach(callbackfn, thisArg) {
        const ki = this.keys();
        const vi = this.values();
        const callback = thisArg === void 0 ? callbackfn : (v, k, m) => callbackfn.call(thisArg, v, k, m);
        const ktoi = this[kKeyToIdx] || (this[kKeyToIdx] = /* @__PURE__ */ new Map());
        const itov = this[kIdxToVal] || (this[kIdxToVal] = new Array(this.size));
        for (let k, v, i = 0, kr, vr; !((kr = ki.next()).done || (vr = vi.next()).done); ++i) {
          k = kr.value;
          v = vr.value;
          itov[i] = v;
          ktoi.has(k) || ktoi.set(k, i);
          callback(v, k, this);
        }
      }
      toArray() {
        return [...this.values()];
      }
      toJSON() {
        const obj = {};
        this.forEach((val, key) => obj[key] = val);
        return obj;
      }
      inspect() {
        return this.toString();
      }
      [kCustomInspect]() {
        return this.toString();
      }
      toString() {
        const str = [];
        this.forEach((val, key) => {
          key = pretty_1.valueToString(key);
          val = pretty_1.valueToString(val);
          str.push(`${key}: ${val}`);
        });
        return `{ ${str.join(", ")} }`;
      }
    };
    Row[Symbol.toStringTag] = ((proto) => {
      Object.defineProperties(proto, {
        "size": { writable: true, enumerable: false, configurable: false, value: 0 },
        [kParent]: { writable: true, enumerable: false, configurable: false, value: null },
        [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 }
      });
      return proto[Symbol.toStringTag] = "Row";
    })(Row.prototype);
    var MapRow = class extends Row {
      constructor(slice) {
        super(slice, slice.length);
        return createRowProxy(this);
      }
      keys() {
        return this[kParent].getChildAt(0)[Symbol.iterator]();
      }
      values() {
        return this[kParent].getChildAt(1)[Symbol.iterator]();
      }
      getKey(idx) {
        return this[kParent].getChildAt(0).get(idx);
      }
      getIndex(key) {
        return this[kParent].getChildAt(0).indexOf(key);
      }
      getValue(index) {
        return this[kParent].getChildAt(1).get(index);
      }
      setValue(index, value) {
        this[kParent].getChildAt(1).set(index, value);
      }
    };
    exports.MapRow = MapRow;
    var StructRow = class extends Row {
      constructor(parent) {
        super(parent, parent.type.children.length);
        return defineRowProxyProperties(this);
      }
      *keys() {
        for (const field of this[kParent].type.children) {
          yield field.name;
        }
      }
      *values() {
        for (const field of this[kParent].type.children) {
          yield this[field.name];
        }
      }
      getKey(idx) {
        return this[kParent].type.children[idx].name;
      }
      getIndex(key) {
        return this[kParent].type.children.findIndex((f) => f.name === key);
      }
      getValue(index) {
        return this[kParent].getChildAt(index).get(this[kRowIndex]);
      }
      setValue(index, value) {
        return this[kParent].getChildAt(index).set(this[kRowIndex], value);
      }
    };
    exports.StructRow = StructRow;
    Object.setPrototypeOf(Row.prototype, Map.prototype);
    var defineRowProxyProperties = (() => {
      const desc = { enumerable: true, configurable: false, get: null, set: null };
      return (row) => {
        let idx = -1, ktoi = row[kKeyToIdx] || (row[kKeyToIdx] = /* @__PURE__ */ new Map());
        const getter = (key) => function() {
          return this.get(key);
        };
        const setter = (key) => function(val) {
          return this.set(key, val);
        };
        for (const key of row.keys()) {
          ktoi.set(key, ++idx);
          desc.get = getter(key);
          desc.set = setter(key);
          row.hasOwnProperty(key) || (desc.enumerable = true, Object.defineProperty(row, key, desc));
          row.hasOwnProperty(idx) || (desc.enumerable = false, Object.defineProperty(row, idx, desc));
        }
        desc.get = desc.set = null;
        return row;
      };
    })();
    var createRowProxy = (() => {
      if (typeof Proxy === "undefined") {
        return defineRowProxyProperties;
      }
      const has = Row.prototype.has;
      const get = Row.prototype.get;
      const set = Row.prototype.set;
      const getKey = Row.prototype.getKey;
      const RowProxyHandler = {
        isExtensible() {
          return false;
        },
        deleteProperty() {
          return false;
        },
        preventExtensions() {
          return true;
        },
        ownKeys(row) {
          return [...row.keys()].map((x) => `${x}`);
        },
        has(row, key) {
          switch (key) {
            case "getKey":
            case "getIndex":
            case "getValue":
            case "setValue":
            case "toArray":
            case "toJSON":
            case "inspect":
            case "constructor":
            case "isPrototypeOf":
            case "propertyIsEnumerable":
            case "toString":
            case "toLocaleString":
            case "valueOf":
            case "size":
            case "has":
            case "get":
            case "set":
            case "clear":
            case "delete":
            case "keys":
            case "values":
            case "entries":
            case "forEach":
            case "__proto__":
            case "__defineGetter__":
            case "__defineSetter__":
            case "hasOwnProperty":
            case "__lookupGetter__":
            case "__lookupSetter__":
            case Symbol.iterator:
            case Symbol.toStringTag:
            case kParent:
            case kRowIndex:
            case kIdxToVal:
            case kKeyToIdx:
            case kCustomInspect:
              return true;
          }
          if (typeof key === "number" && !row.has(key)) {
            key = row.getKey(key);
          }
          return row.has(key);
        },
        get(row, key, receiver) {
          switch (key) {
            case "getKey":
            case "getIndex":
            case "getValue":
            case "setValue":
            case "toArray":
            case "toJSON":
            case "inspect":
            case "constructor":
            case "isPrototypeOf":
            case "propertyIsEnumerable":
            case "toString":
            case "toLocaleString":
            case "valueOf":
            case "size":
            case "has":
            case "get":
            case "set":
            case "clear":
            case "delete":
            case "keys":
            case "values":
            case "entries":
            case "forEach":
            case "__proto__":
            case "__defineGetter__":
            case "__defineSetter__":
            case "hasOwnProperty":
            case "__lookupGetter__":
            case "__lookupSetter__":
            case Symbol.iterator:
            case Symbol.toStringTag:
            case kParent:
            case kRowIndex:
            case kIdxToVal:
            case kKeyToIdx:
            case kCustomInspect:
              return Reflect.get(row, key, receiver);
          }
          if (typeof key === "number" && !has.call(receiver, key)) {
            key = getKey.call(receiver, key);
          }
          return get.call(receiver, key);
        },
        set(row, key, val, receiver) {
          switch (key) {
            case kParent:
            case kRowIndex:
            case kIdxToVal:
            case kKeyToIdx:
              return Reflect.set(row, key, val, receiver);
            case "getKey":
            case "getIndex":
            case "getValue":
            case "setValue":
            case "toArray":
            case "toJSON":
            case "inspect":
            case "constructor":
            case "isPrototypeOf":
            case "propertyIsEnumerable":
            case "toString":
            case "toLocaleString":
            case "valueOf":
            case "size":
            case "has":
            case "get":
            case "set":
            case "clear":
            case "delete":
            case "keys":
            case "values":
            case "entries":
            case "forEach":
            case "__proto__":
            case "__defineGetter__":
            case "__defineSetter__":
            case "hasOwnProperty":
            case "__lookupGetter__":
            case "__lookupSetter__":
            case Symbol.iterator:
            case Symbol.toStringTag:
              return false;
          }
          if (typeof key === "number" && !has.call(receiver, key)) {
            key = getKey.call(receiver, key);
          }
          return has.call(receiver, key) ? !!set.call(receiver, key, val) : false;
        }
      };
      return (row) => new Proxy(row, RowProxyHandler);
    })();
  }
});

// node_modules/apache-arrow/util/vector.js
var require_vector2 = __commonJS({
  "node_modules/apache-arrow/util/vector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector();
    var row_1 = require_row();
    var buffer_1 = require_buffer();
    var compat_1 = require_compat();
    function clampIndex(source, index, then) {
      const length = source.length;
      const adjust = index > -1 ? index : length + index % length;
      return then ? then(source, adjust) : adjust;
    }
    exports.clampIndex = clampIndex;
    var tmp;
    function clampRange(source, begin, end, then) {
      let { length: len = 0 } = source;
      let lhs = typeof begin !== "number" ? 0 : begin;
      let rhs = typeof end !== "number" ? len : end;
      lhs < 0 && (lhs = (lhs % len + len) % len);
      rhs < 0 && (rhs = (rhs % len + len) % len);
      rhs < lhs && (tmp = lhs, lhs = rhs, rhs = tmp);
      rhs > len && (rhs = len);
      return then ? then(source, lhs, rhs) : [lhs, rhs];
    }
    exports.clampRange = clampRange;
    var big0 = compat_1.BigIntAvailable ? compat_1.BigInt(0) : 0;
    var isNaNFast = (value) => value !== value;
    function createElementComparator(search) {
      let typeofSearch = typeof search;
      if (typeofSearch !== "object" || search === null) {
        if (isNaNFast(search)) {
          return isNaNFast;
        }
        return typeofSearch !== "bigint" ? (value) => value === search : (value) => big0 + value === search;
      }
      if (search instanceof Date) {
        const valueOfSearch = search.valueOf();
        return (value) => value instanceof Date ? value.valueOf() === valueOfSearch : false;
      }
      if (ArrayBuffer.isView(search)) {
        return (value) => value ? buffer_1.compareArrayLike(search, value) : false;
      }
      if (search instanceof Map) {
        return creatMapComparator(search);
      }
      if (Array.isArray(search)) {
        return createArrayLikeComparator(search);
      }
      if (search instanceof vector_1.Vector) {
        return createVectorComparator(search);
      }
      return createObjectComparator(search);
    }
    exports.createElementComparator = createElementComparator;
    function createArrayLikeComparator(lhs) {
      const comparators = [];
      for (let i = -1, n = lhs.length; ++i < n; ) {
        comparators[i] = createElementComparator(lhs[i]);
      }
      return createSubElementsComparator(comparators);
    }
    function creatMapComparator(lhs) {
      let i = -1;
      const comparators = [];
      lhs.forEach((v) => comparators[++i] = createElementComparator(v));
      return createSubElementsComparator(comparators);
    }
    function createVectorComparator(lhs) {
      const comparators = [];
      for (let i = -1, n = lhs.length; ++i < n; ) {
        comparators[i] = createElementComparator(lhs.get(i));
      }
      return createSubElementsComparator(comparators);
    }
    function createObjectComparator(lhs) {
      const keys = Object.keys(lhs);
      if (keys.length === 0) {
        return () => false;
      }
      const comparators = [];
      for (let i = -1, n = keys.length; ++i < n; ) {
        comparators[i] = createElementComparator(lhs[keys[i]]);
      }
      return createSubElementsComparator(comparators, keys);
    }
    function createSubElementsComparator(comparators, keys) {
      return (rhs) => {
        if (!rhs || typeof rhs !== "object") {
          return false;
        }
        switch (rhs.constructor) {
          case Array:
            return compareArray(comparators, rhs);
          case Map:
          case row_1.MapRow:
          case row_1.StructRow:
            return compareObject(comparators, rhs, rhs.keys());
          case Object:
          case void 0:
            return compareObject(comparators, rhs, keys || Object.keys(rhs));
        }
        return rhs instanceof vector_1.Vector ? compareVector(comparators, rhs) : false;
      };
    }
    function compareArray(comparators, arr) {
      const n = comparators.length;
      if (arr.length !== n) {
        return false;
      }
      for (let i = -1; ++i < n; ) {
        if (!comparators[i](arr[i])) {
          return false;
        }
      }
      return true;
    }
    function compareVector(comparators, vec) {
      const n = comparators.length;
      if (vec.length !== n) {
        return false;
      }
      for (let i = -1; ++i < n; ) {
        if (!comparators[i](vec.get(i))) {
          return false;
        }
      }
      return true;
    }
    function compareObject(comparators, obj, keys) {
      const lKeyItr = keys[Symbol.iterator]();
      const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();
      const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();
      let i = 0;
      let n = comparators.length;
      let rVal = rValItr.next();
      let lKey = lKeyItr.next();
      let rKey = rKeyItr.next();
      for (; i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {
        if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {
          break;
        }
      }
      if (i === n && lKey.done && rKey.done && rVal.done) {
        return true;
      }
      lKeyItr.return && lKeyItr.return();
      rKeyItr.return && rKeyItr.return();
      rValItr.return && rValItr.return();
      return false;
    }
  }
});

// node_modules/apache-arrow/vector/chunked.js
var require_chunked = __commonJS({
  "node_modules/apache-arrow/vector/chunked.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector2();
    var type_1 = require_type();
    var args_1 = require_args();
    var vector_2 = require_vector();
    var Chunked2 = class extends vector_2.AbstractVector {
      constructor(type, chunks = [], offsets = calculateOffsets(chunks)) {
        super();
        this._nullCount = -1;
        this._type = type;
        this._chunks = chunks;
        this._chunkOffsets = offsets;
        this._length = offsets[offsets.length - 1];
        this._numChildren = (this._type.children || []).length;
      }
      static flatten(...vectors) {
        return args_1.selectChunkArgs(vector_2.Vector, vectors);
      }
      static concat(...vectors) {
        const chunks = Chunked2.flatten(...vectors);
        return new Chunked2(chunks[0].type, chunks);
      }
      get type() {
        return this._type;
      }
      get length() {
        return this._length;
      }
      get chunks() {
        return this._chunks;
      }
      get typeId() {
        return this._type.typeId;
      }
      get VectorName() {
        return `Chunked<${this._type}>`;
      }
      get data() {
        return this._chunks[0] ? this._chunks[0].data : null;
      }
      get ArrayType() {
        return this._type.ArrayType;
      }
      get numChildren() {
        return this._numChildren;
      }
      get stride() {
        return this._chunks[0] ? this._chunks[0].stride : 1;
      }
      get byteLength() {
        return this._chunks.reduce((byteLength, chunk) => byteLength + chunk.byteLength, 0);
      }
      get nullCount() {
        let nullCount = this._nullCount;
        if (nullCount < 0) {
          this._nullCount = nullCount = this._chunks.reduce((x, { nullCount: nullCount2 }) => x + nullCount2, 0);
        }
        return nullCount;
      }
      get indices() {
        if (type_1.DataType.isDictionary(this._type)) {
          if (!this._indices) {
            const chunks = this._chunks;
            this._indices = chunks.length === 1 ? chunks[0].indices : Chunked2.concat(...chunks.map((x) => x.indices));
          }
          return this._indices;
        }
        return null;
      }
      get dictionary() {
        if (type_1.DataType.isDictionary(this._type)) {
          return this._chunks[this._chunks.length - 1].data.dictionary;
        }
        return null;
      }
      *[Symbol.iterator]() {
        for (const chunk of this._chunks) {
          yield* chunk;
        }
      }
      clone(chunks = this._chunks) {
        return new Chunked2(this._type, chunks);
      }
      concat(...others) {
        return this.clone(Chunked2.flatten(this, ...others));
      }
      slice(begin, end) {
        return vector_1.clampRange(this, begin, end, this._sliceInternal);
      }
      getChildAt(index) {
        if (index < 0 || index >= this._numChildren) {
          return null;
        }
        let columns = this._children || (this._children = []);
        let child, field, chunks;
        if (child = columns[index]) {
          return child;
        }
        if (field = (this._type.children || [])[index]) {
          chunks = this._chunks.map((vector) => vector.getChildAt(index)).filter((vec) => vec != null);
          if (chunks.length > 0) {
            return columns[index] = new Chunked2(field.type, chunks);
          }
        }
        return null;
      }
      search(index, then) {
        let idx = index;
        let offsets = this._chunkOffsets, rhs = offsets.length - 1;
        if (idx < 0) {
          return null;
        }
        if (idx >= offsets[rhs]) {
          return null;
        }
        if (rhs <= 1) {
          return then ? then(this, 0, idx) : [0, idx];
        }
        let lhs = 0, pos = 0, mid = 0;
        do {
          if (lhs + 1 === rhs) {
            return then ? then(this, lhs, idx - pos) : [lhs, idx - pos];
          }
          mid = lhs + (rhs - lhs) / 2 | 0;
          idx >= offsets[mid] ? lhs = mid : rhs = mid;
        } while (idx < offsets[rhs] && idx >= (pos = offsets[lhs]));
        return null;
      }
      isValid(index) {
        return !!this.search(index, this.isValidInternal);
      }
      get(index) {
        return this.search(index, this.getInternal);
      }
      set(index, value) {
        this.search(index, ({ chunks }, i, j) => chunks[i].set(j, value));
      }
      indexOf(element, offset) {
        if (offset && typeof offset === "number") {
          return this.search(offset, (self, i, j) => this.indexOfInternal(self, i, j, element));
        }
        return this.indexOfInternal(this, 0, Math.max(0, offset || 0), element);
      }
      toArray() {
        const { chunks } = this;
        const n = chunks.length;
        let ArrayType = this._type.ArrayType;
        if (n <= 0) {
          return new ArrayType(0);
        }
        if (n <= 1) {
          return chunks[0].toArray();
        }
        let len = 0, src = new Array(n);
        for (let i = -1; ++i < n; ) {
          len += (src[i] = chunks[i].toArray()).length;
        }
        if (ArrayType !== src[0].constructor) {
          ArrayType = src[0].constructor;
        }
        let dst = new ArrayType(len);
        let set = ArrayType === Array ? arraySet : typedSet;
        for (let i = -1, idx = 0; ++i < n; ) {
          idx = set(src[i], dst, idx);
        }
        return dst;
      }
      getInternal({ _chunks }, i, j) {
        return _chunks[i].get(j);
      }
      isValidInternal({ _chunks }, i, j) {
        return _chunks[i].isValid(j);
      }
      indexOfInternal({ _chunks }, chunkIndex, fromIndex, element) {
        let i = chunkIndex - 1, n = _chunks.length;
        let start = fromIndex, offset = 0, found = -1;
        while (++i < n) {
          if (~(found = _chunks[i].indexOf(element, start))) {
            return offset + found;
          }
          start = 0;
          offset += _chunks[i].length;
        }
        return -1;
      }
      _sliceInternal(self, begin, end) {
        const slices = [];
        const { chunks, _chunkOffsets: chunkOffsets } = self;
        for (let i = -1, n = chunks.length; ++i < n; ) {
          const chunk = chunks[i];
          const chunkLength = chunk.length;
          const chunkOffset = chunkOffsets[i];
          if (chunkOffset >= end) {
            break;
          }
          if (begin >= chunkOffset + chunkLength) {
            continue;
          }
          if (chunkOffset >= begin && chunkOffset + chunkLength <= end) {
            slices.push(chunk);
            continue;
          }
          const from = Math.max(0, begin - chunkOffset);
          const to = Math.min(end - chunkOffset, chunkLength);
          slices.push(chunk.slice(from, to));
        }
        return self.clone(slices);
      }
    };
    exports.Chunked = Chunked2;
    function calculateOffsets(vectors) {
      let offsets = new Uint32Array((vectors || []).length + 1);
      let offset = offsets[0] = 0, length = offsets.length;
      for (let index = 0; ++index < length; ) {
        offsets[index] = offset += vectors[index - 1].length;
      }
      return offsets;
    }
    var typedSet = (src, dst, offset) => {
      dst.set(src, offset);
      return offset + src.length;
    };
    var arraySet = (src, dst, offset) => {
      let idx = offset;
      for (let i = -1, n = src.length; ++i < n; ) {
        dst[idx++] = src[i];
      }
      return idx;
    };
  }
});

// node_modules/apache-arrow/column.js
var require_column = __commonJS({
  "node_modules/apache-arrow/column.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema_1 = require_schema();
    var vector_1 = require_vector();
    var chunked_1 = require_chunked();
    var Column2 = class extends chunked_1.Chunked {
      constructor(field, vectors = [], offsets) {
        vectors = chunked_1.Chunked.flatten(...vectors);
        super(field.type, vectors, offsets);
        this._field = field;
        if (vectors.length === 1 && !(this instanceof SingleChunkColumn)) {
          return new SingleChunkColumn(field, vectors[0], this._chunkOffsets);
        }
      }
      static new(field, data, ...rest) {
        const chunks = chunked_1.Chunked.flatten(Array.isArray(data) ? [...data, ...rest] : data instanceof vector_1.Vector ? [data, ...rest] : [vector_1.Vector.new(data, ...rest)]);
        if (typeof field === "string") {
          const type = chunks[0].data.type;
          field = new schema_1.Field(field, type, true);
        } else if (!field.nullable && chunks.some(({ nullCount }) => nullCount > 0)) {
          field = field.clone({ nullable: true });
        }
        return new Column2(field, chunks);
      }
      get field() {
        return this._field;
      }
      get name() {
        return this._field.name;
      }
      get nullable() {
        return this._field.nullable;
      }
      get metadata() {
        return this._field.metadata;
      }
      clone(chunks = this._chunks) {
        return new Column2(this._field, chunks);
      }
      getChildAt(index) {
        if (index < 0 || index >= this.numChildren) {
          return null;
        }
        let columns = this._children || (this._children = []);
        let column, field, chunks;
        if (column = columns[index]) {
          return column;
        }
        if (field = (this.type.children || [])[index]) {
          chunks = this._chunks.map((vector) => vector.getChildAt(index)).filter((vec) => vec != null);
          if (chunks.length > 0) {
            return columns[index] = new Column2(field, chunks);
          }
        }
        return null;
      }
    };
    exports.Column = Column2;
    var SingleChunkColumn = class extends Column2 {
      constructor(field, vector, offsets) {
        super(field, [vector], offsets);
        this._chunk = vector;
      }
      search(index, then) {
        return then ? then(this, 0, index) : [0, index];
      }
      isValid(index) {
        return this._chunk.isValid(index);
      }
      get(index) {
        return this._chunk.get(index);
      }
      set(index, value) {
        this._chunk.set(index, value);
      }
      indexOf(element, offset) {
        return this._chunk.indexOf(element, offset);
      }
    };
  }
});

// node_modules/apache-arrow/util/args.js
var require_args = __commonJS({
  "node_modules/apache-arrow/util/args.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_1 = require_data();
    var schema_1 = require_schema();
    var column_1 = require_column();
    var vector_1 = require_vector();
    var type_1 = require_type();
    var chunked_1 = require_chunked();
    var isArray = Array.isArray;
    exports.selectArgs = (Ctor, vals) => _selectArgs(Ctor, vals, [], 0);
    exports.selectColumnArgs = (args) => {
      const [fields, values] = _selectFieldArgs(args, [[], []]);
      return values.map((x, i) => x instanceof column_1.Column ? column_1.Column.new(x.field.clone(fields[i]), x) : x instanceof vector_1.Vector ? column_1.Column.new(fields[i], x) : column_1.Column.new(fields[i], []));
    };
    exports.selectFieldArgs = (args) => _selectFieldArgs(args, [[], []]);
    exports.selectChunkArgs = (Ctor, vals) => _selectChunkArgs(Ctor, vals, [], 0);
    exports.selectVectorChildrenArgs = (Ctor, vals) => _selectVectorChildrenArgs(Ctor, vals, [], 0);
    exports.selectColumnChildrenArgs = (Ctor, vals) => _selectColumnChildrenArgs(Ctor, vals, [], 0);
    function _selectArgs(Ctor, vals, res, idx) {
      let value, j = idx;
      let i = -1, n = vals.length;
      while (++i < n) {
        if (isArray(value = vals[i])) {
          j = _selectArgs(Ctor, value, res, j).length;
        } else if (value instanceof Ctor) {
          res[j++] = value;
        }
      }
      return res;
    }
    function _selectChunkArgs(Ctor, vals, res, idx) {
      let value, j = idx;
      let i = -1, n = vals.length;
      while (++i < n) {
        if (isArray(value = vals[i])) {
          j = _selectChunkArgs(Ctor, value, res, j).length;
        } else if (value instanceof chunked_1.Chunked) {
          j = _selectChunkArgs(Ctor, value.chunks, res, j).length;
        } else if (value instanceof Ctor) {
          res[j++] = value;
        }
      }
      return res;
    }
    function _selectVectorChildrenArgs(Ctor, vals, res, idx) {
      let value, j = idx;
      let i = -1, n = vals.length;
      while (++i < n) {
        if (isArray(value = vals[i])) {
          j = _selectVectorChildrenArgs(Ctor, value, res, j).length;
        } else if (value instanceof Ctor) {
          j = _selectArgs(vector_1.Vector, value.schema.fields.map((_, i2) => value.getChildAt(i2)), res, j).length;
        } else if (value instanceof vector_1.Vector) {
          res[j++] = value;
        }
      }
      return res;
    }
    function _selectColumnChildrenArgs(Ctor, vals, res, idx) {
      let value, j = idx;
      let i = -1, n = vals.length;
      while (++i < n) {
        if (isArray(value = vals[i])) {
          j = _selectColumnChildrenArgs(Ctor, value, res, j).length;
        } else if (value instanceof Ctor) {
          j = _selectArgs(column_1.Column, value.schema.fields.map((f, i2) => column_1.Column.new(f, value.getChildAt(i2))), res, j).length;
        } else if (value instanceof column_1.Column) {
          res[j++] = value;
        }
      }
      return res;
    }
    var toKeysAndValues = (xs, [k, v], i) => (xs[0][i] = k, xs[1][i] = v, xs);
    function _selectFieldArgs(vals, ret) {
      let keys, n;
      switch (n = vals.length) {
        case 0:
          return ret;
        case 1:
          keys = ret[0];
          if (!vals[0]) {
            return ret;
          }
          if (isArray(vals[0])) {
            return _selectFieldArgs(vals[0], ret);
          }
          if (!(vals[0] instanceof data_1.Data || vals[0] instanceof vector_1.Vector || vals[0] instanceof type_1.DataType)) {
            [keys, vals] = Object.entries(vals[0]).reduce(toKeysAndValues, ret);
          }
          break;
        default:
          !isArray(keys = vals[n - 1]) ? (vals = isArray(vals[0]) ? vals[0] : vals, keys = []) : vals = isArray(vals[0]) ? vals[0] : vals.slice(0, n - 1);
      }
      let fieldIndex = -1;
      let valueIndex = -1;
      let idx = -1, len = vals.length;
      let field;
      let val;
      let [fields, values] = ret;
      while (++idx < len) {
        val = vals[idx];
        if (val instanceof column_1.Column && (values[++valueIndex] = val)) {
          fields[++fieldIndex] = val.field.clone(keys[idx], val.type, true);
        } else {
          ({ [idx]: field = idx } = keys);
          if (val instanceof type_1.DataType && (values[++valueIndex] = val)) {
            fields[++fieldIndex] = schema_1.Field.new(field, val, true);
          } else if (val && val.type && (values[++valueIndex] = val)) {
            val instanceof data_1.Data && (values[valueIndex] = val = vector_1.Vector.new(val));
            fields[++fieldIndex] = schema_1.Field.new(field, val.type, true);
          }
        }
      }
      return ret;
    }
  }
});

// node_modules/apache-arrow/schema.js
var require_schema = __commonJS({
  "node_modules/apache-arrow/schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var type_1 = require_type();
    var args_1 = require_args();
    var args_2 = require_args();
    var typecomparator_1 = require_typecomparator();
    var Schema2 = class {
      constructor(fields = [], metadata, dictionaries) {
        this.fields = fields || [];
        this.metadata = metadata || /* @__PURE__ */ new Map();
        if (!dictionaries) {
          dictionaries = generateDictionaryMap(fields);
        }
        this.dictionaries = dictionaries;
      }
      static from(...args) {
        return Schema2.new(args[0], args[1]);
      }
      static new(...args) {
        return new Schema2(args_2.selectFieldArgs(args)[0]);
      }
      get [Symbol.toStringTag]() {
        return "Schema";
      }
      toString() {
        return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(", ")} }>`;
      }
      compareTo(other) {
        return typecomparator_1.instance.compareSchemas(this, other);
      }
      select(...columnNames) {
        const names = columnNames.reduce((xs, x) => (xs[x] = true) && xs, /* @__PURE__ */ Object.create(null));
        return new Schema2(this.fields.filter((f) => names[f.name]), this.metadata);
      }
      selectAt(...columnIndices) {
        return new Schema2(columnIndices.map((i) => this.fields[i]).filter(Boolean), this.metadata);
      }
      assign(...args) {
        const other = args[0] instanceof Schema2 ? args[0] : new Schema2(args_1.selectArgs(Field2, args));
        const curFields = [...this.fields];
        const metadata = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), other.metadata);
        const newFields = other.fields.filter((f2) => {
          const i = curFields.findIndex((f) => f.name === f2.name);
          return ~i ? (curFields[i] = f2.clone({
            metadata: mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), curFields[i].metadata), f2.metadata)
          })) && false : true;
        });
        const newDictionaries = generateDictionaryMap(newFields, /* @__PURE__ */ new Map());
        return new Schema2([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));
      }
    };
    exports.Schema = Schema2;
    var Field2 = class {
      constructor(name, type, nullable = false, metadata) {
        this.name = name;
        this.type = type;
        this.nullable = nullable;
        this.metadata = metadata || /* @__PURE__ */ new Map();
      }
      static new(...args) {
        let [name, type, nullable, metadata] = args;
        if (args[0] && typeof args[0] === "object") {
          ({ name } = args[0]);
          type === void 0 && (type = args[0].type);
          nullable === void 0 && (nullable = args[0].nullable);
          metadata === void 0 && (metadata = args[0].metadata);
        }
        return new Field2(`${name}`, type, nullable, metadata);
      }
      get typeId() {
        return this.type.typeId;
      }
      get [Symbol.toStringTag]() {
        return "Field";
      }
      toString() {
        return `${this.name}: ${this.type}`;
      }
      compareTo(other) {
        return typecomparator_1.instance.compareField(this, other);
      }
      clone(...args) {
        let [name, type, nullable, metadata] = args;
        !args[0] || typeof args[0] !== "object" ? [name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args : { name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata } = args[0];
        return Field2.new(name, type, nullable, metadata);
      }
    };
    exports.Field = Field2;
    function mergeMaps(m1, m2) {
      return new Map([...m1 || /* @__PURE__ */ new Map(), ...m2 || /* @__PURE__ */ new Map()]);
    }
    function generateDictionaryMap(fields, dictionaries = /* @__PURE__ */ new Map()) {
      for (let i = -1, n = fields.length; ++i < n; ) {
        const field = fields[i];
        const type = field.type;
        if (type_1.DataType.isDictionary(type)) {
          if (!dictionaries.has(type.id)) {
            dictionaries.set(type.id, type.dictionary);
          } else if (dictionaries.get(type.id) !== type.dictionary) {
            throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
          }
        }
        if (type.children && type.children.length > 0) {
          generateDictionaryMap(type.children, dictionaries);
        }
      }
      return dictionaries;
    }
    Schema2.prototype.fields = null;
    Schema2.prototype.metadata = null;
    Schema2.prototype.dictionaries = null;
    Field2.prototype.type = null;
    Field2.prototype.name = null;
    Field2.prototype.nullable = null;
    Field2.prototype.metadata = null;
  }
});

// node_modules/apache-arrow/builder/list.js
var require_list = __commonJS({
  "node_modules/apache-arrow/builder/list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var run_1 = require_run();
    var schema_1 = require_schema();
    var type_1 = require_type();
    var buffer_1 = require_buffer2();
    var builder_1 = require_builder();
    var ListBuilder2 = class extends builder_1.VariableWidthBuilder {
      constructor(opts) {
        super(opts);
        this._run = new run_1.Run();
        this._offsets = new buffer_1.OffsetsBufferBuilder();
      }
      addChild(child, name = "0") {
        if (this.numChildren > 0) {
          throw new Error("ListBuilder can only have one child.");
        }
        this.children[this.numChildren] = child;
        this.type = new type_1.List(new schema_1.Field(name, child.type, true));
        return this.numChildren - 1;
      }
      clear() {
        this._run.clear();
        return super.clear();
      }
      _flushPending(pending) {
        const run = this._run;
        const offsets = this._offsets;
        const setValue = this._setValue;
        let index = 0, value;
        for ([index, value] of pending) {
          if (value === void 0) {
            offsets.set(index, 0);
          } else {
            offsets.set(index, value.length);
            setValue(this, index, run.bind(value));
          }
        }
      }
    };
    exports.ListBuilder = ListBuilder2;
  }
});

// node_modules/apache-arrow/builder/fixedsizelist.js
var require_fixedsizelist = __commonJS({
  "node_modules/apache-arrow/builder/fixedsizelist.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var run_1 = require_run();
    var schema_1 = require_schema();
    var builder_1 = require_builder();
    var type_1 = require_type();
    var FixedSizeListBuilder2 = class extends builder_1.Builder {
      constructor() {
        super(...arguments);
        this._run = new run_1.Run();
      }
      setValue(index, value) {
        super.setValue(index, this._run.bind(value));
      }
      addChild(child, name = "0") {
        if (this.numChildren > 0) {
          throw new Error("FixedSizeListBuilder can only have one child.");
        }
        const childIndex = this.children.push(child);
        this.type = new type_1.FixedSizeList(this.type.listSize, new schema_1.Field(name, child.type, true));
        return childIndex;
      }
      clear() {
        this._run.clear();
        return super.clear();
      }
    };
    exports.FixedSizeListBuilder = FixedSizeListBuilder2;
  }
});

// node_modules/apache-arrow/builder/map.js
var require_map = __commonJS({
  "node_modules/apache-arrow/builder/map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema_1 = require_schema();
    var type_1 = require_type();
    var builder_1 = require_builder();
    var MapBuilder2 = class extends builder_1.VariableWidthBuilder {
      set(index, value) {
        return super.set(index, value);
      }
      setValue(index, value) {
        value = value instanceof Map ? value : new Map(Object.entries(value));
        const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
        const current = pending.get(index);
        current && (this._pendingLength -= current.size);
        this._pendingLength += value.size;
        pending.set(index, value);
      }
      addChild(child, name = `${this.numChildren}`) {
        if (this.numChildren > 0) {
          throw new Error("ListBuilder can only have one child.");
        }
        this.children[this.numChildren] = child;
        this.type = new type_1.Map_(new schema_1.Field(name, child.type, true), this.type.keysSorted);
        return this.numChildren - 1;
      }
      _flushPending(pending) {
        const offsets = this._offsets;
        const setValue = this._setValue;
        pending.forEach((value, index) => {
          if (value === void 0) {
            offsets.set(index, 0);
          } else {
            offsets.set(index, value.size);
            setValue(this, index, value);
          }
        });
      }
    };
    exports.MapBuilder = MapBuilder2;
  }
});

// node_modules/apache-arrow/builder/struct.js
var require_struct = __commonJS({
  "node_modules/apache-arrow/builder/struct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema_1 = require_schema();
    var builder_1 = require_builder();
    var type_1 = require_type();
    var StructBuilder2 = class extends builder_1.Builder {
      addChild(child, name = `${this.numChildren}`) {
        const childIndex = this.children.push(child);
        this.type = new type_1.Struct([...this.type.children, new schema_1.Field(name, child.type, true)]);
        return childIndex;
      }
    };
    exports.StructBuilder = StructBuilder2;
  }
});

// node_modules/apache-arrow/builder/union.js
var require_union = __commonJS({
  "node_modules/apache-arrow/builder/union.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema_1 = require_schema();
    var buffer_1 = require_buffer2();
    var builder_1 = require_builder();
    var type_1 = require_type();
    var UnionBuilder2 = class extends builder_1.Builder {
      constructor(options) {
        super(options);
        this._typeIds = new buffer_1.DataBufferBuilder(new Int8Array(0), 1);
        if (typeof options["valueToChildTypeId"] === "function") {
          this._valueToChildTypeId = options["valueToChildTypeId"];
        }
      }
      get typeIdToChildIndex() {
        return this.type.typeIdToChildIndex;
      }
      append(value, childTypeId) {
        return this.set(this.length, value, childTypeId);
      }
      set(index, value, childTypeId) {
        if (childTypeId === void 0) {
          childTypeId = this._valueToChildTypeId(this, value, index);
        }
        if (this.setValid(index, this.isValid(value))) {
          this.setValue(index, value, childTypeId);
        }
        return this;
      }
      setValue(index, value, childTypeId) {
        this._typeIds.set(index, childTypeId);
        super.setValue(index, value);
      }
      addChild(child, name = `${this.children.length}`) {
        const childTypeId = this.children.push(child);
        const { type: { children, mode, typeIds } } = this;
        const fields = [...children, new schema_1.Field(name, child.type)];
        this.type = new type_1.Union(mode, [...typeIds, childTypeId], fields);
        return childTypeId;
      }
      _valueToChildTypeId(builder, value, offset) {
        throw new Error(`Cannot map UnionBuilder value to child typeId. Pass the \`childTypeId\` as the second argument to unionBuilder.append(), or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
      }
    };
    exports.UnionBuilder = UnionBuilder2;
    var SparseUnionBuilder2 = class extends UnionBuilder2 {
    };
    exports.SparseUnionBuilder = SparseUnionBuilder2;
    var DenseUnionBuilder2 = class extends UnionBuilder2 {
      constructor(options) {
        super(options);
        this._offsets = new buffer_1.DataBufferBuilder(new Int32Array(0));
      }
      setValue(index, value, childTypeId) {
        const childIndex = this.type.typeIdToChildIndex[childTypeId];
        this._offsets.set(index, this.getChildAt(childIndex).length);
        return super.setValue(index, value, childTypeId);
      }
    };
    exports.DenseUnionBuilder = DenseUnionBuilder2;
  }
});

// node_modules/apache-arrow/visitor/set.js
var require_set = __commonJS({
  "node_modules/apache-arrow/visitor/set.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector();
    var visitor_1 = require_visitor();
    var utf8_1 = require_utf8();
    var math_1 = require_math();
    var buffer_1 = require_buffer();
    var enum_1 = require_enum();
    var SetVisitor = class extends visitor_1.Visitor {
    };
    exports.SetVisitor = SetVisitor;
    var setEpochMsToDays = (data, index, epochMs) => {
      data[index] = epochMs / 864e5 | 0;
    };
    var setEpochMsToMillisecondsLong = (data, index, epochMs) => {
      data[index] = epochMs % 4294967296 | 0;
      data[index + 1] = epochMs / 4294967296 | 0;
    };
    var setEpochMsToMicrosecondsLong = (data, index, epochMs) => {
      data[index] = epochMs * 1e3 % 4294967296 | 0;
      data[index + 1] = epochMs * 1e3 / 4294967296 | 0;
    };
    var setEpochMsToNanosecondsLong = (data, index, epochMs) => {
      data[index] = epochMs * 1e6 % 4294967296 | 0;
      data[index + 1] = epochMs * 1e6 / 4294967296 | 0;
    };
    var setVariableWidthBytes = (values, valueOffsets, index, value) => {
      const { [index]: x, [index + 1]: y } = valueOffsets;
      if (x != null && y != null) {
        values.set(value.subarray(0, y - x), x);
      }
    };
    var setBool = ({ offset, values }, index, val) => {
      const idx = offset + index;
      val ? values[idx >> 3] |= 1 << idx % 8 : values[idx >> 3] &= ~(1 << idx % 8);
    };
    var setDateDay = ({ values }, index, value) => {
      setEpochMsToDays(values, index, value.valueOf());
    };
    var setDateMillisecond = ({ values }, index, value) => {
      setEpochMsToMillisecondsLong(values, index * 2, value.valueOf());
    };
    var setNumeric = ({ stride, values }, index, value) => {
      values[stride * index] = value;
    };
    var setFloat16 = ({ stride, values }, index, value) => {
      values[stride * index] = math_1.float64ToUint16(value);
    };
    var setNumericX2 = (vector, index, value) => {
      switch (typeof value) {
        case "bigint":
          vector.values64[index] = value;
          break;
        case "number":
          vector.values[index * vector.stride] = value;
          break;
        default:
          const val = value;
          const { stride, ArrayType } = vector;
          const long = buffer_1.toArrayBufferView(ArrayType, val);
          vector.values.set(long.subarray(0, stride), stride * index);
      }
    };
    var setFixedSizeBinary = ({ stride, values }, index, value) => {
      values.set(value.subarray(0, stride), stride * index);
    };
    var setBinary = ({ values, valueOffsets }, index, value) => setVariableWidthBytes(values, valueOffsets, index, value);
    var setUtf8 = ({ values, valueOffsets }, index, value) => {
      setVariableWidthBytes(values, valueOffsets, index, utf8_1.encodeUtf8(value));
    };
    var setInt = (vector, index, value) => {
      vector.type.bitWidth < 64 ? setNumeric(vector, index, value) : setNumericX2(vector, index, value);
    };
    var setFloat = (vector, index, value) => {
      vector.type.precision !== enum_1.Precision.HALF ? setNumeric(vector, index, value) : setFloat16(vector, index, value);
    };
    var setDate = (vector, index, value) => {
      vector.type.unit === enum_1.DateUnit.DAY ? setDateDay(vector, index, value) : setDateMillisecond(vector, index, value);
    };
    var setTimestampSecond = ({ values }, index, value) => setEpochMsToMillisecondsLong(values, index * 2, value / 1e3);
    var setTimestampMillisecond = ({ values }, index, value) => setEpochMsToMillisecondsLong(values, index * 2, value);
    var setTimestampMicrosecond = ({ values }, index, value) => setEpochMsToMicrosecondsLong(values, index * 2, value);
    var setTimestampNanosecond = ({ values }, index, value) => setEpochMsToNanosecondsLong(values, index * 2, value);
    var setTimestamp = (vector, index, value) => {
      switch (vector.type.unit) {
        case enum_1.TimeUnit.SECOND:
          return setTimestampSecond(vector, index, value);
        case enum_1.TimeUnit.MILLISECOND:
          return setTimestampMillisecond(vector, index, value);
        case enum_1.TimeUnit.MICROSECOND:
          return setTimestampMicrosecond(vector, index, value);
        case enum_1.TimeUnit.NANOSECOND:
          return setTimestampNanosecond(vector, index, value);
      }
    };
    var setTimeSecond = ({ values, stride }, index, value) => {
      values[stride * index] = value;
    };
    var setTimeMillisecond = ({ values, stride }, index, value) => {
      values[stride * index] = value;
    };
    var setTimeMicrosecond = ({ values }, index, value) => {
      values.set(value.subarray(0, 2), 2 * index);
    };
    var setTimeNanosecond = ({ values }, index, value) => {
      values.set(value.subarray(0, 2), 2 * index);
    };
    var setTime = (vector, index, value) => {
      switch (vector.type.unit) {
        case enum_1.TimeUnit.SECOND:
          return setTimeSecond(vector, index, value);
        case enum_1.TimeUnit.MILLISECOND:
          return setTimeMillisecond(vector, index, value);
        case enum_1.TimeUnit.MICROSECOND:
          return setTimeMicrosecond(vector, index, value);
        case enum_1.TimeUnit.NANOSECOND:
          return setTimeNanosecond(vector, index, value);
      }
    };
    var setDecimal = ({ values }, index, value) => {
      values.set(value.subarray(0, 4), 4 * index);
    };
    var setList = (vector, index, value) => {
      const values = vector.getChildAt(0), valueOffsets = vector.valueOffsets;
      for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end; ) {
        values.set(itr++, value.get(++idx));
      }
    };
    var setMap = (vector, index, value) => {
      const values = vector.getChildAt(0), valueOffsets = vector.valueOffsets;
      const entries = value instanceof Map ? [...value] : Object.entries(value);
      for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end; ) {
        values.set(itr++, entries[++idx]);
      }
    };
    var _setStructArrayValue = (o, v) => (c, _, i) => c && c.set(o, v[i]);
    var _setStructVectorValue = (o, v) => (c, _, i) => c && c.set(o, v.get(i));
    var _setStructMapValue = (o, v) => (c, f, _) => c && c.set(o, v.get(f.name));
    var _setStructObjectValue = (o, v) => (c, f, _) => c && c.set(o, v[f.name]);
    var setStruct = (vector, index, value) => {
      const setValue = value instanceof Map ? _setStructMapValue(index, value) : value instanceof vector_1.Vector ? _setStructVectorValue(index, value) : Array.isArray(value) ? _setStructArrayValue(index, value) : _setStructObjectValue(index, value);
      vector.type.children.forEach((f, i) => setValue(vector.getChildAt(i), f, i));
    };
    var setUnion = (vector, index, value) => {
      vector.type.mode === enum_1.UnionMode.Dense ? setDenseUnion(vector, index, value) : setSparseUnion(vector, index, value);
    };
    var setDenseUnion = (vector, index, value) => {
      const childIndex = vector.typeIdToChildIndex[vector.typeIds[index]];
      const child = vector.getChildAt(childIndex);
      child && child.set(vector.valueOffsets[index], value);
    };
    var setSparseUnion = (vector, index, value) => {
      const childIndex = vector.typeIdToChildIndex[vector.typeIds[index]];
      const child = vector.getChildAt(childIndex);
      child && child.set(index, value);
    };
    var setDictionary = (vector, index, value) => {
      const key = vector.getKey(index);
      if (key !== null) {
        vector.setValue(key, value);
      }
    };
    var setIntervalValue = (vector, index, value) => {
      vector.type.unit === enum_1.IntervalUnit.DAY_TIME ? setIntervalDayTime(vector, index, value) : setIntervalYearMonth(vector, index, value);
    };
    var setIntervalDayTime = ({ values }, index, value) => {
      values.set(value.subarray(0, 2), 2 * index);
    };
    var setIntervalYearMonth = ({ values }, index, value) => {
      values[index] = value[0] * 12 + value[1] % 12;
    };
    var setFixedSizeList = (vector, index, value) => {
      const child = vector.getChildAt(0), { stride } = vector;
      for (let idx = -1, offset = index * stride; ++idx < stride; ) {
        child.set(offset + idx, value.get(idx));
      }
    };
    SetVisitor.prototype.visitBool = setBool;
    SetVisitor.prototype.visitInt = setInt;
    SetVisitor.prototype.visitInt8 = setNumeric;
    SetVisitor.prototype.visitInt16 = setNumeric;
    SetVisitor.prototype.visitInt32 = setNumeric;
    SetVisitor.prototype.visitInt64 = setNumericX2;
    SetVisitor.prototype.visitUint8 = setNumeric;
    SetVisitor.prototype.visitUint16 = setNumeric;
    SetVisitor.prototype.visitUint32 = setNumeric;
    SetVisitor.prototype.visitUint64 = setNumericX2;
    SetVisitor.prototype.visitFloat = setFloat;
    SetVisitor.prototype.visitFloat16 = setFloat16;
    SetVisitor.prototype.visitFloat32 = setNumeric;
    SetVisitor.prototype.visitFloat64 = setNumeric;
    SetVisitor.prototype.visitUtf8 = setUtf8;
    SetVisitor.prototype.visitBinary = setBinary;
    SetVisitor.prototype.visitFixedSizeBinary = setFixedSizeBinary;
    SetVisitor.prototype.visitDate = setDate;
    SetVisitor.prototype.visitDateDay = setDateDay;
    SetVisitor.prototype.visitDateMillisecond = setDateMillisecond;
    SetVisitor.prototype.visitTimestamp = setTimestamp;
    SetVisitor.prototype.visitTimestampSecond = setTimestampSecond;
    SetVisitor.prototype.visitTimestampMillisecond = setTimestampMillisecond;
    SetVisitor.prototype.visitTimestampMicrosecond = setTimestampMicrosecond;
    SetVisitor.prototype.visitTimestampNanosecond = setTimestampNanosecond;
    SetVisitor.prototype.visitTime = setTime;
    SetVisitor.prototype.visitTimeSecond = setTimeSecond;
    SetVisitor.prototype.visitTimeMillisecond = setTimeMillisecond;
    SetVisitor.prototype.visitTimeMicrosecond = setTimeMicrosecond;
    SetVisitor.prototype.visitTimeNanosecond = setTimeNanosecond;
    SetVisitor.prototype.visitDecimal = setDecimal;
    SetVisitor.prototype.visitList = setList;
    SetVisitor.prototype.visitStruct = setStruct;
    SetVisitor.prototype.visitUnion = setUnion;
    SetVisitor.prototype.visitDenseUnion = setDenseUnion;
    SetVisitor.prototype.visitSparseUnion = setSparseUnion;
    SetVisitor.prototype.visitDictionary = setDictionary;
    SetVisitor.prototype.visitInterval = setIntervalValue;
    SetVisitor.prototype.visitIntervalDayTime = setIntervalDayTime;
    SetVisitor.prototype.visitIntervalYearMonth = setIntervalYearMonth;
    SetVisitor.prototype.visitFixedSizeList = setFixedSizeList;
    SetVisitor.prototype.visitMap = setMap;
    exports.instance = new SetVisitor();
  }
});

// node_modules/apache-arrow/visitor/builderctor.js
var require_builderctor = __commonJS({
  "node_modules/apache-arrow/visitor/builderctor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var visitor_1 = require_visitor();
    var binary_1 = require_binary();
    var bool_1 = require_bool();
    var date_1 = require_date();
    var decimal_1 = require_decimal();
    var dictionary_1 = require_dictionary();
    var fixedsizebinary_1 = require_fixedsizebinary();
    var fixedsizelist_1 = require_fixedsizelist();
    var float_1 = require_float();
    var interval_1 = require_interval();
    var int_1 = require_int();
    var list_1 = require_list();
    var map_1 = require_map();
    var null_1 = require_null();
    var struct_1 = require_struct();
    var timestamp_1 = require_timestamp();
    var time_1 = require_time();
    var union_1 = require_union();
    var utf8_1 = require_utf82();
    var GetBuilderCtor = class extends visitor_1.Visitor {
      visitNull() {
        return null_1.NullBuilder;
      }
      visitBool() {
        return bool_1.BoolBuilder;
      }
      visitInt() {
        return int_1.IntBuilder;
      }
      visitInt8() {
        return int_1.Int8Builder;
      }
      visitInt16() {
        return int_1.Int16Builder;
      }
      visitInt32() {
        return int_1.Int32Builder;
      }
      visitInt64() {
        return int_1.Int64Builder;
      }
      visitUint8() {
        return int_1.Uint8Builder;
      }
      visitUint16() {
        return int_1.Uint16Builder;
      }
      visitUint32() {
        return int_1.Uint32Builder;
      }
      visitUint64() {
        return int_1.Uint64Builder;
      }
      visitFloat() {
        return float_1.FloatBuilder;
      }
      visitFloat16() {
        return float_1.Float16Builder;
      }
      visitFloat32() {
        return float_1.Float32Builder;
      }
      visitFloat64() {
        return float_1.Float64Builder;
      }
      visitUtf8() {
        return utf8_1.Utf8Builder;
      }
      visitBinary() {
        return binary_1.BinaryBuilder;
      }
      visitFixedSizeBinary() {
        return fixedsizebinary_1.FixedSizeBinaryBuilder;
      }
      visitDate() {
        return date_1.DateBuilder;
      }
      visitDateDay() {
        return date_1.DateDayBuilder;
      }
      visitDateMillisecond() {
        return date_1.DateMillisecondBuilder;
      }
      visitTimestamp() {
        return timestamp_1.TimestampBuilder;
      }
      visitTimestampSecond() {
        return timestamp_1.TimestampSecondBuilder;
      }
      visitTimestampMillisecond() {
        return timestamp_1.TimestampMillisecondBuilder;
      }
      visitTimestampMicrosecond() {
        return timestamp_1.TimestampMicrosecondBuilder;
      }
      visitTimestampNanosecond() {
        return timestamp_1.TimestampNanosecondBuilder;
      }
      visitTime() {
        return time_1.TimeBuilder;
      }
      visitTimeSecond() {
        return time_1.TimeSecondBuilder;
      }
      visitTimeMillisecond() {
        return time_1.TimeMillisecondBuilder;
      }
      visitTimeMicrosecond() {
        return time_1.TimeMicrosecondBuilder;
      }
      visitTimeNanosecond() {
        return time_1.TimeNanosecondBuilder;
      }
      visitDecimal() {
        return decimal_1.DecimalBuilder;
      }
      visitList() {
        return list_1.ListBuilder;
      }
      visitStruct() {
        return struct_1.StructBuilder;
      }
      visitUnion() {
        return union_1.UnionBuilder;
      }
      visitDenseUnion() {
        return union_1.DenseUnionBuilder;
      }
      visitSparseUnion() {
        return union_1.SparseUnionBuilder;
      }
      visitDictionary() {
        return dictionary_1.DictionaryBuilder;
      }
      visitInterval() {
        return interval_1.IntervalBuilder;
      }
      visitIntervalDayTime() {
        return interval_1.IntervalDayTimeBuilder;
      }
      visitIntervalYearMonth() {
        return interval_1.IntervalYearMonthBuilder;
      }
      visitFixedSizeList() {
        return fixedsizelist_1.FixedSizeListBuilder;
      }
      visitMap() {
        return map_1.MapBuilder;
      }
    };
    exports.GetBuilderCtor = GetBuilderCtor;
    exports.instance = new GetBuilderCtor();
  }
});

// node_modules/apache-arrow/builder/index.js
var require_builder2 = __commonJS({
  "node_modules/apache-arrow/builder/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var builder_1 = require_builder();
    exports.Builder = builder_1.Builder;
    var bool_1 = require_bool();
    exports.BoolBuilder = bool_1.BoolBuilder;
    var null_1 = require_null();
    exports.NullBuilder = null_1.NullBuilder;
    var date_1 = require_date();
    exports.DateBuilder = date_1.DateBuilder;
    exports.DateDayBuilder = date_1.DateDayBuilder;
    exports.DateMillisecondBuilder = date_1.DateMillisecondBuilder;
    var decimal_1 = require_decimal();
    exports.DecimalBuilder = decimal_1.DecimalBuilder;
    var dictionary_1 = require_dictionary();
    exports.DictionaryBuilder = dictionary_1.DictionaryBuilder;
    var fixedsizebinary_1 = require_fixedsizebinary();
    exports.FixedSizeBinaryBuilder = fixedsizebinary_1.FixedSizeBinaryBuilder;
    var float_1 = require_float();
    exports.FloatBuilder = float_1.FloatBuilder;
    exports.Float16Builder = float_1.Float16Builder;
    exports.Float32Builder = float_1.Float32Builder;
    exports.Float64Builder = float_1.Float64Builder;
    var int_1 = require_int();
    exports.IntBuilder = int_1.IntBuilder;
    exports.Int8Builder = int_1.Int8Builder;
    exports.Int16Builder = int_1.Int16Builder;
    exports.Int32Builder = int_1.Int32Builder;
    exports.Int64Builder = int_1.Int64Builder;
    exports.Uint8Builder = int_1.Uint8Builder;
    exports.Uint16Builder = int_1.Uint16Builder;
    exports.Uint32Builder = int_1.Uint32Builder;
    exports.Uint64Builder = int_1.Uint64Builder;
    var time_1 = require_time();
    exports.TimeBuilder = time_1.TimeBuilder;
    exports.TimeSecondBuilder = time_1.TimeSecondBuilder;
    exports.TimeMillisecondBuilder = time_1.TimeMillisecondBuilder;
    exports.TimeMicrosecondBuilder = time_1.TimeMicrosecondBuilder;
    exports.TimeNanosecondBuilder = time_1.TimeNanosecondBuilder;
    var timestamp_1 = require_timestamp();
    exports.TimestampBuilder = timestamp_1.TimestampBuilder;
    exports.TimestampSecondBuilder = timestamp_1.TimestampSecondBuilder;
    exports.TimestampMillisecondBuilder = timestamp_1.TimestampMillisecondBuilder;
    exports.TimestampMicrosecondBuilder = timestamp_1.TimestampMicrosecondBuilder;
    exports.TimestampNanosecondBuilder = timestamp_1.TimestampNanosecondBuilder;
    var interval_1 = require_interval();
    exports.IntervalBuilder = interval_1.IntervalBuilder;
    exports.IntervalDayTimeBuilder = interval_1.IntervalDayTimeBuilder;
    exports.IntervalYearMonthBuilder = interval_1.IntervalYearMonthBuilder;
    var utf8_1 = require_utf82();
    exports.Utf8Builder = utf8_1.Utf8Builder;
    var binary_1 = require_binary();
    exports.BinaryBuilder = binary_1.BinaryBuilder;
    var list_1 = require_list();
    exports.ListBuilder = list_1.ListBuilder;
    var fixedsizelist_1 = require_fixedsizelist();
    exports.FixedSizeListBuilder = fixedsizelist_1.FixedSizeListBuilder;
    var map_1 = require_map();
    exports.MapBuilder = map_1.MapBuilder;
    var struct_1 = require_struct();
    exports.StructBuilder = struct_1.StructBuilder;
    var union_1 = require_union();
    exports.UnionBuilder = union_1.UnionBuilder;
    exports.SparseUnionBuilder = union_1.SparseUnionBuilder;
    exports.DenseUnionBuilder = union_1.DenseUnionBuilder;
    var enum_1 = require_enum();
    var utf8_2 = require_utf82();
    var builder_2 = require_builder();
    var set_1 = require_set();
    var builderctor_1 = require_builderctor();
    builder_2.Builder.new = newBuilder;
    function newBuilder(options) {
      const type = options.type;
      const builder = new (builderctor_1.instance.getVisitFn(type)())(options);
      if (type.children && type.children.length > 0) {
        const children = options["children"] || [];
        const defaultOptions = { "nullValues": options["nullValues"] };
        const getChildOptions = Array.isArray(children) ? (_, i) => children[i] || defaultOptions : ({ name }) => children[name] || defaultOptions;
        type.children.forEach((field, index) => {
          const { type: type2 } = field;
          const opts = getChildOptions(field, index);
          builder.children.push(newBuilder({ ...opts, type: type2 }));
        });
      }
      return builder;
    }
    Object.keys(enum_1.Type).map((T) => enum_1.Type[T]).filter((T) => typeof T === "number" && T !== enum_1.Type.NONE).forEach((typeId) => {
      const BuilderCtor = builderctor_1.instance.visit(typeId);
      BuilderCtor.prototype._setValue = set_1.instance.getVisitFn(typeId);
    });
    utf8_2.Utf8Builder.prototype._setValue = set_1.instance.visitBinary;
  }
});

// node_modules/apache-arrow/fb/File.js
var require_File = __commonJS({
  "node_modules/apache-arrow/fb/File.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NS7624605610262437867 = require_Schema();
    var org;
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Footer {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              static getRootAsFooter(bb, obj) {
                return (obj || new Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
              }
              version() {
                let offset = this.bb.__offset(this.bb_pos, 4);
                return offset ? this.bb.readInt16(this.bb_pos + offset) : NS7624605610262437867.org.apache.arrow.flatbuf.MetadataVersion.V1;
              }
              schema(obj) {
                let offset = this.bb.__offset(this.bb_pos, 6);
                return offset ? (obj || new NS7624605610262437867.org.apache.arrow.flatbuf.Schema()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
              }
              dictionaries(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? (obj || new org2.apache.arrow.flatbuf.Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
              }
              dictionariesLength() {
                let offset = this.bb.__offset(this.bb_pos, 8);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              recordBatches(index, obj) {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? (obj || new org2.apache.arrow.flatbuf.Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
              }
              recordBatchesLength() {
                let offset = this.bb.__offset(this.bb_pos, 10);
                return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
              }
              static startFooter(builder) {
                builder.startObject(4);
              }
              static addVersion(builder, version) {
                builder.addFieldInt16(0, version, NS7624605610262437867.org.apache.arrow.flatbuf.MetadataVersion.V1);
              }
              static addSchema(builder, schemaOffset) {
                builder.addFieldOffset(1, schemaOffset, 0);
              }
              static addDictionaries(builder, dictionariesOffset) {
                builder.addFieldOffset(2, dictionariesOffset, 0);
              }
              static startDictionariesVector(builder, numElems) {
                builder.startVector(24, numElems, 8);
              }
              static addRecordBatches(builder, recordBatchesOffset) {
                builder.addFieldOffset(3, recordBatchesOffset, 0);
              }
              static startRecordBatchesVector(builder, numElems) {
                builder.startVector(24, numElems, 8);
              }
              static endFooter(builder) {
                let offset = builder.endObject();
                return offset;
              }
              static finishFooterBuffer(builder, offset) {
                builder.finish(offset);
              }
              static createFooter(builder, version, schemaOffset, dictionariesOffset, recordBatchesOffset) {
                Footer.startFooter(builder);
                Footer.addVersion(builder, version);
                Footer.addSchema(builder, schemaOffset);
                Footer.addDictionaries(builder, dictionariesOffset);
                Footer.addRecordBatches(builder, recordBatchesOffset);
                return Footer.endFooter(builder);
              }
            }
            flatbuf2.Footer = Footer;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
    (function(org2) {
      var apache;
      (function(apache2) {
        var arrow;
        (function(arrow2) {
          var flatbuf;
          (function(flatbuf2) {
            class Block {
              constructor() {
                this.bb = null;
                this.bb_pos = 0;
              }
              __init(i, bb) {
                this.bb_pos = i;
                this.bb = bb;
                return this;
              }
              offset() {
                return this.bb.readInt64(this.bb_pos);
              }
              metaDataLength() {
                return this.bb.readInt32(this.bb_pos + 8);
              }
              bodyLength() {
                return this.bb.readInt64(this.bb_pos + 16);
              }
              static createBlock(builder, offset, metaDataLength, bodyLength) {
                builder.prep(8, 24);
                builder.writeInt64(bodyLength);
                builder.pad(4);
                builder.writeInt32(metaDataLength);
                builder.writeInt64(offset);
                return builder.offset();
              }
            }
            flatbuf2.Block = Block;
          })(flatbuf = arrow2.flatbuf || (arrow2.flatbuf = {}));
        })(arrow = apache2.arrow || (apache2.arrow = {}));
      })(apache = org2.apache || (org2.apache = {}));
    })(org = exports.org || (exports.org = {}));
  }
});

// node_modules/apache-arrow/ipc/metadata/file.js
var require_file = __commonJS({
  "node_modules/apache-arrow/ipc/metadata/file.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var File_ = require_File();
    var flatbuffers_1 = (init_flatbuffers(), __toCommonJS(flatbuffers_exports));
    var Long = flatbuffers_1.flatbuffers.Long;
    var Builder3 = flatbuffers_1.flatbuffers.Builder;
    var ByteBuffer = flatbuffers_1.flatbuffers.ByteBuffer;
    var _Block = File_.org.apache.arrow.flatbuf.Block;
    var _Footer = File_.org.apache.arrow.flatbuf.Footer;
    var schema_1 = require_schema();
    var enum_1 = require_enum();
    var buffer_1 = require_buffer();
    var Footer_ = class {
      constructor(schema, version = enum_1.MetadataVersion.V4, recordBatches, dictionaryBatches) {
        this.schema = schema;
        this.version = version;
        recordBatches && (this._recordBatches = recordBatches);
        dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);
      }
      static decode(buf) {
        buf = new ByteBuffer(buffer_1.toUint8Array(buf));
        const footer = _Footer.getRootAsFooter(buf);
        const schema = schema_1.Schema.decode(footer.schema());
        return new OffHeapFooter(schema, footer);
      }
      static encode(footer) {
        const b = new Builder3();
        const schemaOffset = schema_1.Schema.encode(b, footer.schema);
        _Footer.startRecordBatchesVector(b, footer.numRecordBatches);
        [...footer.recordBatches()].slice().reverse().forEach((rb) => FileBlock.encode(b, rb));
        const recordBatchesOffset = b.endVector();
        _Footer.startDictionariesVector(b, footer.numDictionaries);
        [...footer.dictionaryBatches()].slice().reverse().forEach((db) => FileBlock.encode(b, db));
        const dictionaryBatchesOffset = b.endVector();
        _Footer.startFooter(b);
        _Footer.addSchema(b, schemaOffset);
        _Footer.addVersion(b, enum_1.MetadataVersion.V4);
        _Footer.addRecordBatches(b, recordBatchesOffset);
        _Footer.addDictionaries(b, dictionaryBatchesOffset);
        _Footer.finishFooterBuffer(b, _Footer.endFooter(b));
        return b.asUint8Array();
      }
      get numRecordBatches() {
        return this._recordBatches.length;
      }
      get numDictionaries() {
        return this._dictionaryBatches.length;
      }
      *recordBatches() {
        for (let block, i = -1, n = this.numRecordBatches; ++i < n; ) {
          if (block = this.getRecordBatch(i)) {
            yield block;
          }
        }
      }
      *dictionaryBatches() {
        for (let block, i = -1, n = this.numDictionaries; ++i < n; ) {
          if (block = this.getDictionaryBatch(i)) {
            yield block;
          }
        }
      }
      getRecordBatch(index) {
        return index >= 0 && index < this.numRecordBatches && this._recordBatches[index] || null;
      }
      getDictionaryBatch(index) {
        return index >= 0 && index < this.numDictionaries && this._dictionaryBatches[index] || null;
      }
    };
    exports.Footer = Footer_;
    var OffHeapFooter = class extends Footer_ {
      constructor(schema, _footer) {
        super(schema, _footer.version());
        this._footer = _footer;
      }
      get numRecordBatches() {
        return this._footer.recordBatchesLength();
      }
      get numDictionaries() {
        return this._footer.dictionariesLength();
      }
      getRecordBatch(index) {
        if (index >= 0 && index < this.numRecordBatches) {
          const fileBlock = this._footer.recordBatches(index);
          if (fileBlock) {
            return FileBlock.decode(fileBlock);
          }
        }
        return null;
      }
      getDictionaryBatch(index) {
        if (index >= 0 && index < this.numDictionaries) {
          const fileBlock = this._footer.dictionaries(index);
          if (fileBlock) {
            return FileBlock.decode(fileBlock);
          }
        }
        return null;
      }
    };
    var FileBlock = class {
      static decode(block) {
        return new FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
      }
      static encode(b, fileBlock) {
        const { metaDataLength } = fileBlock;
        const offset = new Long(fileBlock.offset, 0);
        const bodyLength = new Long(fileBlock.bodyLength, 0);
        return _Block.createBlock(b, offset, metaDataLength, bodyLength);
      }
      constructor(metaDataLength, bodyLength, offset) {
        this.metaDataLength = metaDataLength;
        this.offset = typeof offset === "number" ? offset : offset.low;
        this.bodyLength = typeof bodyLength === "number" ? bodyLength : bodyLength.low;
      }
    };
    exports.FileBlock = FileBlock;
  }
});

// node_modules/apache-arrow/io/stream.js
var require_stream = __commonJS({
  "node_modules/apache-arrow/io/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var adapters_1 = require_adapters();
    var utf8_1 = require_utf8();
    var interfaces_1 = require_interfaces();
    var buffer_1 = require_buffer();
    var compat_1 = require_compat();
    var AsyncByteQueue2 = class extends interfaces_1.AsyncQueue {
      write(value) {
        if ((value = buffer_1.toUint8Array(value)).byteLength > 0) {
          return super.write(value);
        }
      }
      toString(sync = false) {
        return sync ? utf8_1.decodeUtf8(this.toUint8Array(true)) : this.toUint8Array(false).then(utf8_1.decodeUtf8);
      }
      toUint8Array(sync = false) {
        return sync ? buffer_1.joinUint8Arrays(this._values)[0] : (async () => {
          let buffers = [], byteLength = 0;
          for await (const chunk of this) {
            buffers.push(chunk);
            byteLength += chunk.byteLength;
          }
          return buffer_1.joinUint8Arrays(buffers, byteLength)[0];
        })();
      }
    };
    exports.AsyncByteQueue = AsyncByteQueue2;
    var ByteStream2 = class {
      constructor(source) {
        if (source) {
          this.source = new ByteStreamSource(adapters_1.default.fromIterable(source));
        }
      }
      [Symbol.iterator]() {
        return this;
      }
      next(value) {
        return this.source.next(value);
      }
      throw(value) {
        return this.source.throw(value);
      }
      return(value) {
        return this.source.return(value);
      }
      peek(size) {
        return this.source.peek(size);
      }
      read(size) {
        return this.source.read(size);
      }
    };
    exports.ByteStream = ByteStream2;
    var AsyncByteStream2 = class {
      constructor(source) {
        if (source instanceof AsyncByteStream2) {
          this.source = source.source;
        } else if (source instanceof AsyncByteQueue2) {
          this.source = new AsyncByteStreamSource(adapters_1.default.fromAsyncIterable(source));
        } else if (compat_1.isReadableNodeStream(source)) {
          this.source = new AsyncByteStreamSource(adapters_1.default.fromNodeStream(source));
        } else if (compat_1.isReadableDOMStream(source)) {
          this.source = new AsyncByteStreamSource(adapters_1.default.fromDOMStream(source));
        } else if (compat_1.isFetchResponse(source)) {
          this.source = new AsyncByteStreamSource(adapters_1.default.fromDOMStream(source.body));
        } else if (compat_1.isIterable(source)) {
          this.source = new AsyncByteStreamSource(adapters_1.default.fromIterable(source));
        } else if (compat_1.isPromise(source)) {
          this.source = new AsyncByteStreamSource(adapters_1.default.fromAsyncIterable(source));
        } else if (compat_1.isAsyncIterable(source)) {
          this.source = new AsyncByteStreamSource(adapters_1.default.fromAsyncIterable(source));
        }
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      next(value) {
        return this.source.next(value);
      }
      throw(value) {
        return this.source.throw(value);
      }
      return(value) {
        return this.source.return(value);
      }
      get closed() {
        return this.source.closed;
      }
      cancel(reason) {
        return this.source.cancel(reason);
      }
      peek(size) {
        return this.source.peek(size);
      }
      read(size) {
        return this.source.read(size);
      }
    };
    exports.AsyncByteStream = AsyncByteStream2;
    var ByteStreamSource = class {
      constructor(source) {
        this.source = source;
      }
      cancel(reason) {
        this.return(reason);
      }
      peek(size) {
        return this.next(size, "peek").value;
      }
      read(size) {
        return this.next(size, "read").value;
      }
      next(size, cmd = "read") {
        return this.source.next({ cmd, size });
      }
      throw(value) {
        return Object.create(this.source.throw && this.source.throw(value) || interfaces_1.ITERATOR_DONE);
      }
      return(value) {
        return Object.create(this.source.return && this.source.return(value) || interfaces_1.ITERATOR_DONE);
      }
    };
    var AsyncByteStreamSource = class {
      constructor(source) {
        this.source = source;
        this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
      }
      async cancel(reason) {
        await this.return(reason);
      }
      get closed() {
        return this._closedPromise;
      }
      async read(size) {
        return (await this.next(size, "read")).value;
      }
      async peek(size) {
        return (await this.next(size, "peek")).value;
      }
      async next(size, cmd = "read") {
        return await this.source.next({ cmd, size });
      }
      async throw(value) {
        const result = this.source.throw && await this.source.throw(value) || interfaces_1.ITERATOR_DONE;
        this._closedPromiseResolve && this._closedPromiseResolve();
        this._closedPromiseResolve = void 0;
        return Object.create(result);
      }
      async return(value) {
        const result = this.source.return && await this.source.return(value) || interfaces_1.ITERATOR_DONE;
        this._closedPromiseResolve && this._closedPromiseResolve();
        this._closedPromiseResolve = void 0;
        return Object.create(result);
      }
    };
  }
});

// node_modules/apache-arrow/io/file.js
var require_file2 = __commonJS({
  "node_modules/apache-arrow/io/file.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require_stream();
    var buffer_1 = require_buffer();
    var RandomAccessFile = class extends stream_1.ByteStream {
      constructor(buffer, byteLength) {
        super();
        this.position = 0;
        this.buffer = buffer_1.toUint8Array(buffer);
        this.size = typeof byteLength === "undefined" ? this.buffer.byteLength : byteLength;
      }
      readInt32(position) {
        const { buffer, byteOffset } = this.readAt(position, 4);
        return new DataView(buffer, byteOffset).getInt32(0, true);
      }
      seek(position) {
        this.position = Math.min(position, this.size);
        return position < this.size;
      }
      read(nBytes) {
        const { buffer, size, position } = this;
        if (buffer && position < size) {
          if (typeof nBytes !== "number") {
            nBytes = Infinity;
          }
          this.position = Math.min(size, position + Math.min(size - position, nBytes));
          return buffer.subarray(position, this.position);
        }
        return null;
      }
      readAt(position, nBytes) {
        const buf = this.buffer;
        const end = Math.min(this.size, position + nBytes);
        return buf ? buf.subarray(position, end) : new Uint8Array(nBytes);
      }
      close() {
        this.buffer && (this.buffer = null);
      }
      throw(value) {
        this.close();
        return { done: true, value };
      }
      return(value) {
        this.close();
        return { done: true, value };
      }
    };
    exports.RandomAccessFile = RandomAccessFile;
    var AsyncRandomAccessFile = class extends stream_1.AsyncByteStream {
      constructor(file, byteLength) {
        super();
        this.position = 0;
        this._handle = file;
        if (typeof byteLength === "number") {
          this.size = byteLength;
        } else {
          this._pending = (async () => {
            this.size = (await file.stat()).size;
            delete this._pending;
          })();
        }
      }
      async readInt32(position) {
        const { buffer, byteOffset } = await this.readAt(position, 4);
        return new DataView(buffer, byteOffset).getInt32(0, true);
      }
      async seek(position) {
        this._pending && await this._pending;
        this.position = Math.min(position, this.size);
        return position < this.size;
      }
      async read(nBytes) {
        this._pending && await this._pending;
        const { _handle: file, size, position } = this;
        if (file && position < size) {
          if (typeof nBytes !== "number") {
            nBytes = Infinity;
          }
          let pos = position, offset = 0, bytesRead = 0;
          let end = Math.min(size, pos + Math.min(size - pos, nBytes));
          let buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));
          while ((pos += bytesRead) < end && (offset += bytesRead) < buffer.byteLength) {
            ({ bytesRead } = await file.read(buffer, offset, buffer.byteLength - offset, pos));
          }
          return buffer;
        }
        return null;
      }
      async readAt(position, nBytes) {
        this._pending && await this._pending;
        const { _handle: file, size } = this;
        if (file && position + nBytes < size) {
          const end = Math.min(size, position + nBytes);
          const buffer = new Uint8Array(end - position);
          return (await file.read(buffer, 0, nBytes, position)).buffer;
        }
        return new Uint8Array(nBytes);
      }
      async close() {
        const f = this._handle;
        this._handle = null;
        f && await f.close();
      }
      async throw(value) {
        await this.close();
        return { done: true, value };
      }
      async return(value) {
        await this.close();
        return { done: true, value };
      }
    };
    exports.AsyncRandomAccessFile = AsyncRandomAccessFile;
  }
});

// node_modules/apache-arrow/util/int.js
var require_int2 = __commonJS({
  "node_modules/apache-arrow/util/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var carryBit16 = 1 << 16;
    function intAsHex(value) {
      if (value < 0) {
        value = 4294967295 + value + 1;
      }
      return `0x${value.toString(16)}`;
    }
    var kInt32DecimalDigits = 8;
    var kPowersOfTen = [
      1,
      10,
      100,
      1e3,
      1e4,
      1e5,
      1e6,
      1e7,
      1e8
    ];
    var BaseInt64 = class {
      constructor(buffer) {
        this.buffer = buffer;
      }
      high() {
        return this.buffer[1];
      }
      low() {
        return this.buffer[0];
      }
      _times(other) {
        const L = new Uint32Array([
          this.buffer[1] >>> 16,
          this.buffer[1] & 65535,
          this.buffer[0] >>> 16,
          this.buffer[0] & 65535
        ]);
        const R = new Uint32Array([
          other.buffer[1] >>> 16,
          other.buffer[1] & 65535,
          other.buffer[0] >>> 16,
          other.buffer[0] & 65535
        ]);
        let product = L[3] * R[3];
        this.buffer[0] = product & 65535;
        let sum = product >>> 16;
        product = L[2] * R[3];
        sum += product;
        product = L[3] * R[2] >>> 0;
        sum += product;
        this.buffer[0] += sum << 16;
        this.buffer[1] = sum >>> 0 < product ? carryBit16 : 0;
        this.buffer[1] += sum >>> 16;
        this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];
        this.buffer[1] += L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0] << 16;
        return this;
      }
      _plus(other) {
        const sum = this.buffer[0] + other.buffer[0] >>> 0;
        this.buffer[1] += other.buffer[1];
        if (sum < this.buffer[0] >>> 0) {
          ++this.buffer[1];
        }
        this.buffer[0] = sum;
      }
      lessThan(other) {
        return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];
      }
      equals(other) {
        return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];
      }
      greaterThan(other) {
        return other.lessThan(this);
      }
      hex() {
        return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
      }
    };
    exports.BaseInt64 = BaseInt64;
    var Uint642 = class extends BaseInt64 {
      times(other) {
        this._times(other);
        return this;
      }
      plus(other) {
        this._plus(other);
        return this;
      }
      static from(val, out_buffer = new Uint32Array(2)) {
        return Uint642.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
      }
      static fromNumber(num, out_buffer = new Uint32Array(2)) {
        return Uint642.fromString(num.toString(), out_buffer);
      }
      static fromString(str, out_buffer = new Uint32Array(2)) {
        const length = str.length;
        let out = new Uint642(out_buffer);
        for (let posn = 0; posn < length; ) {
          const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
          const chunk = new Uint642(new Uint32Array([parseInt(str.substr(posn, group), 10), 0]));
          const multiple = new Uint642(new Uint32Array([kPowersOfTen[group], 0]));
          out.times(multiple);
          out.plus(chunk);
          posn += group;
        }
        return out;
      }
      static convertArray(values) {
        const data = new Uint32Array(values.length * 2);
        for (let i = -1, n = values.length; ++i < n; ) {
          Uint642.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
        }
        return data;
      }
      static multiply(left, right) {
        let rtrn = new Uint642(new Uint32Array(left.buffer));
        return rtrn.times(right);
      }
      static add(left, right) {
        let rtrn = new Uint642(new Uint32Array(left.buffer));
        return rtrn.plus(right);
      }
    };
    exports.Uint64 = Uint642;
    var Int642 = class extends BaseInt64 {
      negate() {
        this.buffer[0] = ~this.buffer[0] + 1;
        this.buffer[1] = ~this.buffer[1];
        if (this.buffer[0] == 0) {
          ++this.buffer[1];
        }
        return this;
      }
      times(other) {
        this._times(other);
        return this;
      }
      plus(other) {
        this._plus(other);
        return this;
      }
      lessThan(other) {
        const this_high = this.buffer[1] << 0;
        const other_high = other.buffer[1] << 0;
        return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];
      }
      static from(val, out_buffer = new Uint32Array(2)) {
        return Int642.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
      }
      static fromNumber(num, out_buffer = new Uint32Array(2)) {
        return Int642.fromString(num.toString(), out_buffer);
      }
      static fromString(str, out_buffer = new Uint32Array(2)) {
        const negate = str.startsWith("-");
        const length = str.length;
        let out = new Int642(out_buffer);
        for (let posn = negate ? 1 : 0; posn < length; ) {
          const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
          const chunk = new Int642(new Uint32Array([parseInt(str.substr(posn, group), 10), 0]));
          const multiple = new Int642(new Uint32Array([kPowersOfTen[group], 0]));
          out.times(multiple);
          out.plus(chunk);
          posn += group;
        }
        return negate ? out.negate() : out;
      }
      static convertArray(values) {
        const data = new Uint32Array(values.length * 2);
        for (let i = -1, n = values.length; ++i < n; ) {
          Int642.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
        }
        return data;
      }
      static multiply(left, right) {
        let rtrn = new Int642(new Uint32Array(left.buffer));
        return rtrn.times(right);
      }
      static add(left, right) {
        let rtrn = new Int642(new Uint32Array(left.buffer));
        return rtrn.plus(right);
      }
    };
    exports.Int64 = Int642;
    var Int128 = class {
      constructor(buffer) {
        this.buffer = buffer;
      }
      high() {
        return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
      }
      low() {
        return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
      }
      negate() {
        this.buffer[0] = ~this.buffer[0] + 1;
        this.buffer[1] = ~this.buffer[1];
        this.buffer[2] = ~this.buffer[2];
        this.buffer[3] = ~this.buffer[3];
        if (this.buffer[0] == 0) {
          ++this.buffer[1];
        }
        if (this.buffer[1] == 0) {
          ++this.buffer[2];
        }
        if (this.buffer[2] == 0) {
          ++this.buffer[3];
        }
        return this;
      }
      times(other) {
        const L0 = new Uint642(new Uint32Array([this.buffer[3], 0]));
        const L1 = new Uint642(new Uint32Array([this.buffer[2], 0]));
        const L2 = new Uint642(new Uint32Array([this.buffer[1], 0]));
        const L3 = new Uint642(new Uint32Array([this.buffer[0], 0]));
        const R0 = new Uint642(new Uint32Array([other.buffer[3], 0]));
        const R1 = new Uint642(new Uint32Array([other.buffer[2], 0]));
        const R2 = new Uint642(new Uint32Array([other.buffer[1], 0]));
        const R3 = new Uint642(new Uint32Array([other.buffer[0], 0]));
        let product = Uint642.multiply(L3, R3);
        this.buffer[0] = product.low();
        let sum = new Uint642(new Uint32Array([product.high(), 0]));
        product = Uint642.multiply(L2, R3);
        sum.plus(product);
        product = Uint642.multiply(L3, R2);
        sum.plus(product);
        this.buffer[1] = sum.low();
        this.buffer[3] = sum.lessThan(product) ? 1 : 0;
        this.buffer[2] = sum.high();
        let high = new Uint642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
        high.plus(Uint642.multiply(L1, R3)).plus(Uint642.multiply(L2, R2)).plus(Uint642.multiply(L3, R1));
        this.buffer[3] += Uint642.multiply(L0, R3).plus(Uint642.multiply(L1, R2)).plus(Uint642.multiply(L2, R1)).plus(Uint642.multiply(L3, R0)).low();
        return this;
      }
      plus(other) {
        let sums = new Uint32Array(4);
        sums[3] = this.buffer[3] + other.buffer[3] >>> 0;
        sums[2] = this.buffer[2] + other.buffer[2] >>> 0;
        sums[1] = this.buffer[1] + other.buffer[1] >>> 0;
        sums[0] = this.buffer[0] + other.buffer[0] >>> 0;
        if (sums[0] < this.buffer[0] >>> 0) {
          ++sums[1];
        }
        if (sums[1] < this.buffer[1] >>> 0) {
          ++sums[2];
        }
        if (sums[2] < this.buffer[2] >>> 0) {
          ++sums[3];
        }
        this.buffer[3] = sums[3];
        this.buffer[2] = sums[2];
        this.buffer[1] = sums[1];
        this.buffer[0] = sums[0];
        return this;
      }
      hex() {
        return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
      }
      static multiply(left, right) {
        let rtrn = new Int128(new Uint32Array(left.buffer));
        return rtrn.times(right);
      }
      static add(left, right) {
        let rtrn = new Int128(new Uint32Array(left.buffer));
        return rtrn.plus(right);
      }
      static from(val, out_buffer = new Uint32Array(4)) {
        return Int128.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
      }
      static fromNumber(num, out_buffer = new Uint32Array(4)) {
        return Int128.fromString(num.toString(), out_buffer);
      }
      static fromString(str, out_buffer = new Uint32Array(4)) {
        const negate = str.startsWith("-");
        const length = str.length;
        let out = new Int128(out_buffer);
        for (let posn = negate ? 1 : 0; posn < length; ) {
          const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
          const chunk = new Int128(new Uint32Array([parseInt(str.substr(posn, group), 10), 0, 0, 0]));
          const multiple = new Int128(new Uint32Array([kPowersOfTen[group], 0, 0, 0]));
          out.times(multiple);
          out.plus(chunk);
          posn += group;
        }
        return negate ? out.negate() : out;
      }
      static convertArray(values) {
        const data = new Uint32Array(values.length * 4);
        for (let i = -1, n = values.length; ++i < n; ) {
          Int128.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));
        }
        return data;
      }
    };
    exports.Int128 = Int128;
  }
});

// node_modules/apache-arrow/visitor/vectorloader.js
var require_vectorloader = __commonJS({
  "node_modules/apache-arrow/visitor/vectorloader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_1 = require_data();
    var schema_1 = require_schema();
    var type_1 = require_type();
    var visitor_1 = require_visitor();
    var bit_1 = require_bit();
    var utf8_1 = require_utf8();
    var int_1 = require_int2();
    var enum_1 = require_enum();
    var buffer_1 = require_buffer();
    var VectorLoader = class extends visitor_1.Visitor {
      constructor(bytes, nodes, buffers, dictionaries) {
        super();
        this.nodesIndex = -1;
        this.buffersIndex = -1;
        this.bytes = bytes;
        this.nodes = nodes;
        this.buffers = buffers;
        this.dictionaries = dictionaries;
      }
      visit(node) {
        return super.visit(node instanceof schema_1.Field ? node.type : node);
      }
      visitNull(type, { length } = this.nextFieldNode()) {
        return data_1.Data.Null(type, 0, length);
      }
      visitBool(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Bool(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitInt(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Int(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitFloat(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Float(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitUtf8(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Utf8(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readOffsets(type), this.readData(type));
      }
      visitBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Binary(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readOffsets(type), this.readData(type));
      }
      visitFixedSizeBinary(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.FixedSizeBinary(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitDate(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Date(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitTimestamp(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Timestamp(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitTime(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Time(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitDecimal(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Decimal(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitList(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.List(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readOffsets(type), this.visit(type.children[0]));
      }
      visitStruct(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Struct(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.visitMany(type.children));
      }
      visitUnion(type) {
        return type.mode === enum_1.UnionMode.Sparse ? this.visitSparseUnion(type) : this.visitDenseUnion(type);
      }
      visitDenseUnion(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Union(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readTypeIds(type), this.readOffsets(type), this.visitMany(type.children));
      }
      visitSparseUnion(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Union(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readTypeIds(type), this.visitMany(type.children));
      }
      visitDictionary(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Dictionary(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type.indices), this.readDictionary(type));
      }
      visitInterval(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Interval(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readData(type));
      }
      visitFixedSizeList(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.FixedSizeList(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.visit(type.children[0]));
      }
      visitMap(type, { length, nullCount } = this.nextFieldNode()) {
        return data_1.Data.Map(type, 0, length, nullCount, this.readNullBitmap(type, nullCount), this.readOffsets(type), this.visit(type.children[0]));
      }
      nextFieldNode() {
        return this.nodes[++this.nodesIndex];
      }
      nextBufferRange() {
        return this.buffers[++this.buffersIndex];
      }
      readNullBitmap(type, nullCount, buffer = this.nextBufferRange()) {
        return nullCount > 0 && this.readData(type, buffer) || new Uint8Array(0);
      }
      readOffsets(type, buffer) {
        return this.readData(type, buffer);
      }
      readTypeIds(type, buffer) {
        return this.readData(type, buffer);
      }
      readData(_type, { length, offset } = this.nextBufferRange()) {
        return this.bytes.subarray(offset, offset + length);
      }
      readDictionary(type) {
        return this.dictionaries.get(type.id);
      }
    };
    exports.VectorLoader = VectorLoader;
    var JSONVectorLoader = class extends VectorLoader {
      constructor(sources, nodes, buffers, dictionaries) {
        super(new Uint8Array(0), nodes, buffers, dictionaries);
        this.sources = sources;
      }
      readNullBitmap(_type, nullCount, { offset } = this.nextBufferRange()) {
        return nullCount <= 0 ? new Uint8Array(0) : bit_1.packBools(this.sources[offset]);
      }
      readOffsets(_type, { offset } = this.nextBufferRange()) {
        return buffer_1.toArrayBufferView(Uint8Array, buffer_1.toArrayBufferView(Int32Array, this.sources[offset]));
      }
      readTypeIds(type, { offset } = this.nextBufferRange()) {
        return buffer_1.toArrayBufferView(Uint8Array, buffer_1.toArrayBufferView(type.ArrayType, this.sources[offset]));
      }
      readData(type, { offset } = this.nextBufferRange()) {
        const { sources } = this;
        if (type_1.DataType.isTimestamp(type)) {
          return buffer_1.toArrayBufferView(Uint8Array, int_1.Int64.convertArray(sources[offset]));
        } else if ((type_1.DataType.isInt(type) || type_1.DataType.isTime(type)) && type.bitWidth === 64) {
          return buffer_1.toArrayBufferView(Uint8Array, int_1.Int64.convertArray(sources[offset]));
        } else if (type_1.DataType.isDate(type) && type.unit === enum_1.DateUnit.MILLISECOND) {
          return buffer_1.toArrayBufferView(Uint8Array, int_1.Int64.convertArray(sources[offset]));
        } else if (type_1.DataType.isDecimal(type)) {
          return buffer_1.toArrayBufferView(Uint8Array, int_1.Int128.convertArray(sources[offset]));
        } else if (type_1.DataType.isBinary(type) || type_1.DataType.isFixedSizeBinary(type)) {
          return binaryDataFromJSON(sources[offset]);
        } else if (type_1.DataType.isBool(type)) {
          return bit_1.packBools(sources[offset]);
        } else if (type_1.DataType.isUtf8(type)) {
          return utf8_1.encodeUtf8(sources[offset].join(""));
        }
        return buffer_1.toArrayBufferView(Uint8Array, buffer_1.toArrayBufferView(type.ArrayType, sources[offset].map((x) => +x)));
      }
    };
    exports.JSONVectorLoader = JSONVectorLoader;
    function binaryDataFromJSON(values) {
      const joined = values.join("");
      const data = new Uint8Array(joined.length / 2);
      for (let i = 0; i < joined.length; i += 2) {
        data[i >> 1] = parseInt(joined.substr(i, 2), 16);
      }
      return data;
    }
  }
});

// node_modules/apache-arrow/visitor/typeassembler.js
var require_typeassembler = __commonJS({
  "node_modules/apache-arrow/visitor/typeassembler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var flatbuffers_1 = (init_flatbuffers(), __toCommonJS(flatbuffers_exports));
    var Long = flatbuffers_1.flatbuffers.Long;
    var Schema_ = require_Schema();
    var visitor_1 = require_visitor();
    var Null2 = Schema_.org.apache.arrow.flatbuf.Null;
    var Int2 = Schema_.org.apache.arrow.flatbuf.Int;
    var FloatingPoint = Schema_.org.apache.arrow.flatbuf.FloatingPoint;
    var Binary2 = Schema_.org.apache.arrow.flatbuf.Binary;
    var Bool2 = Schema_.org.apache.arrow.flatbuf.Bool;
    var Utf82 = Schema_.org.apache.arrow.flatbuf.Utf8;
    var Decimal2 = Schema_.org.apache.arrow.flatbuf.Decimal;
    var Date2 = Schema_.org.apache.arrow.flatbuf.Date;
    var Time2 = Schema_.org.apache.arrow.flatbuf.Time;
    var Timestamp2 = Schema_.org.apache.arrow.flatbuf.Timestamp;
    var Interval2 = Schema_.org.apache.arrow.flatbuf.Interval;
    var List2 = Schema_.org.apache.arrow.flatbuf.List;
    var Struct2 = Schema_.org.apache.arrow.flatbuf.Struct_;
    var Union2 = Schema_.org.apache.arrow.flatbuf.Union;
    var DictionaryEncoding = Schema_.org.apache.arrow.flatbuf.DictionaryEncoding;
    var FixedSizeBinary2 = Schema_.org.apache.arrow.flatbuf.FixedSizeBinary;
    var FixedSizeList2 = Schema_.org.apache.arrow.flatbuf.FixedSizeList;
    var Map_2 = Schema_.org.apache.arrow.flatbuf.Map;
    var TypeAssembler = class extends visitor_1.Visitor {
      visit(node, builder) {
        return node == null || builder == null ? void 0 : super.visit(node, builder);
      }
      visitNull(_node, b) {
        Null2.startNull(b);
        return Null2.endNull(b);
      }
      visitInt(node, b) {
        Int2.startInt(b);
        Int2.addBitWidth(b, node.bitWidth);
        Int2.addIsSigned(b, node.isSigned);
        return Int2.endInt(b);
      }
      visitFloat(node, b) {
        FloatingPoint.startFloatingPoint(b);
        FloatingPoint.addPrecision(b, node.precision);
        return FloatingPoint.endFloatingPoint(b);
      }
      visitBinary(_node, b) {
        Binary2.startBinary(b);
        return Binary2.endBinary(b);
      }
      visitBool(_node, b) {
        Bool2.startBool(b);
        return Bool2.endBool(b);
      }
      visitUtf8(_node, b) {
        Utf82.startUtf8(b);
        return Utf82.endUtf8(b);
      }
      visitDecimal(node, b) {
        Decimal2.startDecimal(b);
        Decimal2.addScale(b, node.scale);
        Decimal2.addPrecision(b, node.precision);
        return Decimal2.endDecimal(b);
      }
      visitDate(node, b) {
        Date2.startDate(b);
        Date2.addUnit(b, node.unit);
        return Date2.endDate(b);
      }
      visitTime(node, b) {
        Time2.startTime(b);
        Time2.addUnit(b, node.unit);
        Time2.addBitWidth(b, node.bitWidth);
        return Time2.endTime(b);
      }
      visitTimestamp(node, b) {
        const timezone = node.timezone && b.createString(node.timezone) || void 0;
        Timestamp2.startTimestamp(b);
        Timestamp2.addUnit(b, node.unit);
        if (timezone !== void 0) {
          Timestamp2.addTimezone(b, timezone);
        }
        return Timestamp2.endTimestamp(b);
      }
      visitInterval(node, b) {
        Interval2.startInterval(b);
        Interval2.addUnit(b, node.unit);
        return Interval2.endInterval(b);
      }
      visitList(_node, b) {
        List2.startList(b);
        return List2.endList(b);
      }
      visitStruct(_node, b) {
        Struct2.startStruct_(b);
        return Struct2.endStruct_(b);
      }
      visitUnion(node, b) {
        Union2.startTypeIdsVector(b, node.typeIds.length);
        const typeIds = Union2.createTypeIdsVector(b, node.typeIds);
        Union2.startUnion(b);
        Union2.addMode(b, node.mode);
        Union2.addTypeIds(b, typeIds);
        return Union2.endUnion(b);
      }
      visitDictionary(node, b) {
        const indexType = this.visit(node.indices, b);
        DictionaryEncoding.startDictionaryEncoding(b);
        DictionaryEncoding.addId(b, new Long(node.id, 0));
        DictionaryEncoding.addIsOrdered(b, node.isOrdered);
        if (indexType !== void 0) {
          DictionaryEncoding.addIndexType(b, indexType);
        }
        return DictionaryEncoding.endDictionaryEncoding(b);
      }
      visitFixedSizeBinary(node, b) {
        FixedSizeBinary2.startFixedSizeBinary(b);
        FixedSizeBinary2.addByteWidth(b, node.byteWidth);
        return FixedSizeBinary2.endFixedSizeBinary(b);
      }
      visitFixedSizeList(node, b) {
        FixedSizeList2.startFixedSizeList(b);
        FixedSizeList2.addListSize(b, node.listSize);
        return FixedSizeList2.endFixedSizeList(b);
      }
      visitMap(node, b) {
        Map_2.startMap(b);
        Map_2.addKeysSorted(b, node.keysSorted);
        return Map_2.endMap(b);
      }
    };
    exports.TypeAssembler = TypeAssembler;
    exports.instance = new TypeAssembler();
  }
});

// node_modules/apache-arrow/ipc/metadata/json.js
var require_json = __commonJS({
  "node_modules/apache-arrow/ipc/metadata/json.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var schema_1 = require_schema();
    var type_1 = require_type();
    var message_1 = require_message();
    var enum_1 = require_enum();
    function schemaFromJSON(_schema, dictionaries = /* @__PURE__ */ new Map()) {
      return new schema_1.Schema(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema["customMetadata"]), dictionaries);
    }
    exports.schemaFromJSON = schemaFromJSON;
    function recordBatchFromJSON(b) {
      return new message_1.RecordBatch(b["count"], fieldNodesFromJSON(b["columns"]), buffersFromJSON(b["columns"]));
    }
    exports.recordBatchFromJSON = recordBatchFromJSON;
    function dictionaryBatchFromJSON(b) {
      return new message_1.DictionaryBatch(recordBatchFromJSON(b["data"]), b["id"], b["isDelta"]);
    }
    exports.dictionaryBatchFromJSON = dictionaryBatchFromJSON;
    function schemaFieldsFromJSON(_schema, dictionaries) {
      return (_schema["fields"] || []).filter(Boolean).map((f) => schema_1.Field.fromJSON(f, dictionaries));
    }
    function fieldChildrenFromJSON(_field, dictionaries) {
      return (_field["children"] || []).filter(Boolean).map((f) => schema_1.Field.fromJSON(f, dictionaries));
    }
    function fieldNodesFromJSON(xs) {
      return (xs || []).reduce((fieldNodes, column) => [
        ...fieldNodes,
        new message_1.FieldNode(column["count"], nullCountFromJSON(column["VALIDITY"])),
        ...fieldNodesFromJSON(column["children"])
      ], []);
    }
    function buffersFromJSON(xs, buffers = []) {
      for (let i = -1, n = (xs || []).length; ++i < n; ) {
        const column = xs[i];
        column["VALIDITY"] && buffers.push(new message_1.BufferRegion(buffers.length, column["VALIDITY"].length));
        column["TYPE"] && buffers.push(new message_1.BufferRegion(buffers.length, column["TYPE"].length));
        column["OFFSET"] && buffers.push(new message_1.BufferRegion(buffers.length, column["OFFSET"].length));
        column["DATA"] && buffers.push(new message_1.BufferRegion(buffers.length, column["DATA"].length));
        buffers = buffersFromJSON(column["children"], buffers);
      }
      return buffers;
    }
    function nullCountFromJSON(validity) {
      return (validity || []).reduce((sum, val) => sum + +(val === 0), 0);
    }
    function fieldFromJSON(_field, dictionaries) {
      let id;
      let keys;
      let field;
      let dictMeta;
      let type;
      let dictType;
      if (!dictionaries || !(dictMeta = _field["dictionary"])) {
        type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
        field = new schema_1.Field(_field["name"], type, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
      } else if (!dictionaries.has(id = dictMeta["id"])) {
        keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new type_1.Int32();
        dictionaries.set(id, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
        dictType = new type_1.Dictionary(type, keys, id, dictMeta["isOrdered"]);
        field = new schema_1.Field(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
      } else {
        keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new type_1.Int32();
        dictType = new type_1.Dictionary(dictionaries.get(id), keys, id, dictMeta["isOrdered"]);
        field = new schema_1.Field(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
      }
      return field || null;
    }
    exports.fieldFromJSON = fieldFromJSON;
    function customMetadataFromJSON(_metadata) {
      return new Map(Object.entries(_metadata || {}));
    }
    function indexTypeFromJSON(_type) {
      return new type_1.Int(_type["isSigned"], _type["bitWidth"]);
    }
    function typeFromJSON(f, children) {
      const typeId = f["type"]["name"];
      switch (typeId) {
        case "NONE":
          return new type_1.Null();
        case "null":
          return new type_1.Null();
        case "binary":
          return new type_1.Binary();
        case "utf8":
          return new type_1.Utf8();
        case "bool":
          return new type_1.Bool();
        case "list":
          return new type_1.List((children || [])[0]);
        case "struct":
          return new type_1.Struct(children || []);
        case "struct_":
          return new type_1.Struct(children || []);
      }
      switch (typeId) {
        case "int": {
          const t = f["type"];
          return new type_1.Int(t["isSigned"], t["bitWidth"]);
        }
        case "floatingpoint": {
          const t = f["type"];
          return new type_1.Float(enum_1.Precision[t["precision"]]);
        }
        case "decimal": {
          const t = f["type"];
          return new type_1.Decimal(t["scale"], t["precision"]);
        }
        case "date": {
          const t = f["type"];
          return new type_1.Date_(enum_1.DateUnit[t["unit"]]);
        }
        case "time": {
          const t = f["type"];
          return new type_1.Time(enum_1.TimeUnit[t["unit"]], t["bitWidth"]);
        }
        case "timestamp": {
          const t = f["type"];
          return new type_1.Timestamp(enum_1.TimeUnit[t["unit"]], t["timezone"]);
        }
        case "interval": {
          const t = f["type"];
          return new type_1.Interval(enum_1.IntervalUnit[t["unit"]]);
        }
        case "union": {
          const t = f["type"];
          return new type_1.Union(enum_1.UnionMode[t["mode"]], t["typeIds"] || [], children || []);
        }
        case "fixedsizebinary": {
          const t = f["type"];
          return new type_1.FixedSizeBinary(t["byteWidth"]);
        }
        case "fixedsizelist": {
          const t = f["type"];
          return new type_1.FixedSizeList(t["listSize"], (children || [])[0]);
        }
        case "map": {
          const t = f["type"];
          return new type_1.Map_((children || [])[0], t["keysSorted"]);
        }
      }
      throw new Error(`Unrecognized type: "${typeId}"`);
    }
  }
});

// node_modules/apache-arrow/ipc/metadata/message.js
var require_message = __commonJS({
  "node_modules/apache-arrow/ipc/metadata/message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var flatbuffers_1 = (init_flatbuffers(), __toCommonJS(flatbuffers_exports));
    var Schema_ = require_Schema();
    var Message_ = require_Message();
    var schema_1 = require_schema();
    var buffer_1 = require_buffer();
    var enum_1 = require_enum();
    var typeassembler_1 = require_typeassembler();
    var json_1 = require_json();
    var Long = flatbuffers_1.flatbuffers.Long;
    var Builder3 = flatbuffers_1.flatbuffers.Builder;
    var ByteBuffer = flatbuffers_1.flatbuffers.ByteBuffer;
    var Type2 = Schema_.org.apache.arrow.flatbuf.Type;
    var _Field = Schema_.org.apache.arrow.flatbuf.Field;
    var _Schema = Schema_.org.apache.arrow.flatbuf.Schema;
    var _Buffer = Schema_.org.apache.arrow.flatbuf.Buffer;
    var _Message = Message_.org.apache.arrow.flatbuf.Message;
    var _KeyValue = Schema_.org.apache.arrow.flatbuf.KeyValue;
    var _FieldNode = Message_.org.apache.arrow.flatbuf.FieldNode;
    var _Endianness = Schema_.org.apache.arrow.flatbuf.Endianness;
    var _RecordBatch = Message_.org.apache.arrow.flatbuf.RecordBatch;
    var _DictionaryBatch = Message_.org.apache.arrow.flatbuf.DictionaryBatch;
    var type_1 = require_type();
    var Message2 = class {
      constructor(bodyLength, version, headerType, header) {
        this._version = version;
        this._headerType = headerType;
        this.body = new Uint8Array(0);
        header && (this._createHeader = () => header);
        this._bodyLength = typeof bodyLength === "number" ? bodyLength : bodyLength.low;
      }
      static fromJSON(msg, headerType) {
        const message = new Message2(0, enum_1.MetadataVersion.V4, headerType);
        message._createHeader = messageHeaderFromJSON(msg, headerType);
        return message;
      }
      static decode(buf) {
        buf = new ByteBuffer(buffer_1.toUint8Array(buf));
        const _message = _Message.getRootAsMessage(buf);
        const bodyLength = _message.bodyLength();
        const version = _message.version();
        const headerType = _message.headerType();
        const message = new Message2(bodyLength, version, headerType);
        message._createHeader = decodeMessageHeader(_message, headerType);
        return message;
      }
      static encode(message) {
        let b = new Builder3(), headerOffset = -1;
        if (message.isSchema()) {
          headerOffset = schema_1.Schema.encode(b, message.header());
        } else if (message.isRecordBatch()) {
          headerOffset = RecordBatch2.encode(b, message.header());
        } else if (message.isDictionaryBatch()) {
          headerOffset = DictionaryBatch.encode(b, message.header());
        }
        _Message.startMessage(b);
        _Message.addVersion(b, enum_1.MetadataVersion.V4);
        _Message.addHeader(b, headerOffset);
        _Message.addHeaderType(b, message.headerType);
        _Message.addBodyLength(b, new Long(message.bodyLength, 0));
        _Message.finishMessageBuffer(b, _Message.endMessage(b));
        return b.asUint8Array();
      }
      static from(header, bodyLength = 0) {
        if (header instanceof schema_1.Schema) {
          return new Message2(0, enum_1.MetadataVersion.V4, enum_1.MessageHeader.Schema, header);
        }
        if (header instanceof RecordBatch2) {
          return new Message2(bodyLength, enum_1.MetadataVersion.V4, enum_1.MessageHeader.RecordBatch, header);
        }
        if (header instanceof DictionaryBatch) {
          return new Message2(bodyLength, enum_1.MetadataVersion.V4, enum_1.MessageHeader.DictionaryBatch, header);
        }
        throw new Error(`Unrecognized Message header: ${header}`);
      }
      get type() {
        return this.headerType;
      }
      get version() {
        return this._version;
      }
      get headerType() {
        return this._headerType;
      }
      get bodyLength() {
        return this._bodyLength;
      }
      header() {
        return this._createHeader();
      }
      isSchema() {
        return this.headerType === enum_1.MessageHeader.Schema;
      }
      isRecordBatch() {
        return this.headerType === enum_1.MessageHeader.RecordBatch;
      }
      isDictionaryBatch() {
        return this.headerType === enum_1.MessageHeader.DictionaryBatch;
      }
    };
    exports.Message = Message2;
    var RecordBatch2 = class {
      get nodes() {
        return this._nodes;
      }
      get length() {
        return this._length;
      }
      get buffers() {
        return this._buffers;
      }
      constructor(length, nodes, buffers) {
        this._nodes = nodes;
        this._buffers = buffers;
        this._length = typeof length === "number" ? length : length.low;
      }
    };
    exports.RecordBatch = RecordBatch2;
    var DictionaryBatch = class {
      get id() {
        return this._id;
      }
      get data() {
        return this._data;
      }
      get isDelta() {
        return this._isDelta;
      }
      get length() {
        return this.data.length;
      }
      get nodes() {
        return this.data.nodes;
      }
      get buffers() {
        return this.data.buffers;
      }
      constructor(data, id, isDelta = false) {
        this._data = data;
        this._isDelta = isDelta;
        this._id = typeof id === "number" ? id : id.low;
      }
    };
    exports.DictionaryBatch = DictionaryBatch;
    var BufferRegion = class {
      constructor(offset, length) {
        this.offset = typeof offset === "number" ? offset : offset.low;
        this.length = typeof length === "number" ? length : length.low;
      }
    };
    exports.BufferRegion = BufferRegion;
    var FieldNode = class {
      constructor(length, nullCount) {
        this.length = typeof length === "number" ? length : length.low;
        this.nullCount = typeof nullCount === "number" ? nullCount : nullCount.low;
      }
    };
    exports.FieldNode = FieldNode;
    function messageHeaderFromJSON(message, type) {
      return () => {
        switch (type) {
          case enum_1.MessageHeader.Schema:
            return schema_1.Schema.fromJSON(message);
          case enum_1.MessageHeader.RecordBatch:
            return RecordBatch2.fromJSON(message);
          case enum_1.MessageHeader.DictionaryBatch:
            return DictionaryBatch.fromJSON(message);
        }
        throw new Error(`Unrecognized Message type: { name: ${enum_1.MessageHeader[type]}, type: ${type} }`);
      };
    }
    function decodeMessageHeader(message, type) {
      return () => {
        switch (type) {
          case enum_1.MessageHeader.Schema:
            return schema_1.Schema.decode(message.header(new _Schema()));
          case enum_1.MessageHeader.RecordBatch:
            return RecordBatch2.decode(message.header(new _RecordBatch()), message.version());
          case enum_1.MessageHeader.DictionaryBatch:
            return DictionaryBatch.decode(message.header(new _DictionaryBatch()), message.version());
        }
        throw new Error(`Unrecognized Message type: { name: ${enum_1.MessageHeader[type]}, type: ${type} }`);
      };
    }
    schema_1.Field["encode"] = encodeField;
    schema_1.Field["decode"] = decodeField;
    schema_1.Field["fromJSON"] = json_1.fieldFromJSON;
    schema_1.Schema["encode"] = encodeSchema;
    schema_1.Schema["decode"] = decodeSchema;
    schema_1.Schema["fromJSON"] = json_1.schemaFromJSON;
    RecordBatch2["encode"] = encodeRecordBatch;
    RecordBatch2["decode"] = decodeRecordBatch;
    RecordBatch2["fromJSON"] = json_1.recordBatchFromJSON;
    DictionaryBatch["encode"] = encodeDictionaryBatch;
    DictionaryBatch["decode"] = decodeDictionaryBatch;
    DictionaryBatch["fromJSON"] = json_1.dictionaryBatchFromJSON;
    FieldNode["encode"] = encodeFieldNode;
    FieldNode["decode"] = decodeFieldNode;
    BufferRegion["encode"] = encodeBufferRegion;
    BufferRegion["decode"] = decodeBufferRegion;
    function decodeSchema(_schema, dictionaries = /* @__PURE__ */ new Map()) {
      const fields = decodeSchemaFields(_schema, dictionaries);
      return new schema_1.Schema(fields, decodeCustomMetadata(_schema), dictionaries);
    }
    function decodeRecordBatch(batch, version = enum_1.MetadataVersion.V4) {
      return new RecordBatch2(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version));
    }
    function decodeDictionaryBatch(batch, version = enum_1.MetadataVersion.V4) {
      return new DictionaryBatch(RecordBatch2.decode(batch.data(), version), batch.id(), batch.isDelta());
    }
    function decodeBufferRegion(b) {
      return new BufferRegion(b.offset(), b.length());
    }
    function decodeFieldNode(f) {
      return new FieldNode(f.length(), f.nullCount());
    }
    function decodeFieldNodes(batch) {
      const nodes = [];
      for (let f, i = -1, j = -1, n = batch.nodesLength(); ++i < n; ) {
        if (f = batch.nodes(i)) {
          nodes[++j] = FieldNode.decode(f);
        }
      }
      return nodes;
    }
    function decodeBuffers(batch, version) {
      const bufferRegions = [];
      for (let b, i = -1, j = -1, n = batch.buffersLength(); ++i < n; ) {
        if (b = batch.buffers(i)) {
          if (version < enum_1.MetadataVersion.V4) {
            b.bb_pos += 8 * (i + 1);
          }
          bufferRegions[++j] = BufferRegion.decode(b);
        }
      }
      return bufferRegions;
    }
    function decodeSchemaFields(schema, dictionaries) {
      const fields = [];
      for (let f, i = -1, j = -1, n = schema.fieldsLength(); ++i < n; ) {
        if (f = schema.fields(i)) {
          fields[++j] = schema_1.Field.decode(f, dictionaries);
        }
      }
      return fields;
    }
    function decodeFieldChildren(field, dictionaries) {
      const children = [];
      for (let f, i = -1, j = -1, n = field.childrenLength(); ++i < n; ) {
        if (f = field.children(i)) {
          children[++j] = schema_1.Field.decode(f, dictionaries);
        }
      }
      return children;
    }
    function decodeField(f, dictionaries) {
      let id;
      let field;
      let type;
      let keys;
      let dictType;
      let dictMeta;
      if (!dictionaries || !(dictMeta = f.dictionary())) {
        type = decodeFieldType(f, decodeFieldChildren(f, dictionaries));
        field = new schema_1.Field(f.name(), type, f.nullable(), decodeCustomMetadata(f));
      } else if (!dictionaries.has(id = dictMeta.id().low)) {
        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new type_1.Int32();
        dictionaries.set(id, type = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));
        dictType = new type_1.Dictionary(type, keys, id, dictMeta.isOrdered());
        field = new schema_1.Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
      } else {
        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new type_1.Int32();
        dictType = new type_1.Dictionary(dictionaries.get(id), keys, id, dictMeta.isOrdered());
        field = new schema_1.Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
      }
      return field || null;
    }
    function decodeCustomMetadata(parent) {
      const data = /* @__PURE__ */ new Map();
      if (parent) {
        for (let entry, key, i = -1, n = parent.customMetadataLength() | 0; ++i < n; ) {
          if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {
            data.set(key, entry.value());
          }
        }
      }
      return data;
    }
    function decodeIndexType(_type) {
      return new type_1.Int(_type.isSigned(), _type.bitWidth());
    }
    function decodeFieldType(f, children) {
      const typeId = f.typeType();
      switch (typeId) {
        case Type2.NONE:
          return new type_1.Null();
        case Type2.Null:
          return new type_1.Null();
        case Type2.Binary:
          return new type_1.Binary();
        case Type2.Utf8:
          return new type_1.Utf8();
        case Type2.Bool:
          return new type_1.Bool();
        case Type2.List:
          return new type_1.List((children || [])[0]);
        case Type2.Struct_:
          return new type_1.Struct(children || []);
      }
      switch (typeId) {
        case Type2.Int: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.Int());
          return new type_1.Int(t.isSigned(), t.bitWidth());
        }
        case Type2.FloatingPoint: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.FloatingPoint());
          return new type_1.Float(t.precision());
        }
        case Type2.Decimal: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.Decimal());
          return new type_1.Decimal(t.scale(), t.precision());
        }
        case Type2.Date: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.Date());
          return new type_1.Date_(t.unit());
        }
        case Type2.Time: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.Time());
          return new type_1.Time(t.unit(), t.bitWidth());
        }
        case Type2.Timestamp: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.Timestamp());
          return new type_1.Timestamp(t.unit(), t.timezone());
        }
        case Type2.Interval: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.Interval());
          return new type_1.Interval(t.unit());
        }
        case Type2.Union: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.Union());
          return new type_1.Union(t.mode(), t.typeIdsArray() || [], children || []);
        }
        case Type2.FixedSizeBinary: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.FixedSizeBinary());
          return new type_1.FixedSizeBinary(t.byteWidth());
        }
        case Type2.FixedSizeList: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.FixedSizeList());
          return new type_1.FixedSizeList(t.listSize(), (children || [])[0]);
        }
        case Type2.Map: {
          const t = f.type(new Schema_.org.apache.arrow.flatbuf.Map());
          return new type_1.Map_((children || [])[0], t.keysSorted());
        }
      }
      throw new Error(`Unrecognized type: "${Type2[typeId]}" (${typeId})`);
    }
    function encodeSchema(b, schema) {
      const fieldOffsets = schema.fields.map((f) => schema_1.Field.encode(b, f));
      _Schema.startFieldsVector(b, fieldOffsets.length);
      const fieldsVectorOffset = _Schema.createFieldsVector(b, fieldOffsets);
      const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : _Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k, v]) => {
        const key = b.createString(`${k}`);
        const val = b.createString(`${v}`);
        _KeyValue.startKeyValue(b);
        _KeyValue.addKey(b, key);
        _KeyValue.addValue(b, val);
        return _KeyValue.endKeyValue(b);
      }));
      _Schema.startSchema(b);
      _Schema.addFields(b, fieldsVectorOffset);
      _Schema.addEndianness(b, platformIsLittleEndian ? _Endianness.Little : _Endianness.Big);
      if (metadataOffset !== -1) {
        _Schema.addCustomMetadata(b, metadataOffset);
      }
      return _Schema.endSchema(b);
    }
    function encodeField(b, field) {
      let nameOffset = -1;
      let typeOffset = -1;
      let dictionaryOffset = -1;
      let type = field.type;
      let typeId = field.typeId;
      if (!type_1.DataType.isDictionary(type)) {
        typeOffset = typeassembler_1.instance.visit(type, b);
      } else {
        typeId = type.dictionary.typeId;
        dictionaryOffset = typeassembler_1.instance.visit(type, b);
        typeOffset = typeassembler_1.instance.visit(type.dictionary, b);
      }
      const childOffsets = (type.children || []).map((f) => schema_1.Field.encode(b, f));
      const childrenVectorOffset = _Field.createChildrenVector(b, childOffsets);
      const metadataOffset = !(field.metadata && field.metadata.size > 0) ? -1 : _Field.createCustomMetadataVector(b, [...field.metadata].map(([k, v]) => {
        const key = b.createString(`${k}`);
        const val = b.createString(`${v}`);
        _KeyValue.startKeyValue(b);
        _KeyValue.addKey(b, key);
        _KeyValue.addValue(b, val);
        return _KeyValue.endKeyValue(b);
      }));
      if (field.name) {
        nameOffset = b.createString(field.name);
      }
      _Field.startField(b);
      _Field.addType(b, typeOffset);
      _Field.addTypeType(b, typeId);
      _Field.addChildren(b, childrenVectorOffset);
      _Field.addNullable(b, !!field.nullable);
      if (nameOffset !== -1) {
        _Field.addName(b, nameOffset);
      }
      if (dictionaryOffset !== -1) {
        _Field.addDictionary(b, dictionaryOffset);
      }
      if (metadataOffset !== -1) {
        _Field.addCustomMetadata(b, metadataOffset);
      }
      return _Field.endField(b);
    }
    function encodeRecordBatch(b, recordBatch) {
      const nodes = recordBatch.nodes || [];
      const buffers = recordBatch.buffers || [];
      _RecordBatch.startNodesVector(b, nodes.length);
      nodes.slice().reverse().forEach((n) => FieldNode.encode(b, n));
      const nodesVectorOffset = b.endVector();
      _RecordBatch.startBuffersVector(b, buffers.length);
      buffers.slice().reverse().forEach((b_) => BufferRegion.encode(b, b_));
      const buffersVectorOffset = b.endVector();
      _RecordBatch.startRecordBatch(b);
      _RecordBatch.addLength(b, new Long(recordBatch.length, 0));
      _RecordBatch.addNodes(b, nodesVectorOffset);
      _RecordBatch.addBuffers(b, buffersVectorOffset);
      return _RecordBatch.endRecordBatch(b);
    }
    function encodeDictionaryBatch(b, dictionaryBatch) {
      const dataOffset = RecordBatch2.encode(b, dictionaryBatch.data);
      _DictionaryBatch.startDictionaryBatch(b);
      _DictionaryBatch.addId(b, new Long(dictionaryBatch.id, 0));
      _DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);
      _DictionaryBatch.addData(b, dataOffset);
      return _DictionaryBatch.endDictionaryBatch(b);
    }
    function encodeFieldNode(b, node) {
      return _FieldNode.createFieldNode(b, new Long(node.length, 0), new Long(node.nullCount, 0));
    }
    function encodeBufferRegion(b, node) {
      return _Buffer.createBuffer(b, new Long(node.offset, 0), new Long(node.length, 0));
    }
    var platformIsLittleEndian = function() {
      const buffer = new ArrayBuffer(2);
      new DataView(buffer).setInt16(0, 256, true);
      return new Int16Array(buffer)[0] === 256;
    }();
  }
});

// node_modules/apache-arrow/ipc/message.js
var require_message2 = __commonJS({
  "node_modules/apache-arrow/ipc/message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var enum_1 = require_enum();
    var flatbuffers_1 = (init_flatbuffers(), __toCommonJS(flatbuffers_exports));
    var ByteBuffer = flatbuffers_1.flatbuffers.ByteBuffer;
    var message_1 = require_message();
    var compat_1 = require_compat();
    var file_1 = require_file2();
    var buffer_1 = require_buffer();
    var stream_1 = require_stream();
    var interfaces_1 = require_interfaces();
    var invalidMessageType = (type) => `Expected ${enum_1.MessageHeader[type]} Message in stream, but was null or length 0.`;
    var nullMessage = (type) => `Header pointer of flatbuffer-encoded ${enum_1.MessageHeader[type]} Message is null or length 0.`;
    var invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
    var invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;
    var MessageReader2 = class {
      constructor(source) {
        this.source = source instanceof stream_1.ByteStream ? source : new stream_1.ByteStream(source);
      }
      [Symbol.iterator]() {
        return this;
      }
      next() {
        let r;
        if ((r = this.readMetadataLength()).done) {
          return interfaces_1.ITERATOR_DONE;
        }
        if (r.value === -1 && (r = this.readMetadataLength()).done) {
          return interfaces_1.ITERATOR_DONE;
        }
        if ((r = this.readMetadata(r.value)).done) {
          return interfaces_1.ITERATOR_DONE;
        }
        return r;
      }
      throw(value) {
        return this.source.throw(value);
      }
      return(value) {
        return this.source.return(value);
      }
      readMessage(type) {
        let r;
        if ((r = this.next()).done) {
          return null;
        }
        if (type != null && r.value.headerType !== type) {
          throw new Error(invalidMessageType(type));
        }
        return r.value;
      }
      readMessageBody(bodyLength) {
        if (bodyLength <= 0) {
          return new Uint8Array(0);
        }
        const buf = buffer_1.toUint8Array(this.source.read(bodyLength));
        if (buf.byteLength < bodyLength) {
          throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
        }
        return buf.byteOffset % 8 === 0 && buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice();
      }
      readSchema(throwIfNull = false) {
        const type = enum_1.MessageHeader.Schema;
        const message = this.readMessage(type);
        const schema = message && message.header();
        if (throwIfNull && !schema) {
          throw new Error(nullMessage(type));
        }
        return schema;
      }
      readMetadataLength() {
        const buf = this.source.read(exports.PADDING);
        const bb = buf && new ByteBuffer(buf);
        const len = bb && bb.readInt32(0) || 0;
        return { done: len === 0, value: len };
      }
      readMetadata(metadataLength) {
        const buf = this.source.read(metadataLength);
        if (!buf) {
          return interfaces_1.ITERATOR_DONE;
        }
        if (buf.byteLength < metadataLength) {
          throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
        }
        return { done: false, value: message_1.Message.decode(buf) };
      }
    };
    exports.MessageReader = MessageReader2;
    var AsyncMessageReader2 = class {
      constructor(source, byteLength) {
        this.source = source instanceof stream_1.AsyncByteStream ? source : compat_1.isFileHandle(source) ? new file_1.AsyncRandomAccessFile(source, byteLength) : new stream_1.AsyncByteStream(source);
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      async next() {
        let r;
        if ((r = await this.readMetadataLength()).done) {
          return interfaces_1.ITERATOR_DONE;
        }
        if (r.value === -1 && (r = await this.readMetadataLength()).done) {
          return interfaces_1.ITERATOR_DONE;
        }
        if ((r = await this.readMetadata(r.value)).done) {
          return interfaces_1.ITERATOR_DONE;
        }
        return r;
      }
      async throw(value) {
        return await this.source.throw(value);
      }
      async return(value) {
        return await this.source.return(value);
      }
      async readMessage(type) {
        let r;
        if ((r = await this.next()).done) {
          return null;
        }
        if (type != null && r.value.headerType !== type) {
          throw new Error(invalidMessageType(type));
        }
        return r.value;
      }
      async readMessageBody(bodyLength) {
        if (bodyLength <= 0) {
          return new Uint8Array(0);
        }
        const buf = buffer_1.toUint8Array(await this.source.read(bodyLength));
        if (buf.byteLength < bodyLength) {
          throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
        }
        return buf.byteOffset % 8 === 0 && buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice();
      }
      async readSchema(throwIfNull = false) {
        const type = enum_1.MessageHeader.Schema;
        const message = await this.readMessage(type);
        const schema = message && message.header();
        if (throwIfNull && !schema) {
          throw new Error(nullMessage(type));
        }
        return schema;
      }
      async readMetadataLength() {
        const buf = await this.source.read(exports.PADDING);
        const bb = buf && new ByteBuffer(buf);
        const len = bb && bb.readInt32(0) || 0;
        return { done: len === 0, value: len };
      }
      async readMetadata(metadataLength) {
        const buf = await this.source.read(metadataLength);
        if (!buf) {
          return interfaces_1.ITERATOR_DONE;
        }
        if (buf.byteLength < metadataLength) {
          throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
        }
        return { done: false, value: message_1.Message.decode(buf) };
      }
    };
    exports.AsyncMessageReader = AsyncMessageReader2;
    var JSONMessageReader2 = class extends MessageReader2 {
      constructor(source) {
        super(new Uint8Array(0));
        this._schema = false;
        this._body = [];
        this._batchIndex = 0;
        this._dictionaryIndex = 0;
        this._json = source instanceof interfaces_1.ArrowJSON ? source : new interfaces_1.ArrowJSON(source);
      }
      next() {
        const { _json } = this;
        if (!this._schema) {
          this._schema = true;
          const message = message_1.Message.fromJSON(_json.schema, enum_1.MessageHeader.Schema);
          return { done: false, value: message };
        }
        if (this._dictionaryIndex < _json.dictionaries.length) {
          const batch = _json.dictionaries[this._dictionaryIndex++];
          this._body = batch["data"]["columns"];
          const message = message_1.Message.fromJSON(batch, enum_1.MessageHeader.DictionaryBatch);
          return { done: false, value: message };
        }
        if (this._batchIndex < _json.batches.length) {
          const batch = _json.batches[this._batchIndex++];
          this._body = batch["columns"];
          const message = message_1.Message.fromJSON(batch, enum_1.MessageHeader.RecordBatch);
          return { done: false, value: message };
        }
        this._body = [];
        return interfaces_1.ITERATOR_DONE;
      }
      readMessageBody(_bodyLength) {
        return flattenDataSources(this._body);
        function flattenDataSources(xs) {
          return (xs || []).reduce((buffers, column) => [
            ...buffers,
            ...column["VALIDITY"] && [column["VALIDITY"]] || [],
            ...column["TYPE"] && [column["TYPE"]] || [],
            ...column["OFFSET"] && [column["OFFSET"]] || [],
            ...column["DATA"] && [column["DATA"]] || [],
            ...flattenDataSources(column["children"])
          ], []);
        }
      }
      readMessage(type) {
        let r;
        if ((r = this.next()).done) {
          return null;
        }
        if (type != null && r.value.headerType !== type) {
          throw new Error(invalidMessageType(type));
        }
        return r.value;
      }
      readSchema() {
        const type = enum_1.MessageHeader.Schema;
        const message = this.readMessage(type);
        const schema = message && message.header();
        if (!message || !schema) {
          throw new Error(nullMessage(type));
        }
        return schema;
      }
    };
    exports.JSONMessageReader = JSONMessageReader2;
    exports.PADDING = 4;
    exports.MAGIC_STR = "ARROW1";
    exports.MAGIC = new Uint8Array(exports.MAGIC_STR.length);
    for (let i = 0; i < exports.MAGIC_STR.length; i += 1 | 0) {
      exports.MAGIC[i] = exports.MAGIC_STR.charCodeAt(i);
    }
    function checkForMagicArrowString(buffer, index = 0) {
      for (let i = -1, n = exports.MAGIC.length; ++i < n; ) {
        if (exports.MAGIC[i] !== buffer[index + i]) {
          return false;
        }
      }
      return true;
    }
    exports.checkForMagicArrowString = checkForMagicArrowString;
    exports.magicLength = exports.MAGIC.length;
    exports.magicAndPadding = exports.magicLength + exports.PADDING;
    exports.magicX2AndPadding = exports.magicLength * 2 + exports.PADDING;
  }
});

// node_modules/apache-arrow/visitor/vectorassembler.js
var require_vectorassembler = __commonJS({
  "node_modules/apache-arrow/visitor/vectorassembler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var visitor_1 = require_visitor();
    var enum_1 = require_enum();
    var recordbatch_1 = require_recordbatch2();
    var buffer_1 = require_buffer();
    var bit_1 = require_bit();
    var args_1 = require_args();
    var message_1 = require_message();
    var type_1 = require_type();
    var VectorAssembler = class extends visitor_1.Visitor {
      constructor() {
        super();
        this._byteLength = 0;
        this._nodes = [];
        this._buffers = [];
        this._bufferRegions = [];
      }
      static assemble(...args) {
        const assembler = new VectorAssembler();
        const vectorChildren = args_1.selectVectorChildrenArgs(recordbatch_1.RecordBatch, args);
        const [assembleResult = assembler] = assembler.visitMany(vectorChildren);
        return assembleResult;
      }
      visit(vector) {
        if (!type_1.DataType.isDictionary(vector.type)) {
          const { data, length, nullCount } = vector;
          if (length > 2147483647) {
            throw new RangeError("Cannot write arrays larger than 2^31 - 1 in length");
          }
          if (!type_1.DataType.isNull(vector.type)) {
            addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) : bit_1.truncateBitmap(data.offset, length, data.nullBitmap));
          }
          this.nodes.push(new message_1.FieldNode(length, nullCount));
        }
        return super.visit(vector);
      }
      visitNull(_nullV) {
        return this;
      }
      visitDictionary(vector) {
        return this.visit(vector.indices);
      }
      get nodes() {
        return this._nodes;
      }
      get buffers() {
        return this._buffers;
      }
      get byteLength() {
        return this._byteLength;
      }
      get bufferRegions() {
        return this._bufferRegions;
      }
    };
    exports.VectorAssembler = VectorAssembler;
    function addBuffer(values) {
      const byteLength = values.byteLength + 7 & ~7;
      this.buffers.push(values);
      this.bufferRegions.push(new message_1.BufferRegion(this._byteLength, byteLength));
      this._byteLength += byteLength;
      return this;
    }
    function assembleUnion(vector) {
      const { type, length, typeIds, valueOffsets } = vector;
      addBuffer.call(this, typeIds);
      if (type.mode === enum_1.UnionMode.Sparse) {
        return assembleNestedVector.call(this, vector);
      } else if (type.mode === enum_1.UnionMode.Dense) {
        if (vector.offset <= 0) {
          addBuffer.call(this, valueOffsets);
          return assembleNestedVector.call(this, vector);
        } else {
          const maxChildTypeId = typeIds.reduce((x, y) => Math.max(x, y), typeIds[0]);
          const childLengths = new Int32Array(maxChildTypeId + 1);
          const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);
          const shiftedOffsets = new Int32Array(length);
          const unshiftedOffsets = buffer_1.rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);
          for (let typeId, shift, index = -1; ++index < length; ) {
            if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {
              shift = childOffsets[typeId] = unshiftedOffsets[typeId];
            }
            shiftedOffsets[index] = unshiftedOffsets[index] - shift;
            ++childLengths[typeId];
          }
          addBuffer.call(this, shiftedOffsets);
          for (let child, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren; ) {
            if (child = vector.getChildAt(childIndex)) {
              const typeId = type.typeIds[childIndex];
              const childLength = Math.min(length, childLengths[typeId]);
              this.visit(child.slice(childOffsets[typeId], childLength));
            }
          }
        }
      }
      return this;
    }
    function assembleBoolVector(vector) {
      let values;
      if (vector.nullCount >= vector.length) {
        return addBuffer.call(this, new Uint8Array(0));
      } else if ((values = vector.values) instanceof Uint8Array) {
        return addBuffer.call(this, bit_1.truncateBitmap(vector.offset, vector.length, values));
      }
      return addBuffer.call(this, bit_1.packBools(vector));
    }
    function assembleFlatVector(vector) {
      return addBuffer.call(this, vector.values.subarray(0, vector.length * vector.stride));
    }
    function assembleFlatListVector(vector) {
      const { length, values, valueOffsets } = vector;
      const firstOffset = valueOffsets[0];
      const lastOffset = valueOffsets[length];
      const byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);
      addBuffer.call(this, buffer_1.rebaseValueOffsets(-valueOffsets[0], length, valueOffsets));
      addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength));
      return this;
    }
    function assembleListVector(vector) {
      const { length, valueOffsets } = vector;
      if (valueOffsets) {
        addBuffer.call(this, buffer_1.rebaseValueOffsets(valueOffsets[0], length, valueOffsets));
      }
      return this.visit(vector.getChildAt(0));
    }
    function assembleNestedVector(vector) {
      return this.visitMany(vector.type.children.map((_, i) => vector.getChildAt(i)).filter(Boolean))[0];
    }
    VectorAssembler.prototype.visitBool = assembleBoolVector;
    VectorAssembler.prototype.visitInt = assembleFlatVector;
    VectorAssembler.prototype.visitFloat = assembleFlatVector;
    VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
    VectorAssembler.prototype.visitBinary = assembleFlatListVector;
    VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
    VectorAssembler.prototype.visitDate = assembleFlatVector;
    VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
    VectorAssembler.prototype.visitTime = assembleFlatVector;
    VectorAssembler.prototype.visitDecimal = assembleFlatVector;
    VectorAssembler.prototype.visitList = assembleListVector;
    VectorAssembler.prototype.visitStruct = assembleNestedVector;
    VectorAssembler.prototype.visitUnion = assembleUnion;
    VectorAssembler.prototype.visitInterval = assembleFlatVector;
    VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
    VectorAssembler.prototype.visitMap = assembleListVector;
  }
});

// node_modules/apache-arrow/visitor/jsontypeassembler.js
var require_jsontypeassembler = __commonJS({
  "node_modules/apache-arrow/visitor/jsontypeassembler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var visitor_1 = require_visitor();
    var enum_1 = require_enum();
    var JSONTypeAssembler = class extends visitor_1.Visitor {
      visit(node) {
        return node == null ? void 0 : super.visit(node);
      }
      visitNull({ typeId }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase() };
      }
      visitInt({ typeId, bitWidth, isSigned }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "bitWidth": bitWidth, "isSigned": isSigned };
      }
      visitFloat({ typeId, precision }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "precision": enum_1.Precision[precision] };
      }
      visitBinary({ typeId }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase() };
      }
      visitBool({ typeId }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase() };
      }
      visitUtf8({ typeId }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase() };
      }
      visitDecimal({ typeId, scale, precision }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "scale": scale, "precision": precision };
      }
      visitDate({ typeId, unit }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "unit": enum_1.DateUnit[unit] };
      }
      visitTime({ typeId, unit, bitWidth }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "unit": enum_1.TimeUnit[unit], bitWidth };
      }
      visitTimestamp({ typeId, timezone, unit }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "unit": enum_1.TimeUnit[unit], timezone };
      }
      visitInterval({ typeId, unit }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "unit": enum_1.IntervalUnit[unit] };
      }
      visitList({ typeId }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase() };
      }
      visitStruct({ typeId }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase() };
      }
      visitUnion({ typeId, mode, typeIds }) {
        return {
          "name": enum_1.ArrowType[typeId].toLowerCase(),
          "mode": enum_1.UnionMode[mode],
          "typeIds": [...typeIds]
        };
      }
      visitDictionary(node) {
        return this.visit(node.dictionary);
      }
      visitFixedSizeBinary({ typeId, byteWidth }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "byteWidth": byteWidth };
      }
      visitFixedSizeList({ typeId, listSize }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "listSize": listSize };
      }
      visitMap({ typeId, keysSorted }) {
        return { "name": enum_1.ArrowType[typeId].toLowerCase(), "keysSorted": keysSorted };
      }
    };
    exports.JSONTypeAssembler = JSONTypeAssembler;
  }
});

// node_modules/apache-arrow/visitor/jsonvectorassembler.js
var require_jsonvectorassembler = __commonJS({
  "node_modules/apache-arrow/visitor/jsonvectorassembler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bn_1 = require_bn();
    var column_1 = require_column();
    var vector_1 = require_vector();
    var visitor_1 = require_visitor();
    var enum_1 = require_enum();
    var recordbatch_1 = require_recordbatch2();
    var enum_2 = require_enum();
    var bit_1 = require_bit();
    var args_1 = require_args();
    var type_1 = require_type();
    var JSONVectorAssembler = class extends visitor_1.Visitor {
      static assemble(...args) {
        return new JSONVectorAssembler().visitMany(args_1.selectColumnChildrenArgs(recordbatch_1.RecordBatch, args));
      }
      visit(column) {
        const { data, name, length } = column;
        const { offset, nullCount, nullBitmap } = data;
        const type = type_1.DataType.isDictionary(column.type) ? column.type.indices : column.type;
        const buffers = Object.assign([], data.buffers, { [enum_1.BufferType.VALIDITY]: void 0 });
        return {
          "name": name,
          "count": length,
          "VALIDITY": type_1.DataType.isNull(type) ? void 0 : nullCount <= 0 ? Array.from({ length }, () => 1) : [...bit_1.iterateBits(nullBitmap, offset, length, null, bit_1.getBit)],
          ...super.visit(vector_1.Vector.new(data.clone(type, offset, length, 0, buffers)))
        };
      }
      visitNull() {
        return {};
      }
      visitBool({ values, offset, length }) {
        return { "DATA": [...bit_1.iterateBits(values, offset, length, null, bit_1.getBool)] };
      }
      visitInt(vector) {
        return {
          "DATA": vector.type.bitWidth < 64 ? [...vector.values] : [...bigNumsToStrings(vector.values, 2)]
        };
      }
      visitFloat(vector) {
        return { "DATA": [...vector.values] };
      }
      visitUtf8(vector) {
        return { "DATA": [...vector], "OFFSET": [...vector.valueOffsets] };
      }
      visitBinary(vector) {
        return { "DATA": [...binaryToString(vector)], OFFSET: [...vector.valueOffsets] };
      }
      visitFixedSizeBinary(vector) {
        return { "DATA": [...binaryToString(vector)] };
      }
      visitDate(vector) {
        return {
          "DATA": vector.type.unit === enum_2.DateUnit.DAY ? [...vector.values] : [...bigNumsToStrings(vector.values, 2)]
        };
      }
      visitTimestamp(vector) {
        return { "DATA": [...bigNumsToStrings(vector.values, 2)] };
      }
      visitTime(vector) {
        return {
          "DATA": vector.type.unit < enum_2.TimeUnit.MICROSECOND ? [...vector.values] : [...bigNumsToStrings(vector.values, 2)]
        };
      }
      visitDecimal(vector) {
        return { "DATA": [...bigNumsToStrings(vector.values, 4)] };
      }
      visitList(vector) {
        return {
          "OFFSET": [...vector.valueOffsets],
          "children": vector.type.children.map((f, i) => this.visit(new column_1.Column(f, [vector.getChildAt(i)])))
        };
      }
      visitStruct(vector) {
        return {
          "children": vector.type.children.map((f, i) => this.visit(new column_1.Column(f, [vector.getChildAt(i)])))
        };
      }
      visitUnion(vector) {
        return {
          "TYPE": [...vector.typeIds],
          "OFFSET": vector.type.mode === enum_2.UnionMode.Dense ? [...vector.valueOffsets] : void 0,
          "children": vector.type.children.map((f, i) => this.visit(new column_1.Column(f, [vector.getChildAt(i)])))
        };
      }
      visitInterval(vector) {
        return { "DATA": [...vector.values] };
      }
      visitFixedSizeList(vector) {
        return {
          "children": vector.type.children.map((f, i) => this.visit(new column_1.Column(f, [vector.getChildAt(i)])))
        };
      }
      visitMap(vector) {
        return {
          "OFFSET": [...vector.valueOffsets],
          "children": vector.type.children.map((f, i) => this.visit(new column_1.Column(f, [vector.getChildAt(i)])))
        };
      }
    };
    exports.JSONVectorAssembler = JSONVectorAssembler;
    function* binaryToString(vector) {
      for (const octets of vector) {
        yield octets.reduce((str, byte) => {
          return `${str}${("0" + (byte & 255).toString(16)).slice(-2)}`;
        }, "").toUpperCase();
      }
    }
    function* bigNumsToStrings(values, stride) {
      for (let i = -1, n = values.length / stride; ++i < n; ) {
        yield `${bn_1.BN.new(values.subarray((i + 0) * stride, (i + 1) * stride), false)}`;
      }
    }
  }
});

// node_modules/apache-arrow/ipc/writer.js
var require_writer = __commonJS({
  "node_modules/apache-arrow/ipc/writer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var table_1 = require_table();
    var message_1 = require_message2();
    var column_1 = require_column();
    var type_1 = require_type();
    var schema_1 = require_schema();
    var message_2 = require_message();
    var metadata = require_message();
    var file_1 = require_file();
    var enum_1 = require_enum();
    var stream_1 = require_stream();
    var vectorassembler_1 = require_vectorassembler();
    var jsontypeassembler_1 = require_jsontypeassembler();
    var jsonvectorassembler_1 = require_jsonvectorassembler();
    var buffer_1 = require_buffer();
    var recordbatch_1 = require_recordbatch2();
    var interfaces_1 = require_interfaces();
    var compat_1 = require_compat();
    var RecordBatchWriter3 = class extends interfaces_1.ReadableInterop {
      constructor(options) {
        super();
        this._position = 0;
        this._started = false;
        this._sink = new stream_1.AsyncByteQueue();
        this._schema = null;
        this._dictionaryBlocks = [];
        this._recordBatchBlocks = [];
        this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
        compat_1.isObject(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false });
        this._autoDestroy = typeof options.autoDestroy === "boolean" ? options.autoDestroy : true;
        this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === "boolean" ? options.writeLegacyIpcFormat : false;
      }
      static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
      }
      static throughDOM(writableStrategy, readableStrategy) {
        throw new Error(`"throughDOM" not available in this environment`);
      }
      toString(sync = false) {
        return this._sink.toString(sync);
      }
      toUint8Array(sync = false) {
        return this._sink.toUint8Array(sync);
      }
      writeAll(input) {
        if (compat_1.isPromise(input)) {
          return input.then((x) => this.writeAll(x));
        } else if (compat_1.isAsyncIterable(input)) {
          return writeAllAsync(this, input);
        }
        return writeAll(this, input);
      }
      get closed() {
        return this._sink.closed;
      }
      [Symbol.asyncIterator]() {
        return this._sink[Symbol.asyncIterator]();
      }
      toDOMStream(options) {
        return this._sink.toDOMStream(options);
      }
      toNodeStream(options) {
        return this._sink.toNodeStream(options);
      }
      close() {
        return this.reset()._sink.close();
      }
      abort(reason) {
        return this.reset()._sink.abort(reason);
      }
      finish() {
        this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);
        return this;
      }
      reset(sink = this._sink, schema = null) {
        if (sink === this._sink || sink instanceof stream_1.AsyncByteQueue) {
          this._sink = sink;
        } else {
          this._sink = new stream_1.AsyncByteQueue();
          if (sink && compat_1.isWritableDOMStream(sink)) {
            this.toDOMStream({ type: "bytes" }).pipeTo(sink);
          } else if (sink && compat_1.isWritableNodeStream(sink)) {
            this.toNodeStream({ objectMode: false }).pipe(sink);
          }
        }
        if (this._started && this._schema) {
          this._writeFooter(this._schema);
        }
        this._started = false;
        this._dictionaryBlocks = [];
        this._recordBatchBlocks = [];
        this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
        if (!schema || !schema.compareTo(this._schema)) {
          if (schema === null) {
            this._position = 0;
            this._schema = null;
          } else {
            this._started = true;
            this._schema = schema;
            this._writeSchema(schema);
          }
        }
        return this;
      }
      write(payload) {
        let schema = null;
        if (!this._sink) {
          throw new Error(`RecordBatchWriter is closed`);
        } else if (payload === null || payload === void 0) {
          return this.finish() && void 0;
        } else if (payload instanceof table_1.Table && !(schema = payload.schema)) {
          return this.finish() && void 0;
        } else if (payload instanceof recordbatch_1.RecordBatch && !(schema = payload.schema)) {
          return this.finish() && void 0;
        }
        if (schema && !schema.compareTo(this._schema)) {
          if (this._started && this._autoDestroy) {
            return this.close();
          }
          this.reset(this._sink, schema);
        }
        if (payload instanceof recordbatch_1.RecordBatch) {
          if (!(payload instanceof recordbatch_1._InternalEmptyPlaceholderRecordBatch)) {
            this._writeRecordBatch(payload);
          }
        } else if (payload instanceof table_1.Table) {
          this.writeAll(payload.chunks);
        } else if (compat_1.isIterable(payload)) {
          this.writeAll(payload);
        }
      }
      _writeMessage(message, alignment = 8) {
        const a = alignment - 1;
        const buffer = message_2.Message.encode(message);
        const flatbufferSize = buffer.byteLength;
        const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
        const alignedSize = flatbufferSize + prefixSize + a & ~a;
        const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
        if (message.headerType === enum_1.MessageHeader.RecordBatch) {
          this._recordBatchBlocks.push(new file_1.FileBlock(alignedSize, message.bodyLength, this._position));
        } else if (message.headerType === enum_1.MessageHeader.DictionaryBatch) {
          this._dictionaryBlocks.push(new file_1.FileBlock(alignedSize, message.bodyLength, this._position));
        }
        if (!this._writeLegacyIpcFormat) {
          this._write(Int32Array.of(-1));
        }
        this._write(Int32Array.of(alignedSize - prefixSize));
        if (flatbufferSize > 0) {
          this._write(buffer);
        }
        return this._writePadding(nPaddingBytes);
      }
      _write(chunk) {
        if (this._started) {
          const buffer = buffer_1.toUint8Array(chunk);
          if (buffer && buffer.byteLength > 0) {
            this._sink.write(buffer);
            this._position += buffer.byteLength;
          }
        }
        return this;
      }
      _writeSchema(schema) {
        return this._writeMessage(message_2.Message.from(schema));
      }
      _writeFooter(schema) {
        return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));
      }
      _writeMagic() {
        return this._write(message_1.MAGIC);
      }
      _writePadding(nBytes) {
        return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;
      }
      _writeRecordBatch(batch) {
        const { byteLength, nodes, bufferRegions, buffers } = vectorassembler_1.VectorAssembler.assemble(batch);
        const recordBatch = new metadata.RecordBatch(batch.length, nodes, bufferRegions);
        const message = message_2.Message.from(recordBatch, byteLength);
        return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);
      }
      _writeDictionaryBatch(dictionary, id, isDelta = false) {
        this._dictionaryDeltaOffsets.set(id, dictionary.length + (this._dictionaryDeltaOffsets.get(id) || 0));
        const { byteLength, nodes, bufferRegions, buffers } = vectorassembler_1.VectorAssembler.assemble(dictionary);
        const recordBatch = new metadata.RecordBatch(dictionary.length, nodes, bufferRegions);
        const dictionaryBatch = new metadata.DictionaryBatch(recordBatch, id, isDelta);
        const message = message_2.Message.from(dictionaryBatch, byteLength);
        return this._writeMessage(message)._writeBodyBuffers(buffers);
      }
      _writeBodyBuffers(buffers) {
        let buffer;
        let size, padding;
        for (let i = -1, n = buffers.length; ++i < n; ) {
          if ((buffer = buffers[i]) && (size = buffer.byteLength) > 0) {
            this._write(buffer);
            if ((padding = (size + 7 & ~7) - size) > 0) {
              this._writePadding(padding);
            }
          }
        }
        return this;
      }
      _writeDictionaries(batch) {
        for (let [id, dictionary] of batch.dictionaries) {
          let offset = this._dictionaryDeltaOffsets.get(id) || 0;
          if (offset === 0 || (dictionary = dictionary.slice(offset)).length > 0) {
            const chunks = "chunks" in dictionary ? dictionary.chunks : [dictionary];
            for (const chunk of chunks) {
              this._writeDictionaryBatch(chunk, id, offset > 0);
              offset += chunk.length;
            }
          }
        }
        return this;
      }
    };
    exports.RecordBatchWriter = RecordBatchWriter3;
    var RecordBatchStreamWriter2 = class extends RecordBatchWriter3 {
      static writeAll(input, options) {
        const writer = new RecordBatchStreamWriter2(options);
        if (compat_1.isPromise(input)) {
          return input.then((x) => writer.writeAll(x));
        } else if (compat_1.isAsyncIterable(input)) {
          return writeAllAsync(writer, input);
        }
        return writeAll(writer, input);
      }
    };
    exports.RecordBatchStreamWriter = RecordBatchStreamWriter2;
    var RecordBatchFileWriter2 = class extends RecordBatchWriter3 {
      constructor() {
        super();
        this._autoDestroy = true;
      }
      static writeAll(input) {
        const writer = new RecordBatchFileWriter2();
        if (compat_1.isPromise(input)) {
          return input.then((x) => writer.writeAll(x));
        } else if (compat_1.isAsyncIterable(input)) {
          return writeAllAsync(writer, input);
        }
        return writeAll(writer, input);
      }
      _writeSchema(schema) {
        return this._writeMagic()._writePadding(2);
      }
      _writeFooter(schema) {
        const buffer = file_1.Footer.encode(new file_1.Footer(schema, enum_1.MetadataVersion.V4, this._recordBatchBlocks, this._dictionaryBlocks));
        return super._writeFooter(schema)._write(buffer)._write(Int32Array.of(buffer.byteLength))._writeMagic();
      }
    };
    exports.RecordBatchFileWriter = RecordBatchFileWriter2;
    var RecordBatchJSONWriter2 = class extends RecordBatchWriter3 {
      constructor() {
        super();
        this._autoDestroy = true;
        this._recordBatches = [];
        this._dictionaries = [];
      }
      static writeAll(input) {
        return new RecordBatchJSONWriter2().writeAll(input);
      }
      _writeMessage() {
        return this;
      }
      _writeFooter(schema) {
        return this;
      }
      _writeSchema(schema) {
        return this._write(`{
  "schema": ${JSON.stringify({ fields: schema.fields.map(fieldToJSON) }, null, 2)}`);
      }
      _writeDictionaries(batch) {
        if (batch.dictionaries.size > 0) {
          this._dictionaries.push(batch);
        }
        return this;
      }
      _writeDictionaryBatch(dictionary, id, isDelta = false) {
        this._dictionaryDeltaOffsets.set(id, dictionary.length + (this._dictionaryDeltaOffsets.get(id) || 0));
        this._write(this._dictionaryBlocks.length === 0 ? `    ` : `,
    `);
        this._write(`${dictionaryBatchToJSON(dictionary, id, isDelta)}`);
        this._dictionaryBlocks.push(new file_1.FileBlock(0, 0, 0));
        return this;
      }
      _writeRecordBatch(batch) {
        this._writeDictionaries(batch);
        this._recordBatches.push(batch);
        return this;
      }
      close() {
        if (this._dictionaries.length > 0) {
          this._write(`,
  "dictionaries": [
`);
          for (const batch of this._dictionaries) {
            super._writeDictionaries(batch);
          }
          this._write(`
  ]`);
        }
        if (this._recordBatches.length > 0) {
          for (let i = -1, n = this._recordBatches.length; ++i < n; ) {
            this._write(i === 0 ? `,
  "batches": [
    ` : `,
    `);
            this._write(`${recordBatchToJSON(this._recordBatches[i])}`);
            this._recordBatchBlocks.push(new file_1.FileBlock(0, 0, 0));
          }
          this._write(`
  ]`);
        }
        if (this._schema) {
          this._write(`
}`);
        }
        this._dictionaries = [];
        this._recordBatches = [];
        return super.close();
      }
    };
    exports.RecordBatchJSONWriter = RecordBatchJSONWriter2;
    function writeAll(writer, input) {
      let chunks = input;
      if (input instanceof table_1.Table) {
        chunks = input.chunks;
        writer.reset(void 0, input.schema);
      }
      for (const batch of chunks) {
        writer.write(batch);
      }
      return writer.finish();
    }
    async function writeAllAsync(writer, batches) {
      for await (const batch of batches) {
        writer.write(batch);
      }
      return writer.finish();
    }
    function fieldToJSON({ name, type, nullable }) {
      const assembler = new jsontypeassembler_1.JSONTypeAssembler();
      return {
        "name": name,
        "nullable": nullable,
        "type": assembler.visit(type),
        "children": (type.children || []).map(fieldToJSON),
        "dictionary": !type_1.DataType.isDictionary(type) ? void 0 : {
          "id": type.id,
          "isOrdered": type.isOrdered,
          "indexType": assembler.visit(type.indices)
        }
      };
    }
    function dictionaryBatchToJSON(dictionary, id, isDelta = false) {
      const field = new schema_1.Field(`${id}`, dictionary.type, dictionary.nullCount > 0);
      const columns = jsonvectorassembler_1.JSONVectorAssembler.assemble(new column_1.Column(field, [dictionary]));
      return JSON.stringify({
        "id": id,
        "isDelta": isDelta,
        "data": {
          "count": dictionary.length,
          "columns": columns
        }
      }, null, 2);
    }
    function recordBatchToJSON(records) {
      return JSON.stringify({
        "count": records.length,
        "columns": jsonvectorassembler_1.JSONVectorAssembler.assemble(records)
      }, null, 2);
    }
  }
});

// node_modules/apache-arrow/util/recordbatch.js
var require_recordbatch = __commonJS({
  "node_modules/apache-arrow/util/recordbatch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_1 = require_data();
    var schema_1 = require_schema();
    var chunked_1 = require_chunked();
    var recordbatch_1 = require_recordbatch2();
    var noopBuf = new Uint8Array(0);
    var nullBufs = (bitmapLength) => [
      noopBuf,
      noopBuf,
      new Uint8Array(bitmapLength),
      noopBuf
    ];
    function ensureSameLengthData(schema, chunks, batchLength = chunks.reduce((l, c) => Math.max(l, c.length), 0)) {
      let data;
      let field;
      let i = -1, n = chunks.length;
      const fields = [...schema.fields];
      const batchData = [];
      const bitmapLength = (batchLength + 63 & ~63) >> 3;
      while (++i < n) {
        if ((data = chunks[i]) && data.length === batchLength) {
          batchData[i] = data;
        } else {
          (field = fields[i]).nullable || (fields[i] = fields[i].clone({ nullable: true }));
          batchData[i] = data ? data._changeLengthAndBackfillNullBitmap(batchLength) : data_1.Data.new(field.type, 0, batchLength, batchLength, nullBufs(bitmapLength));
        }
      }
      return [new schema_1.Schema(fields), batchLength, batchData];
    }
    exports.ensureSameLengthData = ensureSameLengthData;
    function distributeColumnsIntoRecordBatches(columns) {
      return distributeVectorsIntoRecordBatches(new schema_1.Schema(columns.map(({ field }) => field)), columns);
    }
    exports.distributeColumnsIntoRecordBatches = distributeColumnsIntoRecordBatches;
    function distributeVectorsIntoRecordBatches(schema, vecs) {
      return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v) => v instanceof chunked_1.Chunked ? v.chunks.map((c) => c.data) : [v.data]));
    }
    exports.distributeVectorsIntoRecordBatches = distributeVectorsIntoRecordBatches;
    function uniformlyDistributeChunksAcrossRecordBatches(schema, columns) {
      const fields = [...schema.fields];
      const batchArgs = [];
      const memo = { numBatches: columns.reduce((n, c) => Math.max(n, c.length), 0) };
      let numBatches = 0, batchLength = 0;
      let i = -1, numColumns = columns.length;
      let child, childData = [];
      while (memo.numBatches-- > 0) {
        for (batchLength = Number.POSITIVE_INFINITY, i = -1; ++i < numColumns; ) {
          childData[i] = child = columns[i].shift();
          batchLength = Math.min(batchLength, child ? child.length : batchLength);
        }
        if (isFinite(batchLength)) {
          childData = distributeChildData(fields, batchLength, childData, columns, memo);
          if (batchLength > 0) {
            batchArgs[numBatches++] = [batchLength, childData.slice()];
          }
        }
      }
      return [
        schema = new schema_1.Schema(fields, schema.metadata),
        batchArgs.map((xs) => new recordbatch_1.RecordBatch(schema, ...xs))
      ];
    }
    function distributeChildData(fields, batchLength, childData, columns, memo) {
      let data;
      let field;
      let length = 0, i = -1, n = columns.length;
      const bitmapLength = (batchLength + 63 & ~63) >> 3;
      while (++i < n) {
        if ((data = childData[i]) && (length = data.length) >= batchLength) {
          if (length === batchLength) {
            childData[i] = data;
          } else {
            childData[i] = data.slice(0, batchLength);
            data = data.slice(batchLength, length - batchLength);
            memo.numBatches = Math.max(memo.numBatches, columns[i].unshift(data));
          }
        } else {
          (field = fields[i]).nullable || (fields[i] = field.clone({ nullable: true }));
          childData[i] = data ? data._changeLengthAndBackfillNullBitmap(batchLength) : data_1.Data.new(field.type, 0, batchLength, batchLength, nullBufs(bitmapLength));
        }
      }
      return childData;
    }
  }
});

// node_modules/apache-arrow/vector/base.js
var require_base = __commonJS({
  "node_modules/apache-arrow/vector/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var enum_1 = require_enum();
    var chunked_1 = require_chunked();
    var vector_1 = require_vector2();
    var vector_2 = require_vector();
    var BaseVector2 = class extends vector_2.AbstractVector {
      constructor(data, children) {
        super();
        this._children = children;
        this.numChildren = data.childData.length;
        this._bindDataAccessors(this.data = data);
      }
      get type() {
        return this.data.type;
      }
      get typeId() {
        return this.data.typeId;
      }
      get length() {
        return this.data.length;
      }
      get offset() {
        return this.data.offset;
      }
      get stride() {
        return this.data.stride;
      }
      get nullCount() {
        return this.data.nullCount;
      }
      get byteLength() {
        return this.data.byteLength;
      }
      get VectorName() {
        return `${enum_1.Type[this.typeId]}Vector`;
      }
      get ArrayType() {
        return this.type.ArrayType;
      }
      get values() {
        return this.data.values;
      }
      get typeIds() {
        return this.data.typeIds;
      }
      get nullBitmap() {
        return this.data.nullBitmap;
      }
      get valueOffsets() {
        return this.data.valueOffsets;
      }
      get [Symbol.toStringTag]() {
        return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
      }
      clone(data, children = this._children) {
        return vector_2.Vector.new(data, children);
      }
      concat(...others) {
        return chunked_1.Chunked.concat(this, ...others);
      }
      slice(begin, end) {
        return vector_1.clampRange(this, begin, end, this._sliceInternal);
      }
      isValid(index) {
        if (this.nullCount > 0) {
          const idx = this.offset + index;
          const val = this.nullBitmap[idx >> 3];
          const mask = val & 1 << idx % 8;
          return mask !== 0;
        }
        return true;
      }
      getChildAt(index) {
        return index < 0 || index >= this.numChildren ? null : (this._children || (this._children = []))[index] || (this._children[index] = vector_2.Vector.new(this.data.childData[index]));
      }
      toJSON() {
        return [...this];
      }
      _sliceInternal(self, begin, end) {
        return self.clone(self.data.slice(begin, end - begin), null);
      }
      _bindDataAccessors(data) {
      }
    };
    exports.BaseVector = BaseVector2;
    BaseVector2.prototype[Symbol.isConcatSpreadable] = true;
  }
});

// node_modules/apache-arrow/vector/binary.js
var require_binary2 = __commonJS({
  "node_modules/apache-arrow/vector/binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector();
    var base_1 = require_base();
    var type_1 = require_type();
    var BinaryVector2 = class extends base_1.BaseVector {
      asUtf8() {
        return vector_1.Vector.new(this.data.clone(new type_1.Utf8()));
      }
    };
    exports.BinaryVector = BinaryVector2;
  }
});

// node_modules/apache-arrow/vector/bool.js
var require_bool2 = __commonJS({
  "node_modules/apache-arrow/vector/bool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var type_1 = require_type();
    var base_1 = require_base();
    var index_1 = require_vector3();
    var BoolVector2 = class extends base_1.BaseVector {
      static from(input) {
        return index_1.vectorFromValuesWithType(() => new type_1.Bool(), input);
      }
    };
    exports.BoolVector = BoolVector2;
  }
});

// node_modules/apache-arrow/vector/date.js
var require_date2 = __commonJS({
  "node_modules/apache-arrow/vector/date.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var enum_1 = require_enum();
    var base_1 = require_base();
    var index_1 = require_vector3();
    var type_1 = require_type();
    var DateVector2 = class extends base_1.BaseVector {
      static from(...args) {
        if (args.length === 2) {
          return index_1.vectorFromValuesWithType(() => args[1] === enum_1.DateUnit.DAY ? new type_1.DateDay() : new type_1.DateMillisecond(), args[0]);
        }
        return index_1.vectorFromValuesWithType(() => new type_1.DateMillisecond(), args[0]);
      }
    };
    exports.DateVector = DateVector2;
    var DateDayVector2 = class extends DateVector2 {
    };
    exports.DateDayVector = DateDayVector2;
    var DateMillisecondVector2 = class extends DateVector2 {
    };
    exports.DateMillisecondVector = DateMillisecondVector2;
  }
});

// node_modules/apache-arrow/vector/decimal.js
var require_decimal2 = __commonJS({
  "node_modules/apache-arrow/vector/decimal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var DecimalVector2 = class extends base_1.BaseVector {
    };
    exports.DecimalVector = DecimalVector2;
  }
});

// node_modules/apache-arrow/vector/dictionary.js
var require_dictionary2 = __commonJS({
  "node_modules/apache-arrow/vector/dictionary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_1 = require_data();
    var vector_1 = require_vector();
    var base_1 = require_base();
    var index_1 = require_vector3();
    var type_1 = require_type();
    var DictionaryVector2 = class extends base_1.BaseVector {
      constructor(data) {
        super(data);
        this.indices = vector_1.Vector.new(data.clone(this.type.indices));
      }
      static from(...args) {
        if (args.length === 3) {
          const [values, indices, keys] = args;
          const type = new type_1.Dictionary(values.type, indices, null, null);
          return vector_1.Vector.new(data_1.Data.Dictionary(type, 0, keys.length, 0, null, keys, values));
        }
        return index_1.vectorFromValuesWithType(() => args[0].type, args[0]);
      }
      get dictionary() {
        return this.data.dictionary;
      }
      reverseLookup(value) {
        return this.dictionary.indexOf(value);
      }
      getKey(idx) {
        return this.indices.get(idx);
      }
      getValue(key) {
        return this.dictionary.get(key);
      }
      setKey(idx, key) {
        return this.indices.set(idx, key);
      }
      setValue(key, value) {
        return this.dictionary.set(key, value);
      }
    };
    exports.DictionaryVector = DictionaryVector2;
    DictionaryVector2.prototype.indices = null;
  }
});

// node_modules/apache-arrow/vector/fixedsizebinary.js
var require_fixedsizebinary2 = __commonJS({
  "node_modules/apache-arrow/vector/fixedsizebinary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var FixedSizeBinaryVector2 = class extends base_1.BaseVector {
    };
    exports.FixedSizeBinaryVector = FixedSizeBinaryVector2;
  }
});

// node_modules/apache-arrow/vector/fixedsizelist.js
var require_fixedsizelist2 = __commonJS({
  "node_modules/apache-arrow/vector/fixedsizelist.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var FixedSizeListVector2 = class extends base_1.BaseVector {
    };
    exports.FixedSizeListVector = FixedSizeListVector2;
  }
});

// node_modules/apache-arrow/vector/float.js
var require_float2 = __commonJS({
  "node_modules/apache-arrow/vector/float.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_1 = require_data();
    var vector_1 = require_vector();
    var base_1 = require_base();
    var index_1 = require_vector3();
    var type_1 = require_type();
    var FloatVector2 = class extends base_1.BaseVector {
      static from(input) {
        let ArrowType2 = vectorTypeToDataType(this);
        if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
          let InputType = arrayTypeToDataType(input.constructor) || ArrowType2;
          if (ArrowType2 === null) {
            ArrowType2 = InputType;
          }
          if (ArrowType2 && ArrowType2 === InputType) {
            let type = new ArrowType2();
            let length = input.byteLength / type.ArrayType.BYTES_PER_ELEMENT;
            if (!convertTo16Bit(ArrowType2, input.constructor)) {
              return vector_1.Vector.new(data_1.Data.Float(type, 0, length, 0, null, input));
            }
          }
        }
        if (ArrowType2) {
          return index_1.vectorFromValuesWithType(() => new ArrowType2(), input);
        }
        if (input instanceof DataView || input instanceof ArrayBuffer) {
          throw new TypeError(`Cannot infer float type from instance of ${input.constructor.name}`);
        }
        throw new TypeError("Unrecognized FloatVector input");
      }
    };
    exports.FloatVector = FloatVector2;
    var Float16Vector2 = class extends FloatVector2 {
      toFloat32Array() {
        return new Float32Array(this);
      }
      toFloat64Array() {
        return new Float64Array(this);
      }
    };
    exports.Float16Vector = Float16Vector2;
    var Float32Vector2 = class extends FloatVector2 {
    };
    exports.Float32Vector = Float32Vector2;
    var Float64Vector2 = class extends FloatVector2 {
    };
    exports.Float64Vector = Float64Vector2;
    var convertTo16Bit = (typeCtor, dataCtor) => {
      return typeCtor === type_1.Float16 && dataCtor !== Uint16Array;
    };
    var arrayTypeToDataType = (ctor) => {
      switch (ctor) {
        case Uint16Array:
          return type_1.Float16;
        case Float32Array:
          return type_1.Float32;
        case Float64Array:
          return type_1.Float64;
        default:
          return null;
      }
    };
    var vectorTypeToDataType = (ctor) => {
      switch (ctor) {
        case Float16Vector2:
          return type_1.Float16;
        case Float32Vector2:
          return type_1.Float32;
        case Float64Vector2:
          return type_1.Float64;
        default:
          return null;
      }
    };
  }
});

// node_modules/apache-arrow/vector/interval.js
var require_interval2 = __commonJS({
  "node_modules/apache-arrow/vector/interval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var IntervalVector2 = class extends base_1.BaseVector {
    };
    exports.IntervalVector = IntervalVector2;
    var IntervalDayTimeVector2 = class extends IntervalVector2 {
    };
    exports.IntervalDayTimeVector = IntervalDayTimeVector2;
    var IntervalYearMonthVector2 = class extends IntervalVector2 {
    };
    exports.IntervalYearMonthVector = IntervalYearMonthVector2;
  }
});

// node_modules/apache-arrow/vector/int.js
var require_int3 = __commonJS({
  "node_modules/apache-arrow/vector/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_1 = require_data();
    var vector_1 = require_vector();
    var base_1 = require_base();
    var index_1 = require_vector3();
    var compat_1 = require_compat();
    var buffer_1 = require_buffer();
    var type_1 = require_type();
    var IntVector2 = class extends base_1.BaseVector {
      static from(...args) {
        let [input, is64bit = false] = args;
        let ArrowType2 = vectorTypeToDataType(this, is64bit);
        if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
          let InputType = arrayTypeToDataType(input.constructor, is64bit) || ArrowType2;
          if (ArrowType2 === null) {
            ArrowType2 = InputType;
          }
          if (ArrowType2 && ArrowType2 === InputType) {
            let type = new ArrowType2();
            let length = input.byteLength / type.ArrayType.BYTES_PER_ELEMENT;
            if (convert32To64Bit(ArrowType2, input.constructor)) {
              length *= 0.5;
            }
            return vector_1.Vector.new(data_1.Data.Int(type, 0, length, 0, null, input));
          }
        }
        if (ArrowType2) {
          return index_1.vectorFromValuesWithType(() => new ArrowType2(), input);
        }
        if (input instanceof DataView || input instanceof ArrayBuffer) {
          throw new TypeError(`Cannot infer integer type from instance of ${input.constructor.name}`);
        }
        throw new TypeError("Unrecognized IntVector input");
      }
    };
    exports.IntVector = IntVector2;
    var Int8Vector2 = class extends IntVector2 {
    };
    exports.Int8Vector = Int8Vector2;
    var Int16Vector2 = class extends IntVector2 {
    };
    exports.Int16Vector = Int16Vector2;
    var Int32Vector2 = class extends IntVector2 {
    };
    exports.Int32Vector = Int32Vector2;
    var Int64Vector2 = class extends IntVector2 {
      toBigInt64Array() {
        return buffer_1.toBigInt64Array(this.values);
      }
      get values64() {
        return this._values64 || (this._values64 = this.toBigInt64Array());
      }
    };
    exports.Int64Vector = Int64Vector2;
    var Uint8Vector2 = class extends IntVector2 {
    };
    exports.Uint8Vector = Uint8Vector2;
    var Uint16Vector2 = class extends IntVector2 {
    };
    exports.Uint16Vector = Uint16Vector2;
    var Uint32Vector2 = class extends IntVector2 {
    };
    exports.Uint32Vector = Uint32Vector2;
    var Uint64Vector2 = class extends IntVector2 {
      toBigUint64Array() {
        return buffer_1.toBigUint64Array(this.values);
      }
      get values64() {
        return this._values64 || (this._values64 = this.toBigUint64Array());
      }
    };
    exports.Uint64Vector = Uint64Vector2;
    var convert32To64Bit = (typeCtor, dataCtor) => {
      return (typeCtor === type_1.Int64 || typeCtor === type_1.Uint64) && (dataCtor === Int32Array || dataCtor === Uint32Array);
    };
    var arrayTypeToDataType = (ctor, is64bit) => {
      switch (ctor) {
        case Int8Array:
          return type_1.Int8;
        case Int16Array:
          return type_1.Int16;
        case Int32Array:
          return is64bit ? type_1.Int64 : type_1.Int32;
        case compat_1.BigInt64Array:
          return type_1.Int64;
        case Uint8Array:
          return type_1.Uint8;
        case Uint16Array:
          return type_1.Uint16;
        case Uint32Array:
          return is64bit ? type_1.Uint64 : type_1.Uint32;
        case compat_1.BigUint64Array:
          return type_1.Uint64;
        default:
          return null;
      }
    };
    var vectorTypeToDataType = (ctor, is64bit) => {
      switch (ctor) {
        case Int8Vector2:
          return type_1.Int8;
        case Int16Vector2:
          return type_1.Int16;
        case Int32Vector2:
          return is64bit ? type_1.Int64 : type_1.Int32;
        case Int64Vector2:
          return type_1.Int64;
        case Uint8Vector2:
          return type_1.Uint8;
        case Uint16Vector2:
          return type_1.Uint16;
        case Uint32Vector2:
          return is64bit ? type_1.Uint64 : type_1.Uint32;
        case Uint64Vector2:
          return type_1.Uint64;
        default:
          return null;
      }
    };
  }
});

// node_modules/apache-arrow/vector/list.js
var require_list2 = __commonJS({
  "node_modules/apache-arrow/vector/list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var ListVector2 = class extends base_1.BaseVector {
    };
    exports.ListVector = ListVector2;
  }
});

// node_modules/apache-arrow/vector/map.js
var require_map2 = __commonJS({
  "node_modules/apache-arrow/vector/map.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var row_1 = require_row();
    var vector_1 = require_vector();
    var base_1 = require_base();
    var type_1 = require_type();
    var MapVector2 = class extends base_1.BaseVector {
      asList() {
        const child = this.type.children[0];
        return vector_1.Vector.new(this.data.clone(new type_1.List(child)));
      }
      bind(index) {
        const child = this.getChildAt(0);
        const { [index]: begin, [index + 1]: end } = this.valueOffsets;
        return new row_1.MapRow(child.slice(begin, end));
      }
    };
    exports.MapVector = MapVector2;
  }
});

// node_modules/apache-arrow/vector/null.js
var require_null2 = __commonJS({
  "node_modules/apache-arrow/vector/null.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var NullVector2 = class extends base_1.BaseVector {
    };
    exports.NullVector = NullVector2;
  }
});

// node_modules/apache-arrow/vector/struct.js
var require_struct2 = __commonJS({
  "node_modules/apache-arrow/vector/struct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var row_1 = require_row();
    var base_1 = require_base();
    var kRowIndex = Symbol.for("rowIndex");
    var StructVector2 = class extends base_1.BaseVector {
      bind(index) {
        const proto = this._row || (this._row = new row_1.StructRow(this));
        const bound = Object.create(proto);
        bound[kRowIndex] = index;
        return bound;
      }
    };
    exports.StructVector = StructVector2;
  }
});

// node_modules/apache-arrow/vector/timestamp.js
var require_timestamp2 = __commonJS({
  "node_modules/apache-arrow/vector/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var TimestampVector2 = class extends base_1.BaseVector {
    };
    exports.TimestampVector = TimestampVector2;
    var TimestampSecondVector2 = class extends TimestampVector2 {
    };
    exports.TimestampSecondVector = TimestampSecondVector2;
    var TimestampMillisecondVector2 = class extends TimestampVector2 {
    };
    exports.TimestampMillisecondVector = TimestampMillisecondVector2;
    var TimestampMicrosecondVector2 = class extends TimestampVector2 {
    };
    exports.TimestampMicrosecondVector = TimestampMicrosecondVector2;
    var TimestampNanosecondVector2 = class extends TimestampVector2 {
    };
    exports.TimestampNanosecondVector = TimestampNanosecondVector2;
  }
});

// node_modules/apache-arrow/vector/time.js
var require_time2 = __commonJS({
  "node_modules/apache-arrow/vector/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var TimeVector2 = class extends base_1.BaseVector {
    };
    exports.TimeVector = TimeVector2;
    var TimeSecondVector2 = class extends TimeVector2 {
    };
    exports.TimeSecondVector = TimeSecondVector2;
    var TimeMillisecondVector2 = class extends TimeVector2 {
    };
    exports.TimeMillisecondVector = TimeMillisecondVector2;
    var TimeMicrosecondVector2 = class extends TimeVector2 {
    };
    exports.TimeMicrosecondVector = TimeMicrosecondVector2;
    var TimeNanosecondVector2 = class extends TimeVector2 {
    };
    exports.TimeNanosecondVector = TimeNanosecondVector2;
  }
});

// node_modules/apache-arrow/vector/union.js
var require_union2 = __commonJS({
  "node_modules/apache-arrow/vector/union.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require_base();
    var UnionVector2 = class extends base_1.BaseVector {
      get typeIdToChildIndex() {
        return this.data.type.typeIdToChildIndex;
      }
    };
    exports.UnionVector = UnionVector2;
    var DenseUnionVector2 = class extends UnionVector2 {
      get valueOffsets() {
        return this.data.valueOffsets;
      }
    };
    exports.DenseUnionVector = DenseUnionVector2;
    var SparseUnionVector2 = class extends UnionVector2 {
    };
    exports.SparseUnionVector = SparseUnionVector2;
  }
});

// node_modules/apache-arrow/vector/utf8.js
var require_utf83 = __commonJS({
  "node_modules/apache-arrow/vector/utf8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector();
    var base_1 = require_base();
    var type_1 = require_type();
    var index_1 = require_vector3();
    var Utf8Vector2 = class extends base_1.BaseVector {
      static from(input) {
        return index_1.vectorFromValuesWithType(() => new type_1.Utf8(), input);
      }
      asBinary() {
        return vector_1.Vector.new(this.data.clone(new type_1.Binary()));
      }
    };
    exports.Utf8Vector = Utf8Vector2;
  }
});

// node_modules/apache-arrow/util/fn.js
var require_fn = __commonJS({
  "node_modules/apache-arrow/util/fn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function partial0(visit) {
      return function() {
        return visit(this);
      };
    }
    exports.partial0 = partial0;
    function partial1(visit) {
      return function(a) {
        return visit(this, a);
      };
    }
    exports.partial1 = partial1;
    function partial2(visit) {
      return function(a, b) {
        return visit(this, a, b);
      };
    }
    exports.partial2 = partial2;
  }
});

// node_modules/apache-arrow/visitor/get.js
var require_get = __commonJS({
  "node_modules/apache-arrow/visitor/get.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bn_1 = require_bn();
    var visitor_1 = require_visitor();
    var utf8_1 = require_utf8();
    var math_1 = require_math();
    var enum_1 = require_enum();
    var GetVisitor = class extends visitor_1.Visitor {
    };
    exports.GetVisitor = GetVisitor;
    var epochDaysToMs = (data, index) => 864e5 * data[index];
    var epochMillisecondsLongToMs = (data, index) => 4294967296 * data[index + 1] + (data[index] >>> 0);
    var epochMicrosecondsLongToMs = (data, index) => 4294967296 * (data[index + 1] / 1e3) + (data[index] >>> 0) / 1e3;
    var epochNanosecondsLongToMs = (data, index) => 4294967296 * (data[index + 1] / 1e6) + (data[index] >>> 0) / 1e6;
    var epochMillisecondsToDate = (epochMs) => new Date(epochMs);
    var epochDaysToDate = (data, index) => epochMillisecondsToDate(epochDaysToMs(data, index));
    var epochMillisecondsLongToDate = (data, index) => epochMillisecondsToDate(epochMillisecondsLongToMs(data, index));
    var getNull = (_vector, _index) => null;
    var getVariableWidthBytes = (values, valueOffsets, index) => {
      const { [index]: x, [index + 1]: y } = valueOffsets;
      return x != null && y != null ? values.subarray(x, y) : null;
    };
    var getBool = ({ offset, values }, index) => {
      const idx = offset + index;
      const byte = values[idx >> 3];
      return (byte & 1 << idx % 8) !== 0;
    };
    var getDateDay = ({ values }, index) => epochDaysToDate(values, index);
    var getDateMillisecond = ({ values }, index) => epochMillisecondsLongToDate(values, index * 2);
    var getNumeric = ({ stride, values }, index) => values[stride * index];
    var getFloat16 = ({ stride, values }, index) => math_1.uint16ToFloat64(values[stride * index]);
    var getBigInts = ({ stride, values, type }, index) => bn_1.BN.new(values.subarray(stride * index, stride * (index + 1)), type.isSigned);
    var getFixedSizeBinary = ({ stride, values }, index) => values.subarray(stride * index, stride * (index + 1));
    var getBinary = ({ values, valueOffsets }, index) => getVariableWidthBytes(values, valueOffsets, index);
    var getUtf8 = ({ values, valueOffsets }, index) => {
      const bytes = getVariableWidthBytes(values, valueOffsets, index);
      return bytes !== null ? utf8_1.decodeUtf8(bytes) : null;
    };
    var getInt = (vector, index) => vector.type.bitWidth < 64 ? getNumeric(vector, index) : getBigInts(vector, index);
    var getFloat = (vector, index) => vector.type.precision !== enum_1.Precision.HALF ? getNumeric(vector, index) : getFloat16(vector, index);
    var getDate = (vector, index) => vector.type.unit === enum_1.DateUnit.DAY ? getDateDay(vector, index) : getDateMillisecond(vector, index);
    var getTimestampSecond = ({ values }, index) => 1e3 * epochMillisecondsLongToMs(values, index * 2);
    var getTimestampMillisecond = ({ values }, index) => epochMillisecondsLongToMs(values, index * 2);
    var getTimestampMicrosecond = ({ values }, index) => epochMicrosecondsLongToMs(values, index * 2);
    var getTimestampNanosecond = ({ values }, index) => epochNanosecondsLongToMs(values, index * 2);
    var getTimestamp = (vector, index) => {
      switch (vector.type.unit) {
        case enum_1.TimeUnit.SECOND:
          return getTimestampSecond(vector, index);
        case enum_1.TimeUnit.MILLISECOND:
          return getTimestampMillisecond(vector, index);
        case enum_1.TimeUnit.MICROSECOND:
          return getTimestampMicrosecond(vector, index);
        case enum_1.TimeUnit.NANOSECOND:
          return getTimestampNanosecond(vector, index);
      }
    };
    var getTimeSecond = ({ values, stride }, index) => values[stride * index];
    var getTimeMillisecond = ({ values, stride }, index) => values[stride * index];
    var getTimeMicrosecond = ({ values }, index) => bn_1.BN.signed(values.subarray(2 * index, 2 * (index + 1)));
    var getTimeNanosecond = ({ values }, index) => bn_1.BN.signed(values.subarray(2 * index, 2 * (index + 1)));
    var getTime = (vector, index) => {
      switch (vector.type.unit) {
        case enum_1.TimeUnit.SECOND:
          return getTimeSecond(vector, index);
        case enum_1.TimeUnit.MILLISECOND:
          return getTimeMillisecond(vector, index);
        case enum_1.TimeUnit.MICROSECOND:
          return getTimeMicrosecond(vector, index);
        case enum_1.TimeUnit.NANOSECOND:
          return getTimeNanosecond(vector, index);
      }
    };
    var getDecimal = ({ values }, index) => bn_1.BN.decimal(values.subarray(4 * index, 4 * (index + 1)));
    var getList = (vector, index) => {
      const child = vector.getChildAt(0), { valueOffsets, stride } = vector;
      return child.slice(valueOffsets[index * stride], valueOffsets[index * stride + 1]);
    };
    var getMap = (vector, index) => {
      return vector.bind(index);
    };
    var getStruct = (vector, index) => {
      return vector.bind(index);
    };
    var getUnion = (vector, index) => {
      return vector.type.mode === enum_1.UnionMode.Dense ? getDenseUnion(vector, index) : getSparseUnion(vector, index);
    };
    var getDenseUnion = (vector, index) => {
      const childIndex = vector.typeIdToChildIndex[vector.typeIds[index]];
      const child = vector.getChildAt(childIndex);
      return child ? child.get(vector.valueOffsets[index]) : null;
    };
    var getSparseUnion = (vector, index) => {
      const childIndex = vector.typeIdToChildIndex[vector.typeIds[index]];
      const child = vector.getChildAt(childIndex);
      return child ? child.get(index) : null;
    };
    var getDictionary = (vector, index) => {
      return vector.getValue(vector.getKey(index));
    };
    var getInterval = (vector, index) => vector.type.unit === enum_1.IntervalUnit.DAY_TIME ? getIntervalDayTime(vector, index) : getIntervalYearMonth(vector, index);
    var getIntervalDayTime = ({ values }, index) => values.subarray(2 * index, 2 * (index + 1));
    var getIntervalYearMonth = ({ values }, index) => {
      const interval = values[index];
      const int32s = new Int32Array(2);
      int32s[0] = interval / 12 | 0;
      int32s[1] = interval % 12 | 0;
      return int32s;
    };
    var getFixedSizeList = (vector, index) => {
      const child = vector.getChildAt(0), { stride } = vector;
      return child.slice(index * stride, (index + 1) * stride);
    };
    GetVisitor.prototype.visitNull = getNull;
    GetVisitor.prototype.visitBool = getBool;
    GetVisitor.prototype.visitInt = getInt;
    GetVisitor.prototype.visitInt8 = getNumeric;
    GetVisitor.prototype.visitInt16 = getNumeric;
    GetVisitor.prototype.visitInt32 = getNumeric;
    GetVisitor.prototype.visitInt64 = getBigInts;
    GetVisitor.prototype.visitUint8 = getNumeric;
    GetVisitor.prototype.visitUint16 = getNumeric;
    GetVisitor.prototype.visitUint32 = getNumeric;
    GetVisitor.prototype.visitUint64 = getBigInts;
    GetVisitor.prototype.visitFloat = getFloat;
    GetVisitor.prototype.visitFloat16 = getFloat16;
    GetVisitor.prototype.visitFloat32 = getNumeric;
    GetVisitor.prototype.visitFloat64 = getNumeric;
    GetVisitor.prototype.visitUtf8 = getUtf8;
    GetVisitor.prototype.visitBinary = getBinary;
    GetVisitor.prototype.visitFixedSizeBinary = getFixedSizeBinary;
    GetVisitor.prototype.visitDate = getDate;
    GetVisitor.prototype.visitDateDay = getDateDay;
    GetVisitor.prototype.visitDateMillisecond = getDateMillisecond;
    GetVisitor.prototype.visitTimestamp = getTimestamp;
    GetVisitor.prototype.visitTimestampSecond = getTimestampSecond;
    GetVisitor.prototype.visitTimestampMillisecond = getTimestampMillisecond;
    GetVisitor.prototype.visitTimestampMicrosecond = getTimestampMicrosecond;
    GetVisitor.prototype.visitTimestampNanosecond = getTimestampNanosecond;
    GetVisitor.prototype.visitTime = getTime;
    GetVisitor.prototype.visitTimeSecond = getTimeSecond;
    GetVisitor.prototype.visitTimeMillisecond = getTimeMillisecond;
    GetVisitor.prototype.visitTimeMicrosecond = getTimeMicrosecond;
    GetVisitor.prototype.visitTimeNanosecond = getTimeNanosecond;
    GetVisitor.prototype.visitDecimal = getDecimal;
    GetVisitor.prototype.visitList = getList;
    GetVisitor.prototype.visitStruct = getStruct;
    GetVisitor.prototype.visitUnion = getUnion;
    GetVisitor.prototype.visitDenseUnion = getDenseUnion;
    GetVisitor.prototype.visitSparseUnion = getSparseUnion;
    GetVisitor.prototype.visitDictionary = getDictionary;
    GetVisitor.prototype.visitInterval = getInterval;
    GetVisitor.prototype.visitIntervalDayTime = getIntervalDayTime;
    GetVisitor.prototype.visitIntervalYearMonth = getIntervalYearMonth;
    GetVisitor.prototype.visitFixedSizeList = getFixedSizeList;
    GetVisitor.prototype.visitMap = getMap;
    exports.instance = new GetVisitor();
  }
});

// node_modules/apache-arrow/visitor/indexof.js
var require_indexof = __commonJS({
  "node_modules/apache-arrow/visitor/indexof.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var visitor_1 = require_visitor();
    var bit_1 = require_bit();
    var vector_1 = require_vector2();
    var IndexOfVisitor = class extends visitor_1.Visitor {
    };
    exports.IndexOfVisitor = IndexOfVisitor;
    function nullIndexOf(vector, searchElement) {
      return searchElement === null && vector.length > 0 ? 0 : -1;
    }
    function indexOfNull(vector, fromIndex) {
      const { nullBitmap } = vector;
      if (!nullBitmap || vector.nullCount <= 0) {
        return -1;
      }
      let i = 0;
      for (const isValid of bit_1.iterateBits(nullBitmap, vector.data.offset + (fromIndex || 0), vector.length, nullBitmap, bit_1.getBool)) {
        if (!isValid) {
          return i;
        }
        ++i;
      }
      return -1;
    }
    function indexOfValue(vector, searchElement, fromIndex) {
      if (searchElement === void 0) {
        return -1;
      }
      if (searchElement === null) {
        return indexOfNull(vector, fromIndex);
      }
      const compare = vector_1.createElementComparator(searchElement);
      for (let i = (fromIndex || 0) - 1, n = vector.length; ++i < n; ) {
        if (compare(vector.get(i))) {
          return i;
        }
      }
      return -1;
    }
    function indexOfUnion(vector, searchElement, fromIndex) {
      const compare = vector_1.createElementComparator(searchElement);
      for (let i = (fromIndex || 0) - 1, n = vector.length; ++i < n; ) {
        if (compare(vector.get(i))) {
          return i;
        }
      }
      return -1;
    }
    IndexOfVisitor.prototype.visitNull = nullIndexOf;
    IndexOfVisitor.prototype.visitBool = indexOfValue;
    IndexOfVisitor.prototype.visitInt = indexOfValue;
    IndexOfVisitor.prototype.visitInt8 = indexOfValue;
    IndexOfVisitor.prototype.visitInt16 = indexOfValue;
    IndexOfVisitor.prototype.visitInt32 = indexOfValue;
    IndexOfVisitor.prototype.visitInt64 = indexOfValue;
    IndexOfVisitor.prototype.visitUint8 = indexOfValue;
    IndexOfVisitor.prototype.visitUint16 = indexOfValue;
    IndexOfVisitor.prototype.visitUint32 = indexOfValue;
    IndexOfVisitor.prototype.visitUint64 = indexOfValue;
    IndexOfVisitor.prototype.visitFloat = indexOfValue;
    IndexOfVisitor.prototype.visitFloat16 = indexOfValue;
    IndexOfVisitor.prototype.visitFloat32 = indexOfValue;
    IndexOfVisitor.prototype.visitFloat64 = indexOfValue;
    IndexOfVisitor.prototype.visitUtf8 = indexOfValue;
    IndexOfVisitor.prototype.visitBinary = indexOfValue;
    IndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;
    IndexOfVisitor.prototype.visitDate = indexOfValue;
    IndexOfVisitor.prototype.visitDateDay = indexOfValue;
    IndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimestamp = indexOfValue;
    IndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;
    IndexOfVisitor.prototype.visitTime = indexOfValue;
    IndexOfVisitor.prototype.visitTimeSecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;
    IndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;
    IndexOfVisitor.prototype.visitDecimal = indexOfValue;
    IndexOfVisitor.prototype.visitList = indexOfValue;
    IndexOfVisitor.prototype.visitStruct = indexOfValue;
    IndexOfVisitor.prototype.visitUnion = indexOfValue;
    IndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;
    IndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;
    IndexOfVisitor.prototype.visitDictionary = indexOfValue;
    IndexOfVisitor.prototype.visitInterval = indexOfValue;
    IndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;
    IndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;
    IndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;
    IndexOfVisitor.prototype.visitMap = indexOfValue;
    exports.instance = new IndexOfVisitor();
  }
});

// node_modules/apache-arrow/visitor/iterator.js
var require_iterator = __commonJS({
  "node_modules/apache-arrow/visitor/iterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var enum_1 = require_enum();
    var visitor_1 = require_visitor();
    var bit_1 = require_bit();
    var get_1 = require_get();
    var IteratorVisitor = class extends visitor_1.Visitor {
    };
    exports.IteratorVisitor = IteratorVisitor;
    function nullableIterator(vector) {
      const getFn = get_1.instance.getVisitFn(vector);
      return bit_1.iterateBits(vector.nullBitmap, vector.offset, vector.length, vector, (vec, idx, nullByte, nullBit) => (nullByte & 1 << nullBit) !== 0 ? getFn(vec, idx) : null);
    }
    function vectorIterator(vector) {
      if (vector.nullCount > 0) {
        return nullableIterator(vector);
      }
      const { type, typeId, length } = vector;
      if (vector.stride === 1 && (typeId === enum_1.Type.Timestamp || typeId === enum_1.Type.Int && type.bitWidth !== 64 || typeId === enum_1.Type.Time && type.bitWidth !== 64 || typeId === enum_1.Type.Float && type.precision > 0)) {
        return vector.values.subarray(0, length)[Symbol.iterator]();
      }
      return function* (getFn) {
        for (let index = -1; ++index < length; ) {
          yield getFn(vector, index);
        }
      }(get_1.instance.getVisitFn(vector));
    }
    IteratorVisitor.prototype.visitNull = vectorIterator;
    IteratorVisitor.prototype.visitBool = vectorIterator;
    IteratorVisitor.prototype.visitInt = vectorIterator;
    IteratorVisitor.prototype.visitInt8 = vectorIterator;
    IteratorVisitor.prototype.visitInt16 = vectorIterator;
    IteratorVisitor.prototype.visitInt32 = vectorIterator;
    IteratorVisitor.prototype.visitInt64 = vectorIterator;
    IteratorVisitor.prototype.visitUint8 = vectorIterator;
    IteratorVisitor.prototype.visitUint16 = vectorIterator;
    IteratorVisitor.prototype.visitUint32 = vectorIterator;
    IteratorVisitor.prototype.visitUint64 = vectorIterator;
    IteratorVisitor.prototype.visitFloat = vectorIterator;
    IteratorVisitor.prototype.visitFloat16 = vectorIterator;
    IteratorVisitor.prototype.visitFloat32 = vectorIterator;
    IteratorVisitor.prototype.visitFloat64 = vectorIterator;
    IteratorVisitor.prototype.visitUtf8 = vectorIterator;
    IteratorVisitor.prototype.visitBinary = vectorIterator;
    IteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;
    IteratorVisitor.prototype.visitDate = vectorIterator;
    IteratorVisitor.prototype.visitDateDay = vectorIterator;
    IteratorVisitor.prototype.visitDateMillisecond = vectorIterator;
    IteratorVisitor.prototype.visitTimestamp = vectorIterator;
    IteratorVisitor.prototype.visitTimestampSecond = vectorIterator;
    IteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;
    IteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;
    IteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;
    IteratorVisitor.prototype.visitTime = vectorIterator;
    IteratorVisitor.prototype.visitTimeSecond = vectorIterator;
    IteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;
    IteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;
    IteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;
    IteratorVisitor.prototype.visitDecimal = vectorIterator;
    IteratorVisitor.prototype.visitList = vectorIterator;
    IteratorVisitor.prototype.visitStruct = vectorIterator;
    IteratorVisitor.prototype.visitUnion = vectorIterator;
    IteratorVisitor.prototype.visitDenseUnion = vectorIterator;
    IteratorVisitor.prototype.visitSparseUnion = vectorIterator;
    IteratorVisitor.prototype.visitDictionary = vectorIterator;
    IteratorVisitor.prototype.visitInterval = vectorIterator;
    IteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;
    IteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;
    IteratorVisitor.prototype.visitFixedSizeList = vectorIterator;
    IteratorVisitor.prototype.visitMap = vectorIterator;
    exports.instance = new IteratorVisitor();
  }
});

// node_modules/apache-arrow/visitor/toarray.js
var require_toarray = __commonJS({
  "node_modules/apache-arrow/visitor/toarray.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var enum_1 = require_enum();
    var visitor_1 = require_visitor();
    var iterator_1 = require_iterator();
    var ToArrayVisitor = class extends visitor_1.Visitor {
    };
    exports.ToArrayVisitor = ToArrayVisitor;
    function arrayOfVector(vector) {
      const { type, length, stride } = vector;
      switch (type.typeId) {
        case enum_1.Type.Int:
        case enum_1.Type.Float:
        case enum_1.Type.Decimal:
        case enum_1.Type.Time:
        case enum_1.Type.Timestamp:
          return vector.values.subarray(0, length * stride);
      }
      return [...iterator_1.instance.visit(vector)];
    }
    ToArrayVisitor.prototype.visitNull = arrayOfVector;
    ToArrayVisitor.prototype.visitBool = arrayOfVector;
    ToArrayVisitor.prototype.visitInt = arrayOfVector;
    ToArrayVisitor.prototype.visitInt8 = arrayOfVector;
    ToArrayVisitor.prototype.visitInt16 = arrayOfVector;
    ToArrayVisitor.prototype.visitInt32 = arrayOfVector;
    ToArrayVisitor.prototype.visitInt64 = arrayOfVector;
    ToArrayVisitor.prototype.visitUint8 = arrayOfVector;
    ToArrayVisitor.prototype.visitUint16 = arrayOfVector;
    ToArrayVisitor.prototype.visitUint32 = arrayOfVector;
    ToArrayVisitor.prototype.visitUint64 = arrayOfVector;
    ToArrayVisitor.prototype.visitFloat = arrayOfVector;
    ToArrayVisitor.prototype.visitFloat16 = arrayOfVector;
    ToArrayVisitor.prototype.visitFloat32 = arrayOfVector;
    ToArrayVisitor.prototype.visitFloat64 = arrayOfVector;
    ToArrayVisitor.prototype.visitUtf8 = arrayOfVector;
    ToArrayVisitor.prototype.visitBinary = arrayOfVector;
    ToArrayVisitor.prototype.visitFixedSizeBinary = arrayOfVector;
    ToArrayVisitor.prototype.visitDate = arrayOfVector;
    ToArrayVisitor.prototype.visitDateDay = arrayOfVector;
    ToArrayVisitor.prototype.visitDateMillisecond = arrayOfVector;
    ToArrayVisitor.prototype.visitTimestamp = arrayOfVector;
    ToArrayVisitor.prototype.visitTimestampSecond = arrayOfVector;
    ToArrayVisitor.prototype.visitTimestampMillisecond = arrayOfVector;
    ToArrayVisitor.prototype.visitTimestampMicrosecond = arrayOfVector;
    ToArrayVisitor.prototype.visitTimestampNanosecond = arrayOfVector;
    ToArrayVisitor.prototype.visitTime = arrayOfVector;
    ToArrayVisitor.prototype.visitTimeSecond = arrayOfVector;
    ToArrayVisitor.prototype.visitTimeMillisecond = arrayOfVector;
    ToArrayVisitor.prototype.visitTimeMicrosecond = arrayOfVector;
    ToArrayVisitor.prototype.visitTimeNanosecond = arrayOfVector;
    ToArrayVisitor.prototype.visitDecimal = arrayOfVector;
    ToArrayVisitor.prototype.visitList = arrayOfVector;
    ToArrayVisitor.prototype.visitStruct = arrayOfVector;
    ToArrayVisitor.prototype.visitUnion = arrayOfVector;
    ToArrayVisitor.prototype.visitDenseUnion = arrayOfVector;
    ToArrayVisitor.prototype.visitSparseUnion = arrayOfVector;
    ToArrayVisitor.prototype.visitDictionary = arrayOfVector;
    ToArrayVisitor.prototype.visitInterval = arrayOfVector;
    ToArrayVisitor.prototype.visitIntervalDayTime = arrayOfVector;
    ToArrayVisitor.prototype.visitIntervalYearMonth = arrayOfVector;
    ToArrayVisitor.prototype.visitFixedSizeList = arrayOfVector;
    ToArrayVisitor.prototype.visitMap = arrayOfVector;
    exports.instance = new ToArrayVisitor();
  }
});

// node_modules/apache-arrow/visitor/bytewidth.js
var require_bytewidth = __commonJS({
  "node_modules/apache-arrow/visitor/bytewidth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var visitor_1 = require_visitor();
    var enum_1 = require_enum();
    var sum = (x, y) => x + y;
    var variableWidthColumnErrorMessage = (type) => `Cannot compute the byte width of variable-width column ${type}`;
    var ByteWidthVisitor = class extends visitor_1.Visitor {
      visitNull(____) {
        return 0;
      }
      visitInt(type) {
        return type.bitWidth / 8;
      }
      visitFloat(type) {
        return type.ArrayType.BYTES_PER_ELEMENT;
      }
      visitBinary(type) {
        throw new Error(variableWidthColumnErrorMessage(type));
      }
      visitUtf8(type) {
        throw new Error(variableWidthColumnErrorMessage(type));
      }
      visitBool(____) {
        return 1 / 8;
      }
      visitDecimal(____) {
        return 16;
      }
      visitDate(type) {
        return (type.unit + 1) * 4;
      }
      visitTime(type) {
        return type.bitWidth / 8;
      }
      visitTimestamp(type) {
        return type.unit === enum_1.TimeUnit.SECOND ? 4 : 8;
      }
      visitInterval(type) {
        return (type.unit + 1) * 4;
      }
      visitList(type) {
        throw new Error(variableWidthColumnErrorMessage(type));
      }
      visitStruct(type) {
        return this.visitFields(type.children).reduce(sum, 0);
      }
      visitUnion(type) {
        return this.visitFields(type.children).reduce(sum, 0);
      }
      visitFixedSizeBinary(type) {
        return type.byteWidth;
      }
      visitFixedSizeList(type) {
        return type.listSize * this.visitFields(type.children).reduce(sum, 0);
      }
      visitMap(type) {
        return this.visitFields(type.children).reduce(sum, 0);
      }
      visitDictionary(type) {
        return this.visit(type.indices);
      }
      visitFields(fields) {
        return (fields || []).map((field) => this.visit(field.type));
      }
      visitSchema(schema) {
        return this.visitFields(schema.fields).reduce(sum, 0);
      }
    };
    exports.ByteWidthVisitor = ByteWidthVisitor;
    exports.instance = new ByteWidthVisitor();
  }
});

// node_modules/apache-arrow/visitor/vectorctor.js
var require_vectorctor = __commonJS({
  "node_modules/apache-arrow/visitor/vectorctor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var visitor_1 = require_visitor();
    var binary_1 = require_binary2();
    var bool_1 = require_bool2();
    var date_1 = require_date2();
    var decimal_1 = require_decimal2();
    var dictionary_1 = require_dictionary2();
    var fixedsizebinary_1 = require_fixedsizebinary2();
    var fixedsizelist_1 = require_fixedsizelist2();
    var float_1 = require_float2();
    var interval_1 = require_interval2();
    var int_1 = require_int3();
    var list_1 = require_list2();
    var map_1 = require_map2();
    var null_1 = require_null2();
    var struct_1 = require_struct2();
    var timestamp_1 = require_timestamp2();
    var time_1 = require_time2();
    var union_1 = require_union2();
    var utf8_1 = require_utf83();
    var GetVectorConstructor = class extends visitor_1.Visitor {
      visitNull() {
        return null_1.NullVector;
      }
      visitBool() {
        return bool_1.BoolVector;
      }
      visitInt() {
        return int_1.IntVector;
      }
      visitInt8() {
        return int_1.Int8Vector;
      }
      visitInt16() {
        return int_1.Int16Vector;
      }
      visitInt32() {
        return int_1.Int32Vector;
      }
      visitInt64() {
        return int_1.Int64Vector;
      }
      visitUint8() {
        return int_1.Uint8Vector;
      }
      visitUint16() {
        return int_1.Uint16Vector;
      }
      visitUint32() {
        return int_1.Uint32Vector;
      }
      visitUint64() {
        return int_1.Uint64Vector;
      }
      visitFloat() {
        return float_1.FloatVector;
      }
      visitFloat16() {
        return float_1.Float16Vector;
      }
      visitFloat32() {
        return float_1.Float32Vector;
      }
      visitFloat64() {
        return float_1.Float64Vector;
      }
      visitUtf8() {
        return utf8_1.Utf8Vector;
      }
      visitBinary() {
        return binary_1.BinaryVector;
      }
      visitFixedSizeBinary() {
        return fixedsizebinary_1.FixedSizeBinaryVector;
      }
      visitDate() {
        return date_1.DateVector;
      }
      visitDateDay() {
        return date_1.DateDayVector;
      }
      visitDateMillisecond() {
        return date_1.DateMillisecondVector;
      }
      visitTimestamp() {
        return timestamp_1.TimestampVector;
      }
      visitTimestampSecond() {
        return timestamp_1.TimestampSecondVector;
      }
      visitTimestampMillisecond() {
        return timestamp_1.TimestampMillisecondVector;
      }
      visitTimestampMicrosecond() {
        return timestamp_1.TimestampMicrosecondVector;
      }
      visitTimestampNanosecond() {
        return timestamp_1.TimestampNanosecondVector;
      }
      visitTime() {
        return time_1.TimeVector;
      }
      visitTimeSecond() {
        return time_1.TimeSecondVector;
      }
      visitTimeMillisecond() {
        return time_1.TimeMillisecondVector;
      }
      visitTimeMicrosecond() {
        return time_1.TimeMicrosecondVector;
      }
      visitTimeNanosecond() {
        return time_1.TimeNanosecondVector;
      }
      visitDecimal() {
        return decimal_1.DecimalVector;
      }
      visitList() {
        return list_1.ListVector;
      }
      visitStruct() {
        return struct_1.StructVector;
      }
      visitUnion() {
        return union_1.UnionVector;
      }
      visitDenseUnion() {
        return union_1.DenseUnionVector;
      }
      visitSparseUnion() {
        return union_1.SparseUnionVector;
      }
      visitDictionary() {
        return dictionary_1.DictionaryVector;
      }
      visitInterval() {
        return interval_1.IntervalVector;
      }
      visitIntervalDayTime() {
        return interval_1.IntervalDayTimeVector;
      }
      visitIntervalYearMonth() {
        return interval_1.IntervalYearMonthVector;
      }
      visitFixedSizeList() {
        return fixedsizelist_1.FixedSizeListVector;
      }
      visitMap() {
        return map_1.MapVector;
      }
    };
    exports.GetVectorConstructor = GetVectorConstructor;
    exports.instance = new GetVectorConstructor();
  }
});

// node_modules/apache-arrow/vector/index.js
var require_vector3 = __commonJS({
  "node_modules/apache-arrow/vector/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector();
    exports.Vector = vector_1.Vector;
    var base_1 = require_base();
    exports.BaseVector = base_1.BaseVector;
    var binary_1 = require_binary2();
    exports.BinaryVector = binary_1.BinaryVector;
    var bool_1 = require_bool2();
    exports.BoolVector = bool_1.BoolVector;
    var chunked_1 = require_chunked();
    exports.Chunked = chunked_1.Chunked;
    var date_1 = require_date2();
    exports.DateVector = date_1.DateVector;
    exports.DateDayVector = date_1.DateDayVector;
    exports.DateMillisecondVector = date_1.DateMillisecondVector;
    var decimal_1 = require_decimal2();
    exports.DecimalVector = decimal_1.DecimalVector;
    var dictionary_1 = require_dictionary2();
    exports.DictionaryVector = dictionary_1.DictionaryVector;
    var fixedsizebinary_1 = require_fixedsizebinary2();
    exports.FixedSizeBinaryVector = fixedsizebinary_1.FixedSizeBinaryVector;
    var fixedsizelist_1 = require_fixedsizelist2();
    exports.FixedSizeListVector = fixedsizelist_1.FixedSizeListVector;
    var float_1 = require_float2();
    exports.FloatVector = float_1.FloatVector;
    exports.Float16Vector = float_1.Float16Vector;
    exports.Float32Vector = float_1.Float32Vector;
    exports.Float64Vector = float_1.Float64Vector;
    var interval_1 = require_interval2();
    exports.IntervalVector = interval_1.IntervalVector;
    exports.IntervalDayTimeVector = interval_1.IntervalDayTimeVector;
    exports.IntervalYearMonthVector = interval_1.IntervalYearMonthVector;
    var int_1 = require_int3();
    exports.IntVector = int_1.IntVector;
    exports.Int8Vector = int_1.Int8Vector;
    exports.Int16Vector = int_1.Int16Vector;
    exports.Int32Vector = int_1.Int32Vector;
    exports.Int64Vector = int_1.Int64Vector;
    exports.Uint8Vector = int_1.Uint8Vector;
    exports.Uint16Vector = int_1.Uint16Vector;
    exports.Uint32Vector = int_1.Uint32Vector;
    exports.Uint64Vector = int_1.Uint64Vector;
    var list_1 = require_list2();
    exports.ListVector = list_1.ListVector;
    var map_1 = require_map2();
    exports.MapVector = map_1.MapVector;
    var null_1 = require_null2();
    exports.NullVector = null_1.NullVector;
    var struct_1 = require_struct2();
    exports.StructVector = struct_1.StructVector;
    var timestamp_1 = require_timestamp2();
    exports.TimestampVector = timestamp_1.TimestampVector;
    exports.TimestampSecondVector = timestamp_1.TimestampSecondVector;
    exports.TimestampMillisecondVector = timestamp_1.TimestampMillisecondVector;
    exports.TimestampMicrosecondVector = timestamp_1.TimestampMicrosecondVector;
    exports.TimestampNanosecondVector = timestamp_1.TimestampNanosecondVector;
    var time_1 = require_time2();
    exports.TimeVector = time_1.TimeVector;
    exports.TimeSecondVector = time_1.TimeSecondVector;
    exports.TimeMillisecondVector = time_1.TimeMillisecondVector;
    exports.TimeMicrosecondVector = time_1.TimeMicrosecondVector;
    exports.TimeNanosecondVector = time_1.TimeNanosecondVector;
    var union_1 = require_union2();
    exports.UnionVector = union_1.UnionVector;
    exports.DenseUnionVector = union_1.DenseUnionVector;
    exports.SparseUnionVector = union_1.SparseUnionVector;
    var utf8_1 = require_utf83();
    exports.Utf8Vector = utf8_1.Utf8Vector;
    var row_1 = require_row();
    exports.MapRow = row_1.MapRow;
    exports.StructRow = row_1.StructRow;
    var fn = require_fn();
    var enum_1 = require_enum();
    var vector_2 = require_vector();
    var chunked_2 = require_chunked();
    var base_2 = require_base();
    var bit_1 = require_bit();
    var compat_1 = require_compat();
    var builder_1 = require_builder();
    var get_1 = require_get();
    var set_1 = require_set();
    var indexof_1 = require_indexof();
    var toarray_1 = require_toarray();
    var iterator_1 = require_iterator();
    var bytewidth_1 = require_bytewidth();
    var vectorctor_1 = require_vectorctor();
    vector_2.Vector.new = newVector;
    vector_2.Vector.from = vectorFrom;
    function newVector(data, ...args) {
      return new (vectorctor_1.instance.getVisitFn(data)())(data, ...args);
    }
    function vectorFromValuesWithType(newDataType, input) {
      if (compat_1.isIterable(input)) {
        return vector_2.Vector.from({ "nullValues": [null, void 0], type: newDataType(), "values": input });
      } else if (compat_1.isAsyncIterable(input)) {
        return vector_2.Vector.from({ "nullValues": [null, void 0], type: newDataType(), "values": input });
      }
      const { "values": values = [], "type": type = newDataType(), "nullValues": nullValues = [null, void 0] } = { ...input };
      return compat_1.isIterable(values) ? vector_2.Vector.from({ nullValues, ...input, type }) : vector_2.Vector.from({ nullValues, ...input, type });
    }
    exports.vectorFromValuesWithType = vectorFromValuesWithType;
    function vectorFrom(input) {
      const { "values": values = [], ...options } = { "nullValues": [null, void 0], ...input };
      if (compat_1.isIterable(values)) {
        const chunks = [...builder_1.Builder.throughIterable(options)(values)];
        return chunks.length === 1 ? chunks[0] : chunked_2.Chunked.concat(chunks);
      }
      return (async (chunks) => {
        const transform = builder_1.Builder.throughAsyncIterable(options);
        for await (const chunk of transform(values)) {
          chunks.push(chunk);
        }
        return chunks.length === 1 ? chunks[0] : chunked_2.Chunked.concat(chunks);
      })([]);
    }
    base_2.BaseVector.prototype.get = function baseVectorGet(index) {
      return get_1.instance.visit(this, index);
    };
    base_2.BaseVector.prototype.set = function baseVectorSet(index, value) {
      return set_1.instance.visit(this, index, value);
    };
    base_2.BaseVector.prototype.indexOf = function baseVectorIndexOf(value, fromIndex) {
      return indexof_1.instance.visit(this, value, fromIndex);
    };
    base_2.BaseVector.prototype.toArray = function baseVectorToArray() {
      return toarray_1.instance.visit(this);
    };
    base_2.BaseVector.prototype.getByteWidth = function baseVectorGetByteWidth() {
      return bytewidth_1.instance.visit(this.type);
    };
    base_2.BaseVector.prototype[Symbol.iterator] = function baseVectorSymbolIterator() {
      return iterator_1.instance.visit(this);
    };
    base_2.BaseVector.prototype._bindDataAccessors = bindBaseVectorDataAccessors;
    Object.keys(enum_1.Type).map((T) => enum_1.Type[T]).filter((T) => typeof T === "number").filter((typeId) => typeId !== enum_1.Type.NONE).forEach((typeId) => {
      const VectorCtor = vectorctor_1.instance.visit(typeId);
      VectorCtor.prototype["get"] = fn.partial1(get_1.instance.getVisitFn(typeId));
      VectorCtor.prototype["set"] = fn.partial2(set_1.instance.getVisitFn(typeId));
      VectorCtor.prototype["indexOf"] = fn.partial2(indexof_1.instance.getVisitFn(typeId));
      VectorCtor.prototype["toArray"] = fn.partial0(toarray_1.instance.getVisitFn(typeId));
      VectorCtor.prototype["getByteWidth"] = partialType0(bytewidth_1.instance.getVisitFn(typeId));
      VectorCtor.prototype[Symbol.iterator] = fn.partial0(iterator_1.instance.getVisitFn(typeId));
    });
    function partialType0(visit) {
      return function() {
        return visit(this.type);
      };
    }
    function wrapNullableGet(fn2) {
      return function(i) {
        return this.isValid(i) ? fn2.call(this, i) : null;
      };
    }
    function wrapNullableSet(fn2) {
      return function(i, a) {
        if (bit_1.setBool(this.nullBitmap, this.offset + i, !(a === null || a === void 0))) {
          fn2.call(this, i, a);
        }
      };
    }
    function bindBaseVectorDataAccessors() {
      const nullBitmap = this.nullBitmap;
      if (nullBitmap && nullBitmap.byteLength > 0) {
        this.get = wrapNullableGet(this.get);
        this.set = wrapNullableSet(this.set);
      }
    }
  }
});

// node_modules/apache-arrow/table.js
var require_table = __commonJS({
  "node_modules/apache-arrow/table.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var column_1 = require_column();
    var schema_1 = require_schema();
    var recordbatch_1 = require_recordbatch2();
    var reader_1 = require_reader();
    var type_1 = require_type();
    var args_1 = require_args();
    var compat_1 = require_compat();
    var writer_1 = require_writer();
    var recordbatch_2 = require_recordbatch();
    var index_1 = require_vector3();
    var Table2 = class extends index_1.Chunked {
      constructor(...args) {
        let schema = null;
        if (args[0] instanceof schema_1.Schema) {
          schema = args.shift();
        }
        let chunks = args_1.selectArgs(recordbatch_1.RecordBatch, args);
        if (!schema && !(schema = chunks[0] && chunks[0].schema)) {
          throw new TypeError("Table must be initialized with a Schema or at least one RecordBatch");
        }
        chunks[0] || (chunks[0] = new recordbatch_1._InternalEmptyPlaceholderRecordBatch(schema));
        super(new type_1.Struct(schema.fields), chunks);
        this._schema = schema;
        this._chunks = chunks;
      }
      static empty(schema = new schema_1.Schema([])) {
        return new Table2(schema, []);
      }
      static from(input) {
        if (!input) {
          return Table2.empty();
        }
        if (typeof input === "object") {
          let table = compat_1.isIterable(input["values"]) ? tableFromIterable(input) : compat_1.isAsyncIterable(input["values"]) ? tableFromAsyncIterable(input) : null;
          if (table !== null) {
            return table;
          }
        }
        let reader = reader_1.RecordBatchReader.from(input);
        if (compat_1.isPromise(reader)) {
          return (async () => await Table2.from(await reader))();
        }
        if (reader.isSync() && (reader = reader.open())) {
          return !reader.schema ? Table2.empty() : new Table2(reader.schema, [...reader]);
        }
        return (async (opening) => {
          const reader2 = await opening;
          const schema = reader2.schema;
          const batches = [];
          if (schema) {
            for await (let batch of reader2) {
              batches.push(batch);
            }
            return new Table2(schema, batches);
          }
          return Table2.empty();
        })(reader.open());
      }
      static async fromAsync(source) {
        return await Table2.from(source);
      }
      static fromStruct(vector) {
        return Table2.new(vector.data.childData, vector.type.children);
      }
      static new(...cols) {
        return new Table2(...recordbatch_2.distributeColumnsIntoRecordBatches(args_1.selectColumnArgs(cols)));
      }
      get schema() {
        return this._schema;
      }
      get length() {
        return this._length;
      }
      get chunks() {
        return this._chunks;
      }
      get numCols() {
        return this._numChildren;
      }
      clone(chunks = this._chunks) {
        return new Table2(this._schema, chunks);
      }
      getColumn(name) {
        return this.getColumnAt(this.getColumnIndex(name));
      }
      getColumnAt(index) {
        return this.getChildAt(index);
      }
      getColumnIndex(name) {
        return this._schema.fields.findIndex((f) => f.name === name);
      }
      getChildAt(index) {
        if (index < 0 || index >= this.numChildren) {
          return null;
        }
        let field, child;
        const fields = this._schema.fields;
        const columns = this._children || (this._children = []);
        if (child = columns[index]) {
          return child;
        }
        if (field = fields[index]) {
          const chunks = this._chunks.map((chunk) => chunk.getChildAt(index)).filter((vec) => vec != null);
          if (chunks.length > 0) {
            return columns[index] = new column_1.Column(field, chunks);
          }
        }
        return null;
      }
      serialize(encoding = "binary", stream = true) {
        const Writer = !stream ? writer_1.RecordBatchFileWriter : writer_1.RecordBatchStreamWriter;
        return Writer.writeAll(this).toUint8Array(true);
      }
      count() {
        return this._length;
      }
      select(...columnNames) {
        const nameToIndex = this._schema.fields.reduce((m, f, i) => m.set(f.name, i), /* @__PURE__ */ new Map());
        return this.selectAt(...columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));
      }
      selectAt(...columnIndices) {
        const schema = this._schema.selectAt(...columnIndices);
        return new Table2(schema, this._chunks.map(({ length, data: { childData } }) => {
          return new recordbatch_1.RecordBatch(schema, length, columnIndices.map((i) => childData[i]).filter(Boolean));
        }));
      }
      assign(other) {
        const fields = this._schema.fields;
        const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {
          const [indices2, oldToNew2] = memo;
          const i = fields.findIndex((f) => f.name === f2.name);
          ~i ? oldToNew2[i] = newIdx : indices2.push(newIdx);
          return memo;
        }, [[], []]);
        const schema = this._schema.assign(other.schema);
        const columns = [
          ...fields.map((_f, i, _fs, j = oldToNew[i]) => j === void 0 ? this.getColumnAt(i) : other.getColumnAt(j)),
          ...indices.map((i) => other.getColumnAt(i))
        ].filter(Boolean);
        return new Table2(...recordbatch_2.distributeVectorsIntoRecordBatches(schema, columns));
      }
    };
    exports.Table = Table2;
    function tableFromIterable(input) {
      const { type } = input;
      if (type instanceof type_1.Struct) {
        return Table2.fromStruct(index_1.StructVector.from(input));
      }
      return null;
    }
    function tableFromAsyncIterable(input) {
      const { type } = input;
      if (type instanceof type_1.Struct) {
        return index_1.StructVector.from(input).then((vector) => Table2.fromStruct(vector));
      }
      return null;
    }
  }
});

// node_modules/apache-arrow/recordbatch.js
var require_recordbatch2 = __commonJS({
  "node_modules/apache-arrow/recordbatch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data_1 = require_data();
    var table_1 = require_table();
    var vector_1 = require_vector();
    var visitor_1 = require_visitor();
    var schema_1 = require_schema();
    var compat_1 = require_compat();
    var chunked_1 = require_chunked();
    var args_1 = require_args();
    var type_1 = require_type();
    var recordbatch_1 = require_recordbatch();
    var index_1 = require_vector3();
    var RecordBatch2 = class extends index_1.StructVector {
      constructor(...args) {
        let data;
        let schema = args[0];
        let children;
        if (args[1] instanceof data_1.Data) {
          [, data, children] = args;
        } else {
          const fields = schema.fields;
          const [, length, childData] = args;
          data = data_1.Data.Struct(new type_1.Struct(fields), 0, length, 0, null, childData);
        }
        super(data, children);
        this._schema = schema;
      }
      static from(options) {
        if (compat_1.isIterable(options["values"])) {
          return table_1.Table.from(options);
        }
        return table_1.Table.from(options);
      }
      static new(...args) {
        const [fs, xs] = args_1.selectFieldArgs(args);
        const vs = xs.filter((x) => x instanceof vector_1.Vector);
        return new RecordBatch2(...recordbatch_1.ensureSameLengthData(new schema_1.Schema(fs), vs.map((x) => x.data)));
      }
      clone(data, children = this._children) {
        return new RecordBatch2(this._schema, data, children);
      }
      concat(...others) {
        const schema = this._schema, chunks = chunked_1.Chunked.flatten(this, ...others);
        return new table_1.Table(schema, chunks.map(({ data }) => new RecordBatch2(schema, data)));
      }
      get schema() {
        return this._schema;
      }
      get numCols() {
        return this._schema.fields.length;
      }
      get dictionaries() {
        return this._dictionaries || (this._dictionaries = DictionaryCollector.collect(this));
      }
      select(...columnNames) {
        const nameToIndex = this._schema.fields.reduce((m, f, i) => m.set(f.name, i), /* @__PURE__ */ new Map());
        return this.selectAt(...columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));
      }
      selectAt(...columnIndices) {
        const schema = this._schema.selectAt(...columnIndices);
        const childData = columnIndices.map((i) => this.data.childData[i]).filter(Boolean);
        return new RecordBatch2(schema, this.length, childData);
      }
    };
    exports.RecordBatch = RecordBatch2;
    var _InternalEmptyPlaceholderRecordBatch = class extends RecordBatch2 {
      constructor(schema) {
        super(schema, 0, schema.fields.map((f) => data_1.Data.new(f.type, 0, 0, 0)));
      }
    };
    exports._InternalEmptyPlaceholderRecordBatch = _InternalEmptyPlaceholderRecordBatch;
    var DictionaryCollector = class extends visitor_1.Visitor {
      constructor() {
        super(...arguments);
        this.dictionaries = /* @__PURE__ */ new Map();
      }
      static collect(batch) {
        return new DictionaryCollector().visit(batch.data, new type_1.Struct(batch.schema.fields)).dictionaries;
      }
      visit(data, type) {
        if (type_1.DataType.isDictionary(type)) {
          return this.visitDictionary(data, type);
        } else {
          data.childData.forEach((child, i) => this.visit(child, type.children[i].type));
        }
        return this;
      }
      visitDictionary(data, type) {
        const dictionary = data.dictionary;
        if (dictionary && dictionary.length > 0) {
          this.dictionaries.set(type.id, dictionary);
        }
        return this;
      }
    };
  }
});

// node_modules/apache-arrow/ipc/reader.js
var require_reader = __commonJS({
  "node_modules/apache-arrow/ipc/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vector_1 = require_vector();
    var enum_1 = require_enum();
    var file_1 = require_file();
    var adapters_1 = require_adapters();
    var stream_1 = require_stream();
    var file_2 = require_file2();
    var vectorloader_1 = require_vectorloader();
    var recordbatch_1 = require_recordbatch2();
    var interfaces_1 = require_interfaces();
    var message_1 = require_message2();
    var compat_1 = require_compat();
    var RecordBatchReader3 = class extends interfaces_1.ReadableInterop {
      constructor(impl) {
        super();
        this._impl = impl;
      }
      get closed() {
        return this._impl.closed;
      }
      get schema() {
        return this._impl.schema;
      }
      get autoDestroy() {
        return this._impl.autoDestroy;
      }
      get dictionaries() {
        return this._impl.dictionaries;
      }
      get numDictionaries() {
        return this._impl.numDictionaries;
      }
      get numRecordBatches() {
        return this._impl.numRecordBatches;
      }
      get footer() {
        return this._impl.isFile() ? this._impl.footer : null;
      }
      isSync() {
        return this._impl.isSync();
      }
      isAsync() {
        return this._impl.isAsync();
      }
      isFile() {
        return this._impl.isFile();
      }
      isStream() {
        return this._impl.isStream();
      }
      next() {
        return this._impl.next();
      }
      throw(value) {
        return this._impl.throw(value);
      }
      return(value) {
        return this._impl.return(value);
      }
      cancel() {
        return this._impl.cancel();
      }
      reset(schema) {
        this._impl.reset(schema);
        this._DOMStream = void 0;
        this._nodeStream = void 0;
        return this;
      }
      open(options) {
        const opening = this._impl.open(options);
        return compat_1.isPromise(opening) ? opening.then(() => this) : this;
      }
      readRecordBatch(index) {
        return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;
      }
      [Symbol.iterator]() {
        return this._impl[Symbol.iterator]();
      }
      [Symbol.asyncIterator]() {
        return this._impl[Symbol.asyncIterator]();
      }
      toDOMStream() {
        return adapters_1.default.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });
      }
      toNodeStream() {
        return adapters_1.default.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: true });
      }
      static throughNode(options) {
        throw new Error(`"throughNode" not available in this environment`);
      }
      static throughDOM(writableStrategy, readableStrategy) {
        throw new Error(`"throughDOM" not available in this environment`);
      }
      static from(source) {
        if (source instanceof RecordBatchReader3) {
          return source;
        } else if (compat_1.isArrowJSON(source)) {
          return fromArrowJSON(source);
        } else if (compat_1.isFileHandle(source)) {
          return fromFileHandle(source);
        } else if (compat_1.isPromise(source)) {
          return (async () => await RecordBatchReader3.from(await source))();
        } else if (compat_1.isFetchResponse(source) || compat_1.isReadableDOMStream(source) || compat_1.isReadableNodeStream(source) || compat_1.isAsyncIterable(source)) {
          return fromAsyncByteStream(new stream_1.AsyncByteStream(source));
        }
        return fromByteStream(new stream_1.ByteStream(source));
      }
      static readAll(source) {
        if (source instanceof RecordBatchReader3) {
          return source.isSync() ? readAllSync(source) : readAllAsync(source);
        } else if (compat_1.isArrowJSON(source) || ArrayBuffer.isView(source) || compat_1.isIterable(source) || compat_1.isIteratorResult(source)) {
          return readAllSync(source);
        }
        return readAllAsync(source);
      }
    };
    exports.RecordBatchReader = RecordBatchReader3;
    var RecordBatchStreamReader2 = class extends RecordBatchReader3 {
      constructor(_impl) {
        super(_impl);
        this._impl = _impl;
      }
      [Symbol.iterator]() {
        return this._impl[Symbol.iterator]();
      }
      async *[Symbol.asyncIterator]() {
        yield* this[Symbol.iterator]();
      }
    };
    exports.RecordBatchStreamReader = RecordBatchStreamReader2;
    var AsyncRecordBatchStreamReader2 = class extends RecordBatchReader3 {
      constructor(_impl) {
        super(_impl);
        this._impl = _impl;
      }
      [Symbol.iterator]() {
        throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);
      }
      [Symbol.asyncIterator]() {
        return this._impl[Symbol.asyncIterator]();
      }
    };
    exports.AsyncRecordBatchStreamReader = AsyncRecordBatchStreamReader2;
    var RecordBatchFileReader2 = class extends RecordBatchStreamReader2 {
      constructor(_impl) {
        super(_impl);
        this._impl = _impl;
      }
    };
    exports.RecordBatchFileReader = RecordBatchFileReader2;
    var AsyncRecordBatchFileReader2 = class extends AsyncRecordBatchStreamReader2 {
      constructor(_impl) {
        super(_impl);
        this._impl = _impl;
      }
    };
    exports.AsyncRecordBatchFileReader = AsyncRecordBatchFileReader2;
    var RecordBatchReaderImpl = class {
      constructor(dictionaries = /* @__PURE__ */ new Map()) {
        this.closed = false;
        this.autoDestroy = true;
        this._dictionaryIndex = 0;
        this._recordBatchIndex = 0;
        this.dictionaries = dictionaries;
      }
      get numDictionaries() {
        return this._dictionaryIndex;
      }
      get numRecordBatches() {
        return this._recordBatchIndex;
      }
      isSync() {
        return false;
      }
      isAsync() {
        return false;
      }
      isFile() {
        return false;
      }
      isStream() {
        return false;
      }
      reset(schema) {
        this._dictionaryIndex = 0;
        this._recordBatchIndex = 0;
        this.schema = schema;
        this.dictionaries = /* @__PURE__ */ new Map();
        return this;
      }
      _loadRecordBatch(header, body) {
        return new recordbatch_1.RecordBatch(this.schema, header.length, this._loadVectors(header, body, this.schema.fields));
      }
      _loadDictionaryBatch(header, body) {
        const { id, isDelta, data } = header;
        const { dictionaries, schema } = this;
        const dictionary = dictionaries.get(id);
        if (isDelta || !dictionary) {
          const type = schema.dictionaries.get(id);
          return dictionary && isDelta ? dictionary.concat(vector_1.Vector.new(this._loadVectors(data, body, [type])[0])) : vector_1.Vector.new(this._loadVectors(data, body, [type])[0]);
        }
        return dictionary;
      }
      _loadVectors(header, body, types) {
        return new vectorloader_1.VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);
      }
    };
    var RecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
      constructor(source, dictionaries) {
        super(dictionaries);
        this._reader = !compat_1.isArrowJSON(source) ? new message_1.MessageReader(this._handle = source) : new message_1.JSONMessageReader(this._handle = source);
      }
      isSync() {
        return true;
      }
      isStream() {
        return true;
      }
      [Symbol.iterator]() {
        return this;
      }
      cancel() {
        if (!this.closed && (this.closed = true)) {
          this.reset()._reader.return();
          this._reader = null;
          this.dictionaries = null;
        }
      }
      open(options) {
        if (!this.closed) {
          this.autoDestroy = shouldAutoDestroy(this, options);
          if (!(this.schema || (this.schema = this._reader.readSchema()))) {
            this.cancel();
          }
        }
        return this;
      }
      throw(value) {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return this.reset()._reader.throw(value);
        }
        return interfaces_1.ITERATOR_DONE;
      }
      return(value) {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return this.reset()._reader.return(value);
        }
        return interfaces_1.ITERATOR_DONE;
      }
      next() {
        if (this.closed) {
          return interfaces_1.ITERATOR_DONE;
        }
        let message, { _reader: reader } = this;
        while (message = this._readNextMessageAndValidate()) {
          if (message.isSchema()) {
            this.reset(message.header());
          } else if (message.isRecordBatch()) {
            this._recordBatchIndex++;
            const header = message.header();
            const buffer = reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return { done: false, value: recordBatch };
          } else if (message.isDictionaryBatch()) {
            this._dictionaryIndex++;
            const header = message.header();
            const buffer = reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
        if (this.schema && this._recordBatchIndex === 0) {
          this._recordBatchIndex++;
          return { done: false, value: new recordbatch_1._InternalEmptyPlaceholderRecordBatch(this.schema) };
        }
        return this.return();
      }
      _readNextMessageAndValidate(type) {
        return this._reader.readMessage(type);
      }
    };
    var AsyncRecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
      constructor(source, dictionaries) {
        super(dictionaries);
        this._reader = new message_1.AsyncMessageReader(this._handle = source);
      }
      isAsync() {
        return true;
      }
      isStream() {
        return true;
      }
      [Symbol.asyncIterator]() {
        return this;
      }
      async cancel() {
        if (!this.closed && (this.closed = true)) {
          await this.reset()._reader.return();
          this._reader = null;
          this.dictionaries = null;
        }
      }
      async open(options) {
        if (!this.closed) {
          this.autoDestroy = shouldAutoDestroy(this, options);
          if (!(this.schema || (this.schema = await this._reader.readSchema()))) {
            await this.cancel();
          }
        }
        return this;
      }
      async throw(value) {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return await this.reset()._reader.throw(value);
        }
        return interfaces_1.ITERATOR_DONE;
      }
      async return(value) {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return await this.reset()._reader.return(value);
        }
        return interfaces_1.ITERATOR_DONE;
      }
      async next() {
        if (this.closed) {
          return interfaces_1.ITERATOR_DONE;
        }
        let message, { _reader: reader } = this;
        while (message = await this._readNextMessageAndValidate()) {
          if (message.isSchema()) {
            await this.reset(message.header());
          } else if (message.isRecordBatch()) {
            this._recordBatchIndex++;
            const header = message.header();
            const buffer = await reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return { done: false, value: recordBatch };
          } else if (message.isDictionaryBatch()) {
            this._dictionaryIndex++;
            const header = message.header();
            const buffer = await reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
        if (this.schema && this._recordBatchIndex === 0) {
          this._recordBatchIndex++;
          return { done: false, value: new recordbatch_1._InternalEmptyPlaceholderRecordBatch(this.schema) };
        }
        return await this.return();
      }
      async _readNextMessageAndValidate(type) {
        return await this._reader.readMessage(type);
      }
    };
    var RecordBatchFileReaderImpl = class extends RecordBatchStreamReaderImpl {
      constructor(source, dictionaries) {
        super(source instanceof file_2.RandomAccessFile ? source : new file_2.RandomAccessFile(source), dictionaries);
      }
      get footer() {
        return this._footer;
      }
      get numDictionaries() {
        return this._footer ? this._footer.numDictionaries : 0;
      }
      get numRecordBatches() {
        return this._footer ? this._footer.numRecordBatches : 0;
      }
      isSync() {
        return true;
      }
      isFile() {
        return true;
      }
      open(options) {
        if (!this.closed && !this._footer) {
          this.schema = (this._footer = this._readFooter()).schema;
          for (const block of this._footer.dictionaryBatches()) {
            block && this._readDictionaryBatch(this._dictionaryIndex++);
          }
        }
        return super.open(options);
      }
      readRecordBatch(index) {
        if (this.closed) {
          return null;
        }
        if (!this._footer) {
          this.open();
        }
        const block = this._footer && this._footer.getRecordBatch(index);
        if (block && this._handle.seek(block.offset)) {
          const message = this._reader.readMessage(enum_1.MessageHeader.RecordBatch);
          if (message && message.isRecordBatch()) {
            const header = message.header();
            const buffer = this._reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return recordBatch;
          }
        }
        return null;
      }
      _readDictionaryBatch(index) {
        const block = this._footer && this._footer.getDictionaryBatch(index);
        if (block && this._handle.seek(block.offset)) {
          const message = this._reader.readMessage(enum_1.MessageHeader.DictionaryBatch);
          if (message && message.isDictionaryBatch()) {
            const header = message.header();
            const buffer = this._reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
      }
      _readFooter() {
        const { _handle } = this;
        const offset = _handle.size - message_1.magicAndPadding;
        const length = _handle.readInt32(offset);
        const buffer = _handle.readAt(offset - length, length);
        return file_1.Footer.decode(buffer);
      }
      _readNextMessageAndValidate(type) {
        if (!this._footer) {
          this.open();
        }
        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
          const block = this._footer && this._footer.getRecordBatch(this._recordBatchIndex);
          if (block && this._handle.seek(block.offset)) {
            return this._reader.readMessage(type);
          }
        }
        return null;
      }
    };
    var AsyncRecordBatchFileReaderImpl = class extends AsyncRecordBatchStreamReaderImpl {
      constructor(source, ...rest) {
        const byteLength = typeof rest[0] !== "number" ? rest.shift() : void 0;
        const dictionaries = rest[0] instanceof Map ? rest.shift() : void 0;
        super(source instanceof file_2.AsyncRandomAccessFile ? source : new file_2.AsyncRandomAccessFile(source, byteLength), dictionaries);
      }
      get footer() {
        return this._footer;
      }
      get numDictionaries() {
        return this._footer ? this._footer.numDictionaries : 0;
      }
      get numRecordBatches() {
        return this._footer ? this._footer.numRecordBatches : 0;
      }
      isFile() {
        return true;
      }
      isAsync() {
        return true;
      }
      async open(options) {
        if (!this.closed && !this._footer) {
          this.schema = (this._footer = await this._readFooter()).schema;
          for (const block of this._footer.dictionaryBatches()) {
            block && await this._readDictionaryBatch(this._dictionaryIndex++);
          }
        }
        return await super.open(options);
      }
      async readRecordBatch(index) {
        if (this.closed) {
          return null;
        }
        if (!this._footer) {
          await this.open();
        }
        const block = this._footer && this._footer.getRecordBatch(index);
        if (block && await this._handle.seek(block.offset)) {
          const message = await this._reader.readMessage(enum_1.MessageHeader.RecordBatch);
          if (message && message.isRecordBatch()) {
            const header = message.header();
            const buffer = await this._reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return recordBatch;
          }
        }
        return null;
      }
      async _readDictionaryBatch(index) {
        const block = this._footer && this._footer.getDictionaryBatch(index);
        if (block && await this._handle.seek(block.offset)) {
          const message = await this._reader.readMessage(enum_1.MessageHeader.DictionaryBatch);
          if (message && message.isDictionaryBatch()) {
            const header = message.header();
            const buffer = await this._reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
      }
      async _readFooter() {
        const { _handle } = this;
        _handle._pending && await _handle._pending;
        const offset = _handle.size - message_1.magicAndPadding;
        const length = await _handle.readInt32(offset);
        const buffer = await _handle.readAt(offset - length, length);
        return file_1.Footer.decode(buffer);
      }
      async _readNextMessageAndValidate(type) {
        if (!this._footer) {
          await this.open();
        }
        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
          const block = this._footer.getRecordBatch(this._recordBatchIndex);
          if (block && await this._handle.seek(block.offset)) {
            return await this._reader.readMessage(type);
          }
        }
        return null;
      }
    };
    var RecordBatchJSONReaderImpl = class extends RecordBatchStreamReaderImpl {
      constructor(source, dictionaries) {
        super(source, dictionaries);
      }
      _loadVectors(header, body, types) {
        return new vectorloader_1.JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);
      }
    };
    function shouldAutoDestroy(self, options) {
      return options && typeof options["autoDestroy"] === "boolean" ? options["autoDestroy"] : self["autoDestroy"];
    }
    function* readAllSync(source) {
      const reader = RecordBatchReader3.from(source);
      try {
        if (!reader.open({ autoDestroy: false }).closed) {
          do {
            yield reader;
          } while (!reader.reset().open().closed);
        }
      } finally {
        reader.cancel();
      }
    }
    async function* readAllAsync(source) {
      const reader = await RecordBatchReader3.from(source);
      try {
        if (!(await reader.open({ autoDestroy: false })).closed) {
          do {
            yield reader;
          } while (!(await reader.reset().open()).closed);
        }
      } finally {
        await reader.cancel();
      }
    }
    function fromArrowJSON(source) {
      return new RecordBatchStreamReader2(new RecordBatchJSONReaderImpl(source));
    }
    function fromByteStream(source) {
      const bytes = source.peek(message_1.magicLength + 7 & ~7);
      return bytes && bytes.byteLength >= 4 ? !message_1.checkForMagicArrowString(bytes) ? new RecordBatchStreamReader2(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader2(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader2(new RecordBatchStreamReaderImpl(function* () {
      }()));
    }
    async function fromAsyncByteStream(source) {
      const bytes = await source.peek(message_1.magicLength + 7 & ~7);
      return bytes && bytes.byteLength >= 4 ? !message_1.checkForMagicArrowString(bytes) ? new AsyncRecordBatchStreamReader2(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader2(new RecordBatchFileReaderImpl(await source.read())) : new AsyncRecordBatchStreamReader2(new AsyncRecordBatchStreamReaderImpl(async function* () {
      }()));
    }
    async function fromFileHandle(source) {
      const { size } = await source.stat();
      const file = new file_2.AsyncRandomAccessFile(source, size);
      if (size >= message_1.magicX2AndPadding) {
        if (message_1.checkForMagicArrowString(await file.readAt(0, message_1.magicLength + 7 & ~7))) {
          return new AsyncRecordBatchFileReader2(new AsyncRecordBatchFileReaderImpl(file));
        }
      }
      return new AsyncRecordBatchStreamReader2(new AsyncRecordBatchStreamReaderImpl(file));
    }
  }
});

// node_modules/apache-arrow/io/whatwg/iterable.js
var require_iterable = __commonJS({
  "node_modules/apache-arrow/io/whatwg/iterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buffer_1 = require_buffer();
    var compat_1 = require_compat();
    function toDOMStream2(source, options) {
      if (compat_1.isAsyncIterable(source)) {
        return asyncIterableAsReadableDOMStream(source, options);
      }
      if (compat_1.isIterable(source)) {
        return iterableAsReadableDOMStream(source, options);
      }
      throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);
    }
    exports.toDOMStream = toDOMStream2;
    function iterableAsReadableDOMStream(source, options) {
      let it = null;
      const bm = options && options.type === "bytes" || false;
      const hwm = options && options.highWaterMark || 2 ** 24;
      return new ReadableStream({
        ...options,
        start(controller) {
          next(controller, it || (it = source[Symbol.iterator]()));
        },
        pull(controller) {
          it ? next(controller, it) : controller.close();
        },
        cancel() {
          (it && (it.return && it.return()) || true) && (it = null);
        }
      }, { highWaterMark: bm ? hwm : void 0, ...options });
      function next(controller, it2) {
        let buf;
        let r = null;
        let size = controller.desiredSize || null;
        while (!(r = it2.next(bm ? size : null)).done) {
          if (ArrayBuffer.isView(r.value) && (buf = buffer_1.toUint8Array(r.value))) {
            size != null && bm && (size = size - buf.byteLength + 1);
            r.value = buf;
          }
          controller.enqueue(r.value);
          if (size != null && --size <= 0) {
            return;
          }
        }
        controller.close();
      }
    }
    function asyncIterableAsReadableDOMStream(source, options) {
      let it = null;
      const bm = options && options.type === "bytes" || false;
      const hwm = options && options.highWaterMark || 2 ** 24;
      return new ReadableStream({
        ...options,
        async start(controller) {
          await next(controller, it || (it = source[Symbol.asyncIterator]()));
        },
        async pull(controller) {
          it ? await next(controller, it) : controller.close();
        },
        async cancel() {
          (it && (it.return && await it.return()) || true) && (it = null);
        }
      }, { highWaterMark: bm ? hwm : void 0, ...options });
      async function next(controller, it2) {
        let buf;
        let r = null;
        let size = controller.desiredSize || null;
        while (!(r = await it2.next(bm ? size : null)).done) {
          if (ArrayBuffer.isView(r.value) && (buf = buffer_1.toUint8Array(r.value))) {
            size != null && bm && (size = size - buf.byteLength + 1);
            r.value = buf;
          }
          controller.enqueue(r.value);
          if (size != null && --size <= 0) {
            return;
          }
        }
        controller.close();
      }
    }
  }
});

// node_modules/apache-arrow/io/whatwg/builder.js
var require_builder3 = __commonJS({
  "node_modules/apache-arrow/io/whatwg/builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_1 = require_builder2();
    function builderThroughDOMStream2(options) {
      return new BuilderTransform(options);
    }
    exports.builderThroughDOMStream = builderThroughDOMStream2;
    var BuilderTransform = class {
      constructor(options) {
        this._numChunks = 0;
        this._finished = false;
        this._bufferedSize = 0;
        const { ["readableStrategy"]: readableStrategy, ["writableStrategy"]: writableStrategy, ["queueingStrategy"]: queueingStrategy = "count", ...builderOptions } = options;
        this._controller = null;
        this._builder = index_1.Builder.new(builderOptions);
        this._getSize = queueingStrategy !== "bytes" ? chunkLength : chunkByteLength;
        const { ["highWaterMark"]: readableHighWaterMark = queueingStrategy === "bytes" ? 2 ** 14 : 1e3 } = { ...readableStrategy };
        const { ["highWaterMark"]: writableHighWaterMark = queueingStrategy === "bytes" ? 2 ** 14 : 1e3 } = { ...writableStrategy };
        this["readable"] = new ReadableStream({
          ["cancel"]: () => {
            this._builder.clear();
          },
          ["pull"]: (c) => {
            this._maybeFlush(this._builder, this._controller = c);
          },
          ["start"]: (c) => {
            this._maybeFlush(this._builder, this._controller = c);
          }
        }, {
          "highWaterMark": readableHighWaterMark,
          "size": queueingStrategy !== "bytes" ? chunkLength : chunkByteLength
        });
        this["writable"] = new WritableStream({
          ["abort"]: () => {
            this._builder.clear();
          },
          ["write"]: () => {
            this._maybeFlush(this._builder, this._controller);
          },
          ["close"]: () => {
            this._maybeFlush(this._builder.finish(), this._controller);
          }
        }, {
          "highWaterMark": writableHighWaterMark,
          "size": (value) => this._writeValueAndReturnChunkSize(value)
        });
      }
      _writeValueAndReturnChunkSize(value) {
        const bufferedSize = this._bufferedSize;
        this._bufferedSize = this._getSize(this._builder.append(value));
        return this._bufferedSize - bufferedSize;
      }
      _maybeFlush(builder, controller) {
        if (controller === null) {
          return;
        }
        if (this._bufferedSize >= controller.desiredSize) {
          ++this._numChunks && this._enqueue(controller, builder.toVector());
        }
        if (builder.finished) {
          if (builder.length > 0 || this._numChunks === 0) {
            ++this._numChunks && this._enqueue(controller, builder.toVector());
          }
          if (!this._finished && (this._finished = true)) {
            this._enqueue(controller, null);
          }
        }
      }
      _enqueue(controller, chunk) {
        this._bufferedSize = 0;
        this._controller = null;
        chunk === null ? controller.close() : controller.enqueue(chunk);
      }
    };
    exports.BuilderTransform = BuilderTransform;
    var chunkLength = (chunk) => chunk.length;
    var chunkByteLength = (chunk) => chunk.byteLength;
  }
});

// node_modules/apache-arrow/io/whatwg/reader.js
var require_reader2 = __commonJS({
  "node_modules/apache-arrow/io/whatwg/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require_stream();
    var reader_1 = require_reader();
    function recordBatchReaderThroughDOMStream2(writableStrategy, readableStrategy) {
      const queue = new stream_1.AsyncByteQueue();
      let reader = null;
      const readable = new ReadableStream({
        async cancel() {
          await queue.close();
        },
        async start(controller) {
          await next(controller, reader || (reader = await open()));
        },
        async pull(controller) {
          reader ? await next(controller, reader) : controller.close();
        }
      });
      return { writable: new WritableStream(queue, { "highWaterMark": 2 ** 14, ...writableStrategy }), readable };
      async function open() {
        return await (await reader_1.RecordBatchReader.from(queue)).open(readableStrategy);
      }
      async function next(controller, reader2) {
        let size = controller.desiredSize;
        let r = null;
        while (!(r = await reader2.next()).done) {
          controller.enqueue(r.value);
          if (size != null && --size <= 0) {
            return;
          }
        }
        controller.close();
      }
    }
    exports.recordBatchReaderThroughDOMStream = recordBatchReaderThroughDOMStream2;
  }
});

// node_modules/apache-arrow/io/whatwg/writer.js
var require_writer2 = __commonJS({
  "node_modules/apache-arrow/io/whatwg/writer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require_stream();
    function recordBatchWriterThroughDOMStream2(writableStrategy, readableStrategy) {
      const writer = new this(writableStrategy);
      const reader = new stream_1.AsyncByteStream(writer);
      const readable = new ReadableStream({
        type: "bytes",
        async cancel() {
          await reader.cancel();
        },
        async pull(controller) {
          await next(controller);
        },
        async start(controller) {
          await next(controller);
        }
      }, { "highWaterMark": 2 ** 14, ...readableStrategy });
      return { writable: new WritableStream(writer, writableStrategy), readable };
      async function next(controller) {
        let buf = null;
        let size = controller.desiredSize;
        while (buf = await reader.read(size || null)) {
          controller.enqueue(buf);
          if (size != null && (size -= buf.byteLength) <= 0) {
            return;
          }
        }
        controller.close();
      }
    }
    exports.recordBatchWriterThroughDOMStream = recordBatchWriterThroughDOMStream2;
  }
});

// node_modules/apache-arrow/compute/predicate.js
var require_predicate = __commonJS({
  "node_modules/apache-arrow/compute/predicate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dictionary_1 = require_dictionary2();
    var Value = class {
      eq(other) {
        if (!(other instanceof Value)) {
          other = new Literal(other);
        }
        return new Equals(this, other);
      }
      le(other) {
        if (!(other instanceof Value)) {
          other = new Literal(other);
        }
        return new LTeq(this, other);
      }
      ge(other) {
        if (!(other instanceof Value)) {
          other = new Literal(other);
        }
        return new GTeq(this, other);
      }
      lt(other) {
        return new Not(this.ge(other));
      }
      gt(other) {
        return new Not(this.le(other));
      }
      ne(other) {
        return new Not(this.eq(other));
      }
    };
    exports.Value = Value;
    var Literal = class extends Value {
      constructor(v) {
        super();
        this.v = v;
      }
    };
    exports.Literal = Literal;
    var Col = class extends Value {
      constructor(name) {
        super();
        this.name = name;
      }
      bind(batch) {
        if (!this.colidx) {
          this.colidx = -1;
          const fields = batch.schema.fields;
          for (let idx = -1; ++idx < fields.length; ) {
            if (fields[idx].name === this.name) {
              this.colidx = idx;
              break;
            }
          }
          if (this.colidx < 0) {
            throw new Error(`Failed to bind Col "${this.name}"`);
          }
        }
        const vec = this.vector = batch.getChildAt(this.colidx);
        return (idx) => vec.get(idx);
      }
    };
    exports.Col = Col;
    var Predicate = class {
      and(...expr) {
        return new And(this, ...expr);
      }
      or(...expr) {
        return new Or(this, ...expr);
      }
      not() {
        return new Not(this);
      }
    };
    exports.Predicate = Predicate;
    var ComparisonPredicate = class extends Predicate {
      constructor(left, right) {
        super();
        this.left = left;
        this.right = right;
      }
      bind(batch) {
        if (this.left instanceof Literal) {
          if (this.right instanceof Literal) {
            return this._bindLitLit(batch, this.left, this.right);
          } else {
            return this._bindLitCol(batch, this.left, this.right);
          }
        } else {
          if (this.right instanceof Literal) {
            return this._bindColLit(batch, this.left, this.right);
          } else {
            return this._bindColCol(batch, this.left, this.right);
          }
        }
      }
    };
    exports.ComparisonPredicate = ComparisonPredicate;
    var CombinationPredicate = class extends Predicate {
      constructor(...children) {
        super();
        this.children = children;
      }
    };
    exports.CombinationPredicate = CombinationPredicate;
    CombinationPredicate.prototype.children = Object.freeze([]);
    var And = class extends CombinationPredicate {
      constructor(...children) {
        children = children.reduce((accum, p) => {
          return accum.concat(p instanceof And ? p.children : p);
        }, []);
        super(...children);
      }
      bind(batch) {
        const bound = this.children.map((p) => p.bind(batch));
        return (idx, batch2) => bound.every((p) => p(idx, batch2));
      }
    };
    exports.And = And;
    var Or = class extends CombinationPredicate {
      constructor(...children) {
        children = children.reduce((accum, p) => {
          return accum.concat(p instanceof Or ? p.children : p);
        }, []);
        super(...children);
      }
      bind(batch) {
        const bound = this.children.map((p) => p.bind(batch));
        return (idx, batch2) => bound.some((p) => p(idx, batch2));
      }
    };
    exports.Or = Or;
    var Equals = class extends ComparisonPredicate {
      _bindLitLit(_batch, left, right) {
        const rtrn = left.v == right.v;
        return () => rtrn;
      }
      _bindColCol(batch, left, right) {
        const left_func = left.bind(batch);
        const right_func = right.bind(batch);
        return (idx, batch2) => left_func(idx, batch2) == right_func(idx, batch2);
      }
      _bindColLit(batch, col2, lit2) {
        const col_func = col2.bind(batch);
        if (col2.vector instanceof dictionary_1.DictionaryVector) {
          let key;
          const vector = col2.vector;
          if (vector.dictionary !== this.lastDictionary) {
            key = vector.reverseLookup(lit2.v);
            this.lastDictionary = vector.dictionary;
            this.lastKey = key;
          } else {
            key = this.lastKey;
          }
          if (key === -1) {
            return () => false;
          } else {
            return (idx) => {
              return vector.getKey(idx) === key;
            };
          }
        } else {
          return (idx, cols) => col_func(idx, cols) == lit2.v;
        }
      }
      _bindLitCol(batch, lit2, col2) {
        return this._bindColLit(batch, col2, lit2);
      }
    };
    exports.Equals = Equals;
    var LTeq = class extends ComparisonPredicate {
      _bindLitLit(_batch, left, right) {
        const rtrn = left.v <= right.v;
        return () => rtrn;
      }
      _bindColCol(batch, left, right) {
        const left_func = left.bind(batch);
        const right_func = right.bind(batch);
        return (idx, cols) => left_func(idx, cols) <= right_func(idx, cols);
      }
      _bindColLit(batch, col2, lit2) {
        const col_func = col2.bind(batch);
        return (idx, cols) => col_func(idx, cols) <= lit2.v;
      }
      _bindLitCol(batch, lit2, col2) {
        const col_func = col2.bind(batch);
        return (idx, cols) => lit2.v <= col_func(idx, cols);
      }
    };
    exports.LTeq = LTeq;
    var GTeq = class extends ComparisonPredicate {
      _bindLitLit(_batch, left, right) {
        const rtrn = left.v >= right.v;
        return () => rtrn;
      }
      _bindColCol(batch, left, right) {
        const left_func = left.bind(batch);
        const right_func = right.bind(batch);
        return (idx, cols) => left_func(idx, cols) >= right_func(idx, cols);
      }
      _bindColLit(batch, col2, lit2) {
        const col_func = col2.bind(batch);
        return (idx, cols) => col_func(idx, cols) >= lit2.v;
      }
      _bindLitCol(batch, lit2, col2) {
        const col_func = col2.bind(batch);
        return (idx, cols) => lit2.v >= col_func(idx, cols);
      }
    };
    exports.GTeq = GTeq;
    var Not = class extends Predicate {
      constructor(child) {
        super();
        this.child = child;
      }
      bind(batch) {
        const func = this.child.bind(batch);
        return (idx, batch2) => !func(idx, batch2);
      }
    };
    exports.Not = Not;
    var CustomPredicate = class extends Predicate {
      constructor(next, bind_) {
        super();
        this.next = next;
        this.bind_ = bind_;
      }
      bind(batch) {
        this.bind_(batch);
        return this.next;
      }
    };
    exports.CustomPredicate = CustomPredicate;
    function lit(v) {
      return new Literal(v);
    }
    exports.lit = lit;
    function col(n) {
      return new Col(n);
    }
    exports.col = col;
    function and(...p) {
      return new And(...p);
    }
    exports.and = and;
    function or(...p) {
      return new Or(...p);
    }
    exports.or = or;
    function custom(next, bind) {
      return new CustomPredicate(next, bind);
    }
    exports.custom = custom;
  }
});

// node_modules/apache-arrow/compute/dataframe.js
var require_dataframe = __commonJS({
  "node_modules/apache-arrow/compute/dataframe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var table_1 = require_table();
    var int_1 = require_int3();
    var schema_1 = require_schema();
    var predicate_1 = require_predicate();
    var recordbatch_1 = require_recordbatch2();
    var type_1 = require_type();
    table_1.Table.prototype.countBy = function(name) {
      return new DataFrame2(this.chunks).countBy(name);
    };
    table_1.Table.prototype.scan = function(next, bind) {
      return new DataFrame2(this.chunks).scan(next, bind);
    };
    table_1.Table.prototype.scanReverse = function(next, bind) {
      return new DataFrame2(this.chunks).scanReverse(next, bind);
    };
    table_1.Table.prototype.filter = function(predicate2) {
      return new DataFrame2(this.chunks).filter(predicate2);
    };
    var DataFrame2 = class extends table_1.Table {
      filter(predicate2) {
        return new FilteredDataFrame2(this.chunks, predicate2);
      }
      scan(next, bind) {
        const batches = this.chunks, numBatches = batches.length;
        for (let batchIndex = -1; ++batchIndex < numBatches; ) {
          const batch = batches[batchIndex];
          if (bind) {
            bind(batch);
          }
          for (let index = -1, numRows = batch.length; ++index < numRows; ) {
            next(index, batch);
          }
        }
      }
      scanReverse(next, bind) {
        const batches = this.chunks, numBatches = batches.length;
        for (let batchIndex = numBatches; --batchIndex >= 0; ) {
          const batch = batches[batchIndex];
          if (bind) {
            bind(batch);
          }
          for (let index = batch.length; --index >= 0; ) {
            next(index, batch);
          }
        }
      }
      countBy(name) {
        const batches = this.chunks, numBatches = batches.length;
        const count_by = typeof name === "string" ? new predicate_1.Col(name) : name;
        count_by.bind(batches[numBatches - 1]);
        const vector = count_by.vector;
        if (!type_1.DataType.isDictionary(vector.type)) {
          throw new Error("countBy currently only supports dictionary-encoded columns");
        }
        const countByteLength = Math.ceil(Math.log(vector.length) / Math.log(256));
        const CountsArrayType = countByteLength == 4 ? Uint32Array : countByteLength >= 2 ? Uint16Array : Uint8Array;
        const counts = new CountsArrayType(vector.dictionary.length);
        for (let batchIndex = -1; ++batchIndex < numBatches; ) {
          const batch = batches[batchIndex];
          count_by.bind(batch);
          const keys = count_by.vector.indices;
          for (let index = -1, numRows = batch.length; ++index < numRows; ) {
            let key = keys.get(index);
            if (key !== null) {
              counts[key]++;
            }
          }
        }
        return new CountByResult2(vector.dictionary, int_1.IntVector.from(counts));
      }
    };
    exports.DataFrame = DataFrame2;
    var CountByResult2 = class extends table_1.Table {
      constructor(values, counts) {
        const schema = new schema_1.Schema([
          new schema_1.Field("values", values.type),
          new schema_1.Field("counts", counts.type)
        ]);
        super(new recordbatch_1.RecordBatch(schema, counts.length, [values, counts]));
      }
      toJSON() {
        const values = this.getColumnAt(0);
        const counts = this.getColumnAt(1);
        const result = {};
        for (let i = -1; ++i < this.length; ) {
          result[values.get(i)] = counts.get(i);
        }
        return result;
      }
    };
    exports.CountByResult = CountByResult2;
    var FilteredDataFrame2 = class extends DataFrame2 {
      constructor(batches, predicate2) {
        super(batches);
        this._predicate = predicate2;
      }
      scan(next, bind) {
        const batches = this._chunks;
        const numBatches = batches.length;
        for (let batchIndex = -1; ++batchIndex < numBatches; ) {
          const batch = batches[batchIndex];
          const predicate2 = this._predicate.bind(batch);
          let isBound = false;
          for (let index = -1, numRows = batch.length; ++index < numRows; ) {
            if (predicate2(index, batch)) {
              if (bind && !isBound) {
                bind(batch);
                isBound = true;
              }
              next(index, batch);
            }
          }
        }
      }
      scanReverse(next, bind) {
        const batches = this._chunks;
        const numBatches = batches.length;
        for (let batchIndex = numBatches; --batchIndex >= 0; ) {
          const batch = batches[batchIndex];
          const predicate2 = this._predicate.bind(batch);
          let isBound = false;
          for (let index = batch.length; --index >= 0; ) {
            if (predicate2(index, batch)) {
              if (bind && !isBound) {
                bind(batch);
                isBound = true;
              }
              next(index, batch);
            }
          }
        }
      }
      count() {
        let sum = 0;
        const batches = this._chunks;
        const numBatches = batches.length;
        for (let batchIndex = -1; ++batchIndex < numBatches; ) {
          const batch = batches[batchIndex];
          const predicate2 = this._predicate.bind(batch);
          for (let index = -1, numRows = batch.length; ++index < numRows; ) {
            if (predicate2(index, batch)) {
              ++sum;
            }
          }
        }
        return sum;
      }
      *[Symbol.iterator]() {
        const batches = this._chunks;
        const numBatches = batches.length;
        for (let batchIndex = -1; ++batchIndex < numBatches; ) {
          const batch = batches[batchIndex];
          const predicate2 = this._predicate.bind(batch);
          for (let index = -1, numRows = batch.length; ++index < numRows; ) {
            if (predicate2(index, batch)) {
              yield batch.get(index);
            }
          }
        }
      }
      filter(predicate2) {
        return new FilteredDataFrame2(this._chunks, this._predicate.and(predicate2));
      }
      countBy(name) {
        const batches = this._chunks, numBatches = batches.length;
        const count_by = typeof name === "string" ? new predicate_1.Col(name) : name;
        count_by.bind(batches[numBatches - 1]);
        const vector = count_by.vector;
        if (!type_1.DataType.isDictionary(vector.type)) {
          throw new Error("countBy currently only supports dictionary-encoded columns");
        }
        const countByteLength = Math.ceil(Math.log(vector.length) / Math.log(256));
        const CountsArrayType = countByteLength == 4 ? Uint32Array : countByteLength >= 2 ? Uint16Array : Uint8Array;
        const counts = new CountsArrayType(vector.dictionary.length);
        for (let batchIndex = -1; ++batchIndex < numBatches; ) {
          const batch = batches[batchIndex];
          const predicate2 = this._predicate.bind(batch);
          count_by.bind(batch);
          const keys = count_by.vector.indices;
          for (let index = -1, numRows = batch.length; ++index < numRows; ) {
            let key = keys.get(index);
            if (key !== null && predicate2(index, batch)) {
              counts[key]++;
            }
          }
        }
        return new CountByResult2(vector.dictionary, int_1.IntVector.from(counts));
      }
    };
    exports.FilteredDataFrame = FilteredDataFrame2;
  }
});

// node_modules/apache-arrow/Arrow.js
var require_Arrow = __commonJS({
  "node_modules/apache-arrow/Arrow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var enum_1 = require_enum();
    exports.ArrowType = enum_1.ArrowType;
    exports.DateUnit = enum_1.DateUnit;
    exports.IntervalUnit = enum_1.IntervalUnit;
    exports.MessageHeader = enum_1.MessageHeader;
    exports.MetadataVersion = enum_1.MetadataVersion;
    exports.Precision = enum_1.Precision;
    exports.TimeUnit = enum_1.TimeUnit;
    exports.Type = enum_1.Type;
    exports.UnionMode = enum_1.UnionMode;
    exports.BufferType = enum_1.BufferType;
    var data_1 = require_data();
    exports.Data = data_1.Data;
    var type_1 = require_type();
    exports.DataType = type_1.DataType;
    exports.Null = type_1.Null;
    exports.Bool = type_1.Bool;
    exports.Int = type_1.Int;
    exports.Int8 = type_1.Int8;
    exports.Int16 = type_1.Int16;
    exports.Int32 = type_1.Int32;
    exports.Int64 = type_1.Int64;
    exports.Uint8 = type_1.Uint8;
    exports.Uint16 = type_1.Uint16;
    exports.Uint32 = type_1.Uint32;
    exports.Uint64 = type_1.Uint64;
    exports.Float = type_1.Float;
    exports.Float16 = type_1.Float16;
    exports.Float32 = type_1.Float32;
    exports.Float64 = type_1.Float64;
    exports.Utf8 = type_1.Utf8;
    exports.Binary = type_1.Binary;
    exports.FixedSizeBinary = type_1.FixedSizeBinary;
    exports.Date_ = type_1.Date_;
    exports.DateDay = type_1.DateDay;
    exports.DateMillisecond = type_1.DateMillisecond;
    exports.Timestamp = type_1.Timestamp;
    exports.TimestampSecond = type_1.TimestampSecond;
    exports.TimestampMillisecond = type_1.TimestampMillisecond;
    exports.TimestampMicrosecond = type_1.TimestampMicrosecond;
    exports.TimestampNanosecond = type_1.TimestampNanosecond;
    exports.Time = type_1.Time;
    exports.TimeSecond = type_1.TimeSecond;
    exports.TimeMillisecond = type_1.TimeMillisecond;
    exports.TimeMicrosecond = type_1.TimeMicrosecond;
    exports.TimeNanosecond = type_1.TimeNanosecond;
    exports.Decimal = type_1.Decimal;
    exports.List = type_1.List;
    exports.Struct = type_1.Struct;
    exports.Union = type_1.Union;
    exports.DenseUnion = type_1.DenseUnion;
    exports.SparseUnion = type_1.SparseUnion;
    exports.Dictionary = type_1.Dictionary;
    exports.Interval = type_1.Interval;
    exports.IntervalDayTime = type_1.IntervalDayTime;
    exports.IntervalYearMonth = type_1.IntervalYearMonth;
    exports.FixedSizeList = type_1.FixedSizeList;
    exports.Map_ = type_1.Map_;
    var table_1 = require_table();
    exports.Table = table_1.Table;
    var column_1 = require_column();
    exports.Column = column_1.Column;
    var visitor_1 = require_visitor();
    exports.Visitor = visitor_1.Visitor;
    var schema_1 = require_schema();
    exports.Schema = schema_1.Schema;
    exports.Field = schema_1.Field;
    var index_1 = require_vector3();
    exports.Vector = index_1.Vector;
    exports.BaseVector = index_1.BaseVector;
    exports.BinaryVector = index_1.BinaryVector;
    exports.BoolVector = index_1.BoolVector;
    exports.Chunked = index_1.Chunked;
    exports.DateVector = index_1.DateVector;
    exports.DateDayVector = index_1.DateDayVector;
    exports.DateMillisecondVector = index_1.DateMillisecondVector;
    exports.DecimalVector = index_1.DecimalVector;
    exports.DictionaryVector = index_1.DictionaryVector;
    exports.FixedSizeBinaryVector = index_1.FixedSizeBinaryVector;
    exports.FixedSizeListVector = index_1.FixedSizeListVector;
    exports.FloatVector = index_1.FloatVector;
    exports.Float16Vector = index_1.Float16Vector;
    exports.Float32Vector = index_1.Float32Vector;
    exports.Float64Vector = index_1.Float64Vector;
    exports.IntervalVector = index_1.IntervalVector;
    exports.IntervalDayTimeVector = index_1.IntervalDayTimeVector;
    exports.IntervalYearMonthVector = index_1.IntervalYearMonthVector;
    exports.IntVector = index_1.IntVector;
    exports.Int8Vector = index_1.Int8Vector;
    exports.Int16Vector = index_1.Int16Vector;
    exports.Int32Vector = index_1.Int32Vector;
    exports.Int64Vector = index_1.Int64Vector;
    exports.Uint8Vector = index_1.Uint8Vector;
    exports.Uint16Vector = index_1.Uint16Vector;
    exports.Uint32Vector = index_1.Uint32Vector;
    exports.Uint64Vector = index_1.Uint64Vector;
    exports.ListVector = index_1.ListVector;
    exports.MapVector = index_1.MapVector;
    exports.NullVector = index_1.NullVector;
    exports.StructVector = index_1.StructVector;
    exports.TimestampVector = index_1.TimestampVector;
    exports.TimestampSecondVector = index_1.TimestampSecondVector;
    exports.TimestampMillisecondVector = index_1.TimestampMillisecondVector;
    exports.TimestampMicrosecondVector = index_1.TimestampMicrosecondVector;
    exports.TimestampNanosecondVector = index_1.TimestampNanosecondVector;
    exports.TimeVector = index_1.TimeVector;
    exports.TimeSecondVector = index_1.TimeSecondVector;
    exports.TimeMillisecondVector = index_1.TimeMillisecondVector;
    exports.TimeMicrosecondVector = index_1.TimeMicrosecondVector;
    exports.TimeNanosecondVector = index_1.TimeNanosecondVector;
    exports.UnionVector = index_1.UnionVector;
    exports.DenseUnionVector = index_1.DenseUnionVector;
    exports.SparseUnionVector = index_1.SparseUnionVector;
    exports.Utf8Vector = index_1.Utf8Vector;
    var index_2 = require_builder2();
    exports.Builder = index_2.Builder;
    exports.BinaryBuilder = index_2.BinaryBuilder;
    exports.BoolBuilder = index_2.BoolBuilder;
    exports.DateBuilder = index_2.DateBuilder;
    exports.DateDayBuilder = index_2.DateDayBuilder;
    exports.DateMillisecondBuilder = index_2.DateMillisecondBuilder;
    exports.DecimalBuilder = index_2.DecimalBuilder;
    exports.DictionaryBuilder = index_2.DictionaryBuilder;
    exports.FixedSizeBinaryBuilder = index_2.FixedSizeBinaryBuilder;
    exports.FixedSizeListBuilder = index_2.FixedSizeListBuilder;
    exports.FloatBuilder = index_2.FloatBuilder;
    exports.Float16Builder = index_2.Float16Builder;
    exports.Float32Builder = index_2.Float32Builder;
    exports.Float64Builder = index_2.Float64Builder;
    exports.IntervalBuilder = index_2.IntervalBuilder;
    exports.IntervalDayTimeBuilder = index_2.IntervalDayTimeBuilder;
    exports.IntervalYearMonthBuilder = index_2.IntervalYearMonthBuilder;
    exports.IntBuilder = index_2.IntBuilder;
    exports.Int8Builder = index_2.Int8Builder;
    exports.Int16Builder = index_2.Int16Builder;
    exports.Int32Builder = index_2.Int32Builder;
    exports.Int64Builder = index_2.Int64Builder;
    exports.Uint8Builder = index_2.Uint8Builder;
    exports.Uint16Builder = index_2.Uint16Builder;
    exports.Uint32Builder = index_2.Uint32Builder;
    exports.Uint64Builder = index_2.Uint64Builder;
    exports.ListBuilder = index_2.ListBuilder;
    exports.MapBuilder = index_2.MapBuilder;
    exports.NullBuilder = index_2.NullBuilder;
    exports.StructBuilder = index_2.StructBuilder;
    exports.TimestampBuilder = index_2.TimestampBuilder;
    exports.TimestampSecondBuilder = index_2.TimestampSecondBuilder;
    exports.TimestampMillisecondBuilder = index_2.TimestampMillisecondBuilder;
    exports.TimestampMicrosecondBuilder = index_2.TimestampMicrosecondBuilder;
    exports.TimestampNanosecondBuilder = index_2.TimestampNanosecondBuilder;
    exports.TimeBuilder = index_2.TimeBuilder;
    exports.TimeSecondBuilder = index_2.TimeSecondBuilder;
    exports.TimeMillisecondBuilder = index_2.TimeMillisecondBuilder;
    exports.TimeMicrosecondBuilder = index_2.TimeMicrosecondBuilder;
    exports.TimeNanosecondBuilder = index_2.TimeNanosecondBuilder;
    exports.UnionBuilder = index_2.UnionBuilder;
    exports.DenseUnionBuilder = index_2.DenseUnionBuilder;
    exports.SparseUnionBuilder = index_2.SparseUnionBuilder;
    exports.Utf8Builder = index_2.Utf8Builder;
    var stream_1 = require_stream();
    exports.ByteStream = stream_1.ByteStream;
    exports.AsyncByteStream = stream_1.AsyncByteStream;
    exports.AsyncByteQueue = stream_1.AsyncByteQueue;
    var reader_1 = require_reader();
    exports.RecordBatchReader = reader_1.RecordBatchReader;
    exports.RecordBatchFileReader = reader_1.RecordBatchFileReader;
    exports.RecordBatchStreamReader = reader_1.RecordBatchStreamReader;
    exports.AsyncRecordBatchFileReader = reader_1.AsyncRecordBatchFileReader;
    exports.AsyncRecordBatchStreamReader = reader_1.AsyncRecordBatchStreamReader;
    var writer_1 = require_writer();
    exports.RecordBatchWriter = writer_1.RecordBatchWriter;
    exports.RecordBatchFileWriter = writer_1.RecordBatchFileWriter;
    exports.RecordBatchStreamWriter = writer_1.RecordBatchStreamWriter;
    exports.RecordBatchJSONWriter = writer_1.RecordBatchJSONWriter;
    var message_1 = require_message2();
    exports.MessageReader = message_1.MessageReader;
    exports.AsyncMessageReader = message_1.AsyncMessageReader;
    exports.JSONMessageReader = message_1.JSONMessageReader;
    var message_2 = require_message();
    exports.Message = message_2.Message;
    var recordbatch_1 = require_recordbatch2();
    exports.RecordBatch = recordbatch_1.RecordBatch;
    var dataframe_1 = require_dataframe();
    exports.DataFrame = dataframe_1.DataFrame;
    exports.FilteredDataFrame = dataframe_1.FilteredDataFrame;
    exports.CountByResult = dataframe_1.CountByResult;
    var util_bn_ = require_bn();
    var util_int_ = require_int2();
    var util_bit_ = require_bit();
    var util_math_ = require_math();
    var util_buffer_ = require_buffer();
    var util_vector_ = require_vector2();
    var predicate2 = require_predicate();
    exports.predicate = predicate2;
    exports.util = {
      ...util_bn_,
      ...util_int_,
      ...util_bit_,
      ...util_math_,
      ...util_buffer_,
      ...util_vector_
    };
  }
});

// node_modules/streamlit-component-lib/dist/StreamlitReact.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var import_react = __toESM(require_react());

// node_modules/event-target-shim/dist/event-target-shim.mjs
var privateData = /* @__PURE__ */ new WeakMap();
var wrappers = /* @__PURE__ */ new WeakMap();
function pd(event) {
  const retv = privateData.get(event);
  console.assert(
    retv != null,
    "'this' is expected an Event object, but got",
    event
  );
  return retv;
}
function setCancelFlag(data) {
  if (data.passiveListener != null) {
    if (typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "Unable to preventDefault inside passive event listener invocation.",
        data.passiveListener
      );
    }
    return;
  }
  if (!data.event.cancelable) {
    return;
  }
  data.canceled = true;
  if (typeof data.event.preventDefault === "function") {
    data.event.preventDefault();
  }
}
function Event(eventTarget, event) {
  privateData.set(this, {
    eventTarget,
    event,
    eventPhase: 2,
    currentTarget: eventTarget,
    canceled: false,
    stopped: false,
    immediateStopped: false,
    passiveListener: null,
    timeStamp: event.timeStamp || Date.now()
  });
  Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
  const keys = Object.keys(event);
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i];
    if (!(key in this)) {
      Object.defineProperty(this, key, defineRedirectDescriptor(key));
    }
  }
}
Event.prototype = {
  get type() {
    return pd(this).event.type;
  },
  get target() {
    return pd(this).eventTarget;
  },
  get currentTarget() {
    return pd(this).currentTarget;
  },
  composedPath() {
    const currentTarget = pd(this).currentTarget;
    if (currentTarget == null) {
      return [];
    }
    return [currentTarget];
  },
  get NONE() {
    return 0;
  },
  get CAPTURING_PHASE() {
    return 1;
  },
  get AT_TARGET() {
    return 2;
  },
  get BUBBLING_PHASE() {
    return 3;
  },
  get eventPhase() {
    return pd(this).eventPhase;
  },
  stopPropagation() {
    const data = pd(this);
    data.stopped = true;
    if (typeof data.event.stopPropagation === "function") {
      data.event.stopPropagation();
    }
  },
  stopImmediatePropagation() {
    const data = pd(this);
    data.stopped = true;
    data.immediateStopped = true;
    if (typeof data.event.stopImmediatePropagation === "function") {
      data.event.stopImmediatePropagation();
    }
  },
  get bubbles() {
    return Boolean(pd(this).event.bubbles);
  },
  get cancelable() {
    return Boolean(pd(this).event.cancelable);
  },
  preventDefault() {
    setCancelFlag(pd(this));
  },
  get defaultPrevented() {
    return pd(this).canceled;
  },
  get composed() {
    return Boolean(pd(this).event.composed);
  },
  get timeStamp() {
    return pd(this).timeStamp;
  },
  get srcElement() {
    return pd(this).eventTarget;
  },
  get cancelBubble() {
    return pd(this).stopped;
  },
  set cancelBubble(value) {
    if (!value) {
      return;
    }
    const data = pd(this);
    data.stopped = true;
    if (typeof data.event.cancelBubble === "boolean") {
      data.event.cancelBubble = true;
    }
  },
  get returnValue() {
    return !pd(this).canceled;
  },
  set returnValue(value) {
    if (!value) {
      setCancelFlag(pd(this));
    }
  },
  initEvent() {
  }
};
Object.defineProperty(Event.prototype, "constructor", {
  value: Event,
  configurable: true,
  writable: true
});
if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
  Object.setPrototypeOf(Event.prototype, window.Event.prototype);
  wrappers.set(window.Event.prototype, Event);
}
function defineRedirectDescriptor(key) {
  return {
    get() {
      return pd(this).event[key];
    },
    set(value) {
      pd(this).event[key] = value;
    },
    configurable: true,
    enumerable: true
  };
}
function defineCallDescriptor(key) {
  return {
    value() {
      const event = pd(this).event;
      return event[key].apply(event, arguments);
    },
    configurable: true,
    enumerable: true
  };
}
function defineWrapper(BaseEvent, proto) {
  const keys = Object.keys(proto);
  if (keys.length === 0) {
    return BaseEvent;
  }
  function CustomEvent2(eventTarget, event) {
    BaseEvent.call(this, eventTarget, event);
  }
  CustomEvent2.prototype = Object.create(BaseEvent.prototype, {
    constructor: { value: CustomEvent2, configurable: true, writable: true }
  });
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i];
    if (!(key in BaseEvent.prototype)) {
      const descriptor = Object.getOwnPropertyDescriptor(proto, key);
      const isFunc = typeof descriptor.value === "function";
      Object.defineProperty(
        CustomEvent2.prototype,
        key,
        isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)
      );
    }
  }
  return CustomEvent2;
}
function getWrapper(proto) {
  if (proto == null || proto === Object.prototype) {
    return Event;
  }
  let wrapper = wrappers.get(proto);
  if (wrapper == null) {
    wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
    wrappers.set(proto, wrapper);
  }
  return wrapper;
}
function wrapEvent(eventTarget, event) {
  const Wrapper = getWrapper(Object.getPrototypeOf(event));
  return new Wrapper(eventTarget, event);
}
function isStopped(event) {
  return pd(event).immediateStopped;
}
function setEventPhase(event, eventPhase) {
  pd(event).eventPhase = eventPhase;
}
function setCurrentTarget(event, currentTarget) {
  pd(event).currentTarget = currentTarget;
}
function setPassiveListener(event, passiveListener) {
  pd(event).passiveListener = passiveListener;
}
var listenersMap = /* @__PURE__ */ new WeakMap();
var CAPTURE = 1;
var BUBBLE = 2;
var ATTRIBUTE = 3;
function isObject(x) {
  return x !== null && typeof x === "object";
}
function getListeners(eventTarget) {
  const listeners = listenersMap.get(eventTarget);
  if (listeners == null) {
    throw new TypeError(
      "'this' is expected an EventTarget object, but got another value."
    );
  }
  return listeners;
}
function defineEventAttributeDescriptor(eventName) {
  return {
    get() {
      const listeners = getListeners(this);
      let node = listeners.get(eventName);
      while (node != null) {
        if (node.listenerType === ATTRIBUTE) {
          return node.listener;
        }
        node = node.next;
      }
      return null;
    },
    set(listener) {
      if (typeof listener !== "function" && !isObject(listener)) {
        listener = null;
      }
      const listeners = getListeners(this);
      let prev = null;
      let node = listeners.get(eventName);
      while (node != null) {
        if (node.listenerType === ATTRIBUTE) {
          if (prev !== null) {
            prev.next = node.next;
          } else if (node.next !== null) {
            listeners.set(eventName, node.next);
          } else {
            listeners.delete(eventName);
          }
        } else {
          prev = node;
        }
        node = node.next;
      }
      if (listener !== null) {
        const newNode = {
          listener,
          listenerType: ATTRIBUTE,
          passive: false,
          once: false,
          next: null
        };
        if (prev === null) {
          listeners.set(eventName, newNode);
        } else {
          prev.next = newNode;
        }
      }
    },
    configurable: true,
    enumerable: true
  };
}
function defineEventAttribute(eventTargetPrototype, eventName) {
  Object.defineProperty(
    eventTargetPrototype,
    `on${eventName}`,
    defineEventAttributeDescriptor(eventName)
  );
}
function defineCustomEventTarget(eventNames) {
  function CustomEventTarget() {
    EventTarget.call(this);
  }
  CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
    constructor: {
      value: CustomEventTarget,
      configurable: true,
      writable: true
    }
  });
  for (let i = 0; i < eventNames.length; ++i) {
    defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
  }
  return CustomEventTarget;
}
function EventTarget() {
  if (this instanceof EventTarget) {
    listenersMap.set(this, /* @__PURE__ */ new Map());
    return;
  }
  if (arguments.length === 1 && Array.isArray(arguments[0])) {
    return defineCustomEventTarget(arguments[0]);
  }
  if (arguments.length > 0) {
    const types = new Array(arguments.length);
    for (let i = 0; i < arguments.length; ++i) {
      types[i] = arguments[i];
    }
    return defineCustomEventTarget(types);
  }
  throw new TypeError("Cannot call a class as a function");
}
EventTarget.prototype = {
  addEventListener(eventName, listener, options) {
    if (listener == null) {
      return;
    }
    if (typeof listener !== "function" && !isObject(listener)) {
      throw new TypeError("'listener' should be a function or an object.");
    }
    const listeners = getListeners(this);
    const optionsIsObj = isObject(options);
    const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options);
    const listenerType = capture ? CAPTURE : BUBBLE;
    const newNode = {
      listener,
      listenerType,
      passive: optionsIsObj && Boolean(options.passive),
      once: optionsIsObj && Boolean(options.once),
      next: null
    };
    let node = listeners.get(eventName);
    if (node === void 0) {
      listeners.set(eventName, newNode);
      return;
    }
    let prev = null;
    while (node != null) {
      if (node.listener === listener && node.listenerType === listenerType) {
        return;
      }
      prev = node;
      node = node.next;
    }
    prev.next = newNode;
  },
  removeEventListener(eventName, listener, options) {
    if (listener == null) {
      return;
    }
    const listeners = getListeners(this);
    const capture = isObject(options) ? Boolean(options.capture) : Boolean(options);
    const listenerType = capture ? CAPTURE : BUBBLE;
    let prev = null;
    let node = listeners.get(eventName);
    while (node != null) {
      if (node.listener === listener && node.listenerType === listenerType) {
        if (prev !== null) {
          prev.next = node.next;
        } else if (node.next !== null) {
          listeners.set(eventName, node.next);
        } else {
          listeners.delete(eventName);
        }
        return;
      }
      prev = node;
      node = node.next;
    }
  },
  dispatchEvent(event) {
    if (event == null || typeof event.type !== "string") {
      throw new TypeError('"event.type" should be a string.');
    }
    const listeners = getListeners(this);
    const eventName = event.type;
    let node = listeners.get(eventName);
    if (node == null) {
      return true;
    }
    const wrappedEvent = wrapEvent(this, event);
    let prev = null;
    while (node != null) {
      if (node.once) {
        if (prev !== null) {
          prev.next = node.next;
        } else if (node.next !== null) {
          listeners.set(eventName, node.next);
        } else {
          listeners.delete(eventName);
        }
      } else {
        prev = node;
      }
      setPassiveListener(
        wrappedEvent,
        node.passive ? node.listener : null
      );
      if (typeof node.listener === "function") {
        try {
          node.listener.call(this, wrappedEvent);
        } catch (err) {
          if (typeof console !== "undefined" && typeof console.error === "function") {
            console.error(err);
          }
        }
      } else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function") {
        node.listener.handleEvent(wrappedEvent);
      }
      if (isStopped(wrappedEvent)) {
        break;
      }
      node = node.next;
    }
    setPassiveListener(wrappedEvent, null);
    setEventPhase(wrappedEvent, 0);
    setCurrentTarget(wrappedEvent, null);
    return !wrappedEvent.defaultPrevented;
  }
};
Object.defineProperty(EventTarget.prototype, "constructor", {
  value: EventTarget,
  configurable: true,
  writable: true
});
if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined") {
  Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
}

// node_modules/apache-arrow/Arrow.dom.mjs
var import_adapters = __toESM(require_adapters(), 1);
var import_builder = __toESM(require_builder2(), 1);
var import_reader = __toESM(require_reader(), 1);
var import_writer = __toESM(require_writer(), 1);
var import_iterable = __toESM(require_iterable(), 1);
var import_builder2 = __toESM(require_builder3(), 1);
var import_reader2 = __toESM(require_reader2(), 1);
var import_writer2 = __toESM(require_writer2(), 1);
var import_Arrow = __toESM(require_Arrow(), 1);
import_adapters.default.toDOMStream = import_iterable.toDOMStream;
import_builder.Builder["throughDOM"] = import_builder2.builderThroughDOMStream;
import_reader.RecordBatchReader["throughDOM"] = import_reader2.recordBatchReaderThroughDOMStream;
import_writer.RecordBatchWriter["throughDOM"] = import_writer2.recordBatchWriterThroughDOMStream;

// node_modules/streamlit-component-lib/dist/ArrowTable.js
var ArrowTable = function() {
  function ArrowTable2(dataBuffer, indexBuffer, columnsBuffer, styler) {
    var _this = this;
    this.getCell = function(rowIndex, columnIndex) {
      var isBlankCell = rowIndex < _this.headerRows && columnIndex < _this.headerColumns;
      var isIndexCell = rowIndex >= _this.headerRows && columnIndex < _this.headerColumns;
      var isColumnsCell = rowIndex < _this.headerRows && columnIndex >= _this.headerColumns;
      if (isBlankCell) {
        var classNames = ["blank"];
        if (columnIndex > 0) {
          classNames.push("level" + rowIndex);
        }
        return {
          type: "blank",
          classNames: classNames.join(" "),
          content: ""
        };
      } else if (isColumnsCell) {
        var dataColumnIndex = columnIndex - _this.headerColumns;
        var classNames = [
          "col_heading",
          "level" + rowIndex,
          "col" + dataColumnIndex
        ];
        return {
          type: "columns",
          classNames: classNames.join(" "),
          content: _this.getContent(_this.columnsTable, dataColumnIndex, rowIndex)
        };
      } else if (isIndexCell) {
        var dataRowIndex = rowIndex - _this.headerRows;
        var classNames = [
          "row_heading",
          "level" + columnIndex,
          "row" + dataRowIndex
        ];
        return {
          type: "index",
          id: "T_" + _this.uuid + "level" + columnIndex + "_row" + dataRowIndex,
          classNames: classNames.join(" "),
          content: _this.getContent(_this.indexTable, dataRowIndex, columnIndex)
        };
      } else {
        var dataRowIndex = rowIndex - _this.headerRows;
        var dataColumnIndex = columnIndex - _this.headerColumns;
        var classNames = [
          "data",
          "row" + dataRowIndex,
          "col" + dataColumnIndex
        ];
        var content = _this.styler ? _this.getContent(_this.styler.displayValuesTable, dataRowIndex, dataColumnIndex) : _this.getContent(_this.dataTable, dataRowIndex, dataColumnIndex);
        return {
          type: "data",
          id: "T_" + _this.uuid + "row" + dataRowIndex + "_col" + dataColumnIndex,
          classNames: classNames.join(" "),
          content
        };
      }
    };
    this.getContent = function(table, rowIndex, columnIndex) {
      var column = table.getColumnAt(columnIndex);
      if (column === null) {
        return "";
      }
      var columnTypeId = _this.getColumnTypeId(table, columnIndex);
      switch (columnTypeId) {
        case import_Arrow.Type.Timestamp: {
          return _this.nanosToDate(column.get(rowIndex));
        }
        default: {
          return column.get(rowIndex);
        }
      }
    };
    this.dataTable = import_Arrow.Table.from(dataBuffer);
    this.indexTable = import_Arrow.Table.from(indexBuffer);
    this.columnsTable = import_Arrow.Table.from(columnsBuffer);
    this.styler = styler ? {
      caption: styler.caption,
      displayValuesTable: import_Arrow.Table.from(styler.displayValues),
      styles: styler.styles,
      uuid: styler.uuid
    } : void 0;
  }
  Object.defineProperty(ArrowTable2.prototype, "rows", {
    get: function() {
      return this.indexTable.length + this.columnsTable.numCols;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ArrowTable2.prototype, "columns", {
    get: function() {
      return this.indexTable.numCols + this.columnsTable.length;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ArrowTable2.prototype, "headerRows", {
    get: function() {
      return this.rows - this.dataRows;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ArrowTable2.prototype, "headerColumns", {
    get: function() {
      return this.columns - this.dataColumns;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ArrowTable2.prototype, "dataRows", {
    get: function() {
      return this.dataTable.length;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ArrowTable2.prototype, "dataColumns", {
    get: function() {
      return this.dataTable.numCols;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ArrowTable2.prototype, "uuid", {
    get: function() {
      return this.styler && this.styler.uuid;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ArrowTable2.prototype, "caption", {
    get: function() {
      return this.styler && this.styler.caption;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ArrowTable2.prototype, "styles", {
    get: function() {
      return this.styler && this.styler.styles;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ArrowTable2.prototype, "table", {
    get: function() {
      return this.dataTable;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ArrowTable2.prototype, "index", {
    get: function() {
      return this.indexTable;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(ArrowTable2.prototype, "columnTable", {
    get: function() {
      return this.columnsTable;
    },
    enumerable: true,
    configurable: true
  });
  ArrowTable2.prototype.serialize = function() {
    return {
      data: this.dataTable.serialize(),
      index: this.indexTable.serialize(),
      columns: this.columnsTable.serialize()
    };
  };
  ArrowTable2.prototype.getColumnTypeId = function(table, columnIndex) {
    return table.schema.fields[columnIndex].type.typeId;
  };
  ArrowTable2.prototype.nanosToDate = function(nanos) {
    return new Date(nanos / 1e6);
  };
  return ArrowTable2;
}();

// node_modules/streamlit-component-lib/dist/streamlit.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var ComponentMessageType;
(function(ComponentMessageType2) {
  ComponentMessageType2["COMPONENT_READY"] = "streamlit:componentReady";
  ComponentMessageType2["SET_COMPONENT_VALUE"] = "streamlit:setComponentValue";
  ComponentMessageType2["SET_FRAME_HEIGHT"] = "streamlit:setFrameHeight";
})(ComponentMessageType || (ComponentMessageType = {}));
var Streamlit = function() {
  function Streamlit2() {
  }
  Streamlit2.API_VERSION = 1;
  Streamlit2.RENDER_EVENT = "streamlit:render";
  Streamlit2.events = new EventTarget();
  Streamlit2.registeredMessageListener = false;
  Streamlit2.setComponentReady = function() {
    if (!Streamlit2.registeredMessageListener) {
      window.addEventListener("message", Streamlit2.onMessageEvent);
      Streamlit2.registeredMessageListener = true;
    }
    Streamlit2.sendBackMsg(ComponentMessageType.COMPONENT_READY, {
      apiVersion: Streamlit2.API_VERSION
    });
  };
  Streamlit2.setFrameHeight = function(height) {
    if (height === void 0) {
      height = document.body.scrollHeight;
    }
    if (height === Streamlit2.lastFrameHeight) {
      return;
    }
    Streamlit2.lastFrameHeight = height;
    Streamlit2.sendBackMsg(ComponentMessageType.SET_FRAME_HEIGHT, { height });
  };
  Streamlit2.setComponentValue = function(value) {
    var dataType;
    if (value instanceof ArrowTable) {
      dataType = "dataframe";
      value = value.serialize();
    } else if (isTypedArray(value)) {
      dataType = "bytes";
      value = new Uint8Array(value.buffer);
    } else if (value instanceof ArrayBuffer) {
      dataType = "bytes";
      value = new Uint8Array(value);
    } else {
      dataType = "json";
    }
    Streamlit2.sendBackMsg(ComponentMessageType.SET_COMPONENT_VALUE, {
      value,
      dataType
    });
  };
  Streamlit2.onMessageEvent = function(event) {
    var type = event.data["type"];
    switch (type) {
      case Streamlit2.RENDER_EVENT:
        Streamlit2.onRenderMessage(event.data);
        break;
    }
  };
  Streamlit2.onRenderMessage = function(data) {
    var args = data["args"];
    if (args == null) {
      console.error("Got null args in onRenderMessage. This should never happen");
      args = {};
    }
    var dataframeArgs = data["dfs"] && data["dfs"].length > 0 ? Streamlit2.argsDataframeToObject(data["dfs"]) : {};
    args = __assign(__assign({}, args), dataframeArgs);
    var disabled = Boolean(data["disabled"]);
    var theme = data["theme"];
    if (theme) {
      _injectTheme(theme);
    }
    var eventData = { disabled, args, theme };
    var event = new CustomEvent(Streamlit2.RENDER_EVENT, {
      detail: eventData
    });
    Streamlit2.events.dispatchEvent(event);
  };
  Streamlit2.argsDataframeToObject = function(argsDataframe) {
    var argsDataframeArrow = argsDataframe.map(function(_a) {
      var key = _a.key, value = _a.value;
      return [key, Streamlit2.toArrowTable(value)];
    });
    return Object.fromEntries(argsDataframeArrow);
  };
  Streamlit2.toArrowTable = function(df) {
    var _a = df.data, data = _a.data, index = _a.index, columns = _a.columns, styler = _a.styler;
    return new ArrowTable(data, index, columns, styler);
  };
  Streamlit2.sendBackMsg = function(type, data) {
    window.parent.postMessage(__assign({ isStreamlitMessage: true, type }, data), "*");
  };
  return Streamlit2;
}();
var _injectTheme = function(theme) {
  var style = document.createElement("style");
  document.head.appendChild(style);
  style.innerHTML = "\n    :root {\n      --primary-color: " + theme.primaryColor + ";\n      --background-color: " + theme.backgroundColor + ";\n      --secondary-background-color: " + theme.secondaryBackgroundColor + ";\n      --text-color: " + theme.textColor + ";\n      --font: " + theme.font + ";\n    }\n\n    body {\n      background-color: var(--background-color);\n      color: var(--text-color);\n    }\n  ";
};
function isTypedArray(value) {
  var isBigIntArray = false;
  try {
    isBigIntArray = value instanceof BigInt64Array || value instanceof BigUint64Array;
  } catch (e) {
  }
  return value instanceof Int8Array || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int16Array || value instanceof Uint16Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Float32Array || value instanceof Float64Array || isBigIntArray;
}

// node_modules/streamlit-component-lib/dist/StreamlitReact.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var StreamlitComponentBase = function(_super) {
  __extends(StreamlitComponentBase2, _super);
  function StreamlitComponentBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  StreamlitComponentBase2.prototype.componentDidMount = function() {
    Streamlit.setFrameHeight();
  };
  StreamlitComponentBase2.prototype.componentDidUpdate = function() {
    Streamlit.setFrameHeight();
  };
  return StreamlitComponentBase2;
}(import_react.default.PureComponent);
function withStreamlitConnection(WrappedComponent) {
  var ComponentWrapper = function(_super) {
    __extends(ComponentWrapper2, _super);
    function ComponentWrapper2(props) {
      var _this = _super.call(this, props) || this;
      _this.componentDidMount = function() {
        Streamlit.events.addEventListener(Streamlit.RENDER_EVENT, _this.onRenderEvent);
        Streamlit.setComponentReady();
      };
      _this.componentDidUpdate = function() {
        if (_this.state.componentError != null) {
          Streamlit.setFrameHeight();
        }
      };
      _this.componentWillUnmount = function() {
        Streamlit.events.removeEventListener(Streamlit.RENDER_EVENT, _this.onRenderEvent);
      };
      _this.onRenderEvent = function(event) {
        var renderEvent = event;
        _this.setState({ renderData: renderEvent.detail });
      };
      _this.render = function() {
        if (_this.state.componentError != null) {
          return import_react.default.createElement(
            "div",
            null,
            import_react.default.createElement("h1", null, "Component Error"),
            import_react.default.createElement("span", null, _this.state.componentError.message)
          );
        }
        if (_this.state.renderData == null) {
          return null;
        }
        return import_react.default.createElement(WrappedComponent, { width: window.innerWidth, disabled: _this.state.renderData.disabled, args: _this.state.renderData.args, theme: _this.state.renderData.theme });
      };
      _this.state = {
        renderData: void 0,
        componentError: void 0
      };
      return _this;
    }
    ComponentWrapper2.getDerivedStateFromError = function(error) {
      return { componentError: error };
    };
    return ComponentWrapper2;
  }(import_react.default.PureComponent);
  return (0, import_hoist_non_react_statics.default)(ComponentWrapper, WrappedComponent);
}
export {
  ArrowTable,
  Streamlit,
  StreamlitComponentBase,
  withStreamlitConnection
};
/**
 * @license
 * Copyright 2018-2021 Streamlit Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=streamlit-component-lib.js.map
